import 'package:flutter/material.dart';

import '../styling/textf_style_resolver.dart';
import 'format_stack_entry.dart';
import 'textf_token.dart';

/// Encapsulates the state of the parser during the text processing.
///
/// This class maintains all the necessary variables during the parsing process,
/// including the input tokens, the base text style, matching marker pairs,
/// the current formatting stack, and the style resolver. It also provides
/// methods for common state operations like flushing accumulated text
/// with the currently applied formatting.
class ParserState {
  /// Creates a new parser state.
  ///
  /// Requires the token list, the base text style, the map of valid
  /// matching marker pairs, and the style resolver.
  ParserState({
    required this.tokens,
    required this.baseStyle,
    required this.matchingPairs,
    required this.styleResolver,
    this.textScaler,
    this.placeholders,
  });

  /// The list of tokens generated by the tokenizer for the input text.
  final List<TextfToken> tokens;

  /// The base text style provided.
  final TextStyle baseStyle;

  /// A map of matching marker pairs.
  final Map<int, int> matchingPairs;

  /// The style resolver instance.
  final TextfStyleResolver styleResolver;

  /// The list where generated InlineSpans are collected.
  final List<InlineSpan> spans = [];

  /// A buffer for accumulating plain text content between formatting markers.
  final StringBuffer textBuffer = StringBuffer();

  /// A stack tracking the currently active formatting markers.
  final List<FormatStackEntry> formatStack = [];

  /// An optional `TextScaler` for scaling the text.
  final TextScaler? textScaler;

  /// Optional map of inline spans to substitute into placeholders.
  /// Keys correspond to the text inside braces (e.g., "icon" matches "{icon}").
  final Map<String, InlineSpan>? placeholders;

  /// Resolves the current style based on the format stack and base style.
  TextStyle getCurrentStyle(BuildContext context) {
    if (formatStack.isEmpty) {
      return baseStyle;
    }

    TextStyle currentStyle = baseStyle;
    for (final FormatStackEntry entry in formatStack) {
      currentStyle = styleResolver.resolveStyle(entry.type, currentStyle);
    }
    return currentStyle;
  }

  /// Flushes the accumulated `textBuffer` as a `TextSpan` with the current formatting applied.
  ///
  /// This method calculates the effective text style by starting with `baseStyle`
  /// and iteratively applying the styles corresponding to the markers currently
  /// on the `formatStack`, using the `styleResolver`. It then creates a `TextSpan`
  /// with the calculated style and the buffered text, adds it to the `spans` list,
  /// and clears the `textBuffer`.
  ///
  /// - [context]: The BuildContext, needed by the styleResolver.
  void flushText(BuildContext context) {
    if (textBuffer.isEmpty) return;

    final String text = textBuffer.toString();
    final currentStyle = getCurrentStyle(context);

    final bool isSuperscript =
        formatStack.any((e) => e.type == FormatMarkerType.superscript);
    final bool isSubscript =
        formatStack.any((e) => e.type == FormatMarkerType.subscript);

    if (isSuperscript || isSubscript) {
      spans.add(
        styleResolver.createScriptSpan(
          text: text,
          style: currentStyle,
          isSuperscript: isSuperscript,
        ),
      );
    } else {
      spans.add(TextSpan(text: text, style: currentStyle));
    }

    textBuffer.clear();
  }
}
