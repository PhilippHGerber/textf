import 'package:flutter/material.dart';

import '../styling/textf_style_resolver.dart';
import 'format_stack_entry.dart';
import 'token_type.dart';

/// Encapsulates the state of the parser during the text processing.
///
/// This class maintains all the necessary variables during the parsing process,
/// including the input tokens, the base text style, matching marker pairs,
/// the current formatting stack, and the style resolver. It also provides
/// methods for common state operations like flushing accumulated text
/// with the currently applied formatting.
class ParserState {
  /// Creates a new parser state.
  ///
  /// Requires the token list, the base text style, the map of valid
  /// matching marker pairs, and the style resolver.
  ParserState({
    required this.tokens,
    required this.baseStyle,
    required this.matchingPairs,
    required this.styleResolver,
    this.textScaler,
    this.inlineSpans,
  });

  /// The list of tokens generated by the tokenizer for the input text.
  final List<Token> tokens;

  /// The base text style provided.
  final TextStyle baseStyle;

  /// A map of matching marker pairs.
  final Map<int, int> matchingPairs;

  /// The style resolver instance.
  final TextfStyleResolver styleResolver;

  /// The list where generated InlineSpans are collected.
  final List<InlineSpan> spans = [];

  /// A buffer for accumulating plain text content between formatting markers.
  String textBuffer = '';

  /// A stack tracking the currently active formatting markers.
  final List<FormatStackEntry> formatStack = [];

  /// An optional `TextScaler` for scaling the text.
  final TextScaler? textScaler;

  /// Optional list of inline spans to substitute into placeholders.
  final List<InlineSpan>? inlineSpans;

  /// Resolves the current style based on the format stack and base style.
  TextStyle getCurrentStyle(BuildContext context) {
    if (formatStack.isEmpty) {
      return baseStyle;
    }

    TextStyle currentStyle = baseStyle;
    for (final FormatStackEntry entry in formatStack) {
      currentStyle = styleResolver.resolveStyle(entry.type, currentStyle);
    }
    return currentStyle;
  }

  /// Flushes the accumulated `textBuffer` as a `TextSpan` with the current formatting applied.
  ///
  /// This method calculates the effective text style by starting with `baseStyle`
  /// and iteratively applying the styles corresponding to the markers currently
  /// on the `formatStack`, using the `styleResolver`. It then creates a `TextSpan`
  /// with the calculated style and the buffered text, adds it to the `spans` list,
  /// and clears the `textBuffer`.
  ///
  /// - [context]: The BuildContext, needed by the styleResolver. Although the resolver
  ///              already holds the context, passing it here ensures clarity or
  ///              allows for potential future flexibility if the resolver becomes context-dependent per call.
  ///              Alternatively, the resolver could just use its own stored context.
  ///              Let's keep it for now for clarity, assuming the resolver might need it per-call.
  void flushText(BuildContext context) {
    if (textBuffer.isEmpty) return;

    final currentStyle = getCurrentStyle(context);

    final bool isSuperscript = formatStack.any((e) => e.type == TokenType.superscriptMarker);
    final bool isSubscript = formatStack.any((e) => e.type == TokenType.subscriptMarker);

    if (isSuperscript || isSubscript) {
      spans.add(
        styleResolver.createScriptSpan(
          text: textBuffer,
          style: currentStyle,
          isSuperscript: isSuperscript,
        ),
      );
    } else {
      spans.add(TextSpan(text: textBuffer, style: currentStyle));
    }

    textBuffer = '';
  }
}
