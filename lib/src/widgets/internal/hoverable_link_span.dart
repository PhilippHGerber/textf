import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// An internal StatefulWidget used by Textf's LinkHandler to render interactive links
/// that can visually change style on hover.
///
/// This widget manages its own hover state (`_isHovering`) and switches
/// between the provided `normalStyle` and `hoverStyle`. It renders a
/// single `Text.rich` containing the link's content (either plain text
/// or pre-parsed child spans passed via `initialChildrenSpans` or `initialPlainText`).
///
/// It's intended to be wrapped within a `WidgetSpan` by the `LinkHandler`.
class HoverableLinkSpan extends StatefulWidget {
  /// The target URL of the link.
  final String url;

  /// The original, raw display text of the link as it appeared in the
  /// source string (including formatting markers). Used for callbacks.
  final String rawDisplayText;

  /// Pre-parsed list of `InlineSpan` children if the link's display
  /// text itself contained formatting (e.g., `[**bold** link](url)`).
  /// Should be empty if `initialPlainText` is provided.
  final List<InlineSpan> initialChildrenSpans;

  /// The plain display text of the link, used if `initialChildrenSpans` is empty.
  final String? initialPlainText;

  /// The style to apply when the link is not hovered. Resolved by TextfStyleResolver.
  final TextStyle normalStyle;

  /// The style to apply when the link is hovered. Resolved by TextfStyleResolver.
  final TextStyle hoverStyle;

  /// An optional pre-configured `TapGestureRecognizer` for handling taps.
  /// Created by LinkHandler if an `onUrlTap` callback is available.
  final TapGestureRecognizer? tapRecognizer;

  /// The mouse cursor to display when hovering over the link. Resolved by TextfStyleResolver.
  final MouseCursor mouseCursor;

  /// An optional callback function triggered when the hover state changes.
  /// Resolved by TextfStyleResolver. Provides the URL, the raw display text,
  /// and the new hover state (`true` for enter, `false` for exit).
  final Function(String url, String rawDisplayText, bool isHovering)? onHoverCallback;

  /// Creates an internal widget to manage hover state and interaction for a link.
  const HoverableLinkSpan({
    super.key,
    required this.url,
    required this.rawDisplayText,
    required this.initialChildrenSpans,
    this.initialPlainText,
    required this.normalStyle,
    required this.hoverStyle,
    required this.tapRecognizer,
    required this.mouseCursor,
    this.onHoverCallback,
  });

  @override
  State<HoverableLinkSpan> createState() => HoverableLinkSpanState();
}

class HoverableLinkSpanState extends State<HoverableLinkSpan> {
  /// Tracks whether the mouse cursor is currently over this specific link instance.
  bool _isHovering = false;

  @override
  void dispose() {
    // If a TapGestureRecognizer was created and passed in,
    // it must be disposed when the widget is removed to prevent memory leaks.
    widget.tapRecognizer?.dispose();
    super.dispose();
  }

  /// Handles the pointer entering the bounds of the link.
  void _onEnter(PointerEnterEvent event) {
    if (mounted) {
      setState(() => _isHovering = true);
      // Notify listener about hover start, passing URL and raw text
      widget.onHoverCallback?.call(widget.url, widget.rawDisplayText, true);
    }
  }

  /// Handles the pointer exiting the bounds of the link.
  void _onExit(PointerExitEvent event) {
    if (mounted) {
      setState(() => _isHovering = false);
      // Notify listener about hover end
      widget.onHoverCallback?.call(widget.url, widget.rawDisplayText, false);
    }
  }

  /// Recursively applies interaction handlers (tap recognizer, hover callbacks, cursor)
  /// and the correct style (normal or hover) to a given InlineSpan and its children.
  /// This ensures that the entire clickable/hoverable area of the link reacts appropriately.
  InlineSpan _applyInteraction(InlineSpan span) {
    // Only process TextSpans, leave other types (like WidgetSpan) untouched.
    if (span is TextSpan) {
      // 1. Get the base style of the inner span. This style already includes
      //    any nested formatting (like bold, italic) applied by the inner parse
      //    of the link's display text.
      //    Fallback to the widget's normalStyle if the inner span somehow has no style,
      //    which is unlikely for spans generated by the parser but safe to handle.
      final TextStyle innerSpanStyle = span.style ?? widget.normalStyle;

      // 2. Determine the target style properties for the *link's visual appearance*
      //    (typically color and decoration) based on the current hover state (_isHovering).
      //    This will be either the widget.normalStyle or widget.hoverStyle passed in.
      final TextStyle targetLinkAppearance = _isHovering ? widget.hoverStyle : widget.normalStyle;

      // 3. Create the final style for this specific TextSpan segment:
      //    Start with the inner span's style (which contains its specific formatting
      //    like bold or italic).
      //    Then, specifically override only the properties relevant to the overall link's
      //    visual state (color, decoration, decorationColor) using the values
      //    from the resolved targetLinkAppearance (normal or hover).
      //    This ensures that existing fontWeight, fontStyle, backgroundColor, etc.,
      //    from the inner span's original style are preserved.
      final TextStyle finalSpanStyle = innerSpanStyle.copyWith(
        color: targetLinkAppearance.color, // Apply the link's current color (normal or hover)
        decoration: targetLinkAppearance.decoration, // Apply the link's current decoration (e.g., underline or none)
        decorationColor: targetLinkAppearance.decorationColor, // Apply the link's current decoration color
        // Note: We intentionally DO NOT copy fontWeight, fontStyle, backgroundColor,
        // letterSpacing, etc., from targetLinkAppearance here. We want those properties
        // to be determined by the innerSpanStyle to maintain the nested formatting.
      );

      // 4. Rebuild the TextSpan using the carefully combined style and add the recognizer.
      return TextSpan(
        text: span.text,
        // Recursively apply this interaction logic to children if the original span had children.
        // This handles potentially complex InlineSpan structures within the link,
        // although Textf's parser typically creates a flat list of spans where each
        // formatted segment is a separate TextSpan.
        children: span.children?.map(_applyInteraction).toList(),
        style: finalSpanStyle, // Apply the combined style that preserves nested formats + adds link appearance
        recognizer: widget.tapRecognizer, // Add the tap recognizer if it exists for interactivity
        // Mouse cursor and hover events (onEnter/onExit) are now handled by the
        // outer MouseRegion wrapping the HoverableLinkSpan widget in its build method.
        // Setting them to null here avoids potential conflicts or redundancy.
        mouseCursor: null,
        onEnter: null,
        onExit: null,
        semanticsLabel: span.semanticsLabel, // Preserve accessibility labels
        locale: span.locale, // Preserve locale information
        spellOut: span.spellOut, // Preserve spell-out information
      );
    }
    // Return other span types (like WidgetSpan, though unlikely inside Textf links) unmodified.
    return span;
  }

  @override
  Widget build(BuildContext context) {
    // Determine the initial content spans: either the pre-parsed children
    // or a single TextSpan containing the plain text.
    // Note: The initial spans/text don't yet have the interaction handlers attached.
    final List<InlineSpan> initialContentSpans = widget.initialChildrenSpans.isNotEmpty
        ? widget.initialChildrenSpans
        // If plain text, wrap it in a TextSpan. Use normalStyle as the base here,
        // though _applyInteraction will merge the final normal/hover style again.
        : [TextSpan(text: widget.initialPlainText, style: widget.normalStyle)];

    // Apply interaction handlers and correct styling (normal/hover) recursively
    // to the initial content spans.
    final List<InlineSpan> interactiveSpans = initialContentSpans
        .map(_applyInteraction) // Apply handlers and styles
        .toList();

    // Render the resulting interactive spans within a Text.rich widget.
    // The outer TextSpan has no text or style itself, just acts as a container.
    return MouseRegion(
      cursor: widget.mouseCursor, // Der 端bergebene Cursor (z.B. help)
      onEnter: _onEnter, // Eigene Methode f端r Hover-Effekte
      onExit: _onExit, // Eigene Methode f端r Hover-Effekte
      opaque: false, // Wichtig f端r Textselektion
      child: Text.rich(
        TextSpan(
          children: interactiveSpans,
        ),
      ),
    );
  }
}
