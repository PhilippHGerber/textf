# Project Documentation: textf v0.6.1

Generated by llmifier on: 2025-07-31T11:24:31
Extraction Mode: full
Project Type: dart

---

<!-- BEGIN FILE: [v0.6.1] README.md -->
# Text*f*

[![pub package](https://img.shields.io/pub/v/textf.svg)](https://pub.dev/packages/textf) [![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)

A Flutter widget for inline text formatting ‚Äî fully compatible with Flutter‚Äôs `Text` widget.
Easily replace `Text` with `Textf` to add simple formatting:

```dart
Textf('Hello **Flutter**. Build for ==any screen== !');
```

![image](https://github.com/PhilippHGerber/textf/raw/main/images/textf.png)

> **‚ö†Ô∏è Important:**
> Textf is designed for inline styling only and is not a full Markdown renderer. It doesn't support block elements like lists, headings, or images.


## Overview

Textf provides basic text formatting capabilities similar to a subset of Markdown syntax, focusing exclusively on inline styles. It's designed for situations where you need simple text formatting without the overhead of a full Markdown rendering solution.

### About the Name

The name "Textf" is inspired by the C standard library function `printf` (print formatted), which formats text and writes it to standard output. Similarly, `Textf` (Text formatted) provides simple, efficient text formatting for Flutter applications.

### Why Text*f*?

* **Lightweight** ‚Äì Significantly smaller and faster than full Markdown packages
* **Performance-focused** ‚Äì Optimized for speed and memory efficiency
* **Flutter-native** ‚Äì Uses the familiar Text API for seamless integration
* **Zero dependencies** ‚Äì No external packages required
* **Interactive links** ‚Äì Built-in link support with customizable styles and hover effects

Perfect for chat applications, comment sections, UI elements, and any scenario where simple inline formatting is all you need.

## Installation

Add Textf to your `pubspec.yaml`:

```yaml
dependencies:
  textf: ^0.6.1
```

Then run:

```bash
flutter pub get
```

## Requirements

* Flutter: >=3.0.0

## Getting Started

Import the package and use it like a regular Text widget:

```dart
import 'package:textf/textf.dart';

class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Textf(
      'Hello **bold** *italic* ~~strikethrough~~ `code` '
      '++underline++ ==highlight== '
      '[link](https://flutter.dev)',
      style: TextStyle(fontSize: 16),
    );
  }
}
```

![image](https://github.com/PhilippHGerber/textf/raw/main/images/example.png)

## Supported Formatting

Textf supports the following inline formatting syntax, similar to a subset of Markdown:

| Format        | Syntax                       | Result                              |
| ------------- | ---------------------------- | ----------------------------------- |
| Bold          | `**bold**` or `__bold__`     | **bold**                            |
| Italic        | `*italic*` or `_italic_`     | *italic*                            |
| Bold+Italic   | `***both***` or `___both___` | ***both***                          |
| Strikethrough | `~~strikethrough~~`          | ~~strikethrough~~                   |
| Underline     | `++underline++`              | ++underline++                       |
| Highlight     | `==highlight==`              | ==highlight==                       |
| Code          | `` `code` ``                 | `code`                              |
| Link          | `[text](url)`                | [Example Link](https://example.com) |

---

### Links `[text](url)`

![image](https://github.com/PhilippHGerber/textf/raw/main/images/link-hover.gif)

* **Syntax:** Enclose the display text in square brackets `[]` and the URL in parentheses `()`.
* **Rendering:** Links are rendered with a distinct style (usually blue and underlined) that can be customized via `TextfOptions`.
* **Interaction:**
  * `Textf` renders links as tappable/clickable elements.
  * To handle taps (e.g., open the URL) or hovers, wrap your `Textf` widget (or a parent widget containing multiple `Textf` widgets) with `TextfOptions` and provide the `onUrlTap` and/or `onUrlHover` callbacks.
  * `TextfOptions` also allows custom styling for links (`urlStyle`, `urlHoverStyle`) and mouse cursor (`urlMouseCursor`).
* **Nested Formatting:** The display text within the square brackets `[ ]` can contain other formatting markers (e.g., `[**bold link**](https://example.com)`).

```dart
// Example using TextfOptions for link interaction and styling
TextfOptions(
  // Optional: Customize link styles globally for descendants
  urlStyle: TextStyle(color: Colors.green),
  urlHoverStyle: TextStyle(fontWeight: FontWeight.bold),
  onUrlTap: (url, rawDisplayText) {
    // Implement URL launching logic (e.g., using url_launcher package)
    print('Tapped URL: $url (Display Text: $rawDisplayText)');
  },
  onUrlHover: (url, rawDisplayText, isHovering) {
    // Handle hover effects (e.g., change cursor, update UI state)
    print('Hovering over $url: $isHovering');
  },
  child: Textf(
    'Visit [**Flutter website**](https://flutter.dev) or [this link](https://example.com).',
    style: TextStyle(fontSize: 16),
  ),
)

```

### Nesting Formatting

When nesting formatting, use different marker types (asterisks vs underscores) to ensure proper parsing:

| Format            | Correct                  | Incorrect                |
| ----------------- | ------------------------ | ------------------------ |
| Nested formatting | `**Bold with _italic_**` | `**Bold with *italic***` |

Using the same marker type for nested formatting may result in unexpected rendering.

### Example

```dart
Textf(
  'The **quick** _brown_ fox jumps over \n'
  'the ~~lazy~~ ++wily++ ==alert== `dog`. \*Escaped asterisks\*',
  style: TextStyle(fontSize: 18),
  textAlign: TextAlign.center,
)
```

![image](https://github.com/PhilippHGerber/textf/raw/main/images/quick_brown_fox.png)

## Customizing with TextfOptions

The `TextfOptions` widget allows you to customize the appearance and behavior of formatted text throughout your app. It uses the InheritedWidget pattern to make configuration available to all descendant `Textf` widgets.

When resolving styles or callbacks, Textf searches up the widget tree for the nearest `TextfOptions` ancestor that defines the specific property (e.g., `boldStyle`, `onUrlTap`). If no ancestor defines it, theme-based defaults (for code/links) or package defaults (for bold, italic, strikethrough) are used.

### Basic Usage

```dart
// Import url_launcher if you need it for the tap callback
// import 'package:url_launcher/url_launcher.dart';

TextfOptions(
  // Styling options (merged onto the base style)
  boldStyle: TextStyle(fontWeight: FontWeight.w900, color: Colors.red),
  italicStyle: TextStyle(fontStyle: FontStyle.italic, color: Colors.blue),
  codeStyle: TextStyle(fontFamily: 'RobotoMono', backgroundColor: Colors.grey.shade200),

  strikethroughStyle: TextStyle(decorationColor: Colors.orange, decorationThickness: 3.0),

  underlineStyle: TextStyle(decoration: TextDecoration.underline, decorationColor: Colors.purple, decorationStyle: TextDecorationStyle.wavy),
  highlightStyle: TextStyle(backgroundColor: Colors.greenAccent.withOpacity(0.5), color: Colors.black),

  // Link options
  urlStyle: TextStyle(color: Colors.green),
  urlHoverStyle: TextStyle(decoration: TextDecoration.underline, fontWeight: FontWeight.bold),
  urlMouseCursor: SystemMouseCursors.click,

  // Link callbacks
  onUrlTap: (url, displayText) {
    // Example using url_launcher:
    // final uri = Uri.tryParse(url);
    // if (uri != null) {
    //   launchUrl(uri);
    // }
    print('Tapped URL: $url (Display Text: $displayText)');
  },
  onUrlHover: (url, displayText, isHovering) {
    print('Hover state changed for $url: $isHovering');
  },

  child: Textf(
    'This text has **bold**, *italic*, ~~strikethrough~~, `code`, '
    '++underline++, ==highlight==, '
    'and [links](https://example.com).',
    style: TextStyle(fontSize: 16),
  ),
)
```

**Available `TextfOptions` Properties:**

* **`boldStyle`**: `TextStyle?` for bold text (`**bold**` or `__bold__`).
  * Merged **onto** the base text style if provided.
  * If `null`, `DefaultStyles.boldStyle` (adds `FontWeight.bold`) is used as a fallback.
* **`italicStyle`**: `TextStyle?` for italic text (`*italic*` or `_italic_`).
  * Merged **onto** the base text style if provided.
  * If `null`, `DefaultStyles.italicStyle` (adds `FontStyle.italic`) is used as a fallback.
* **`boldItalicStyle`**: `TextStyle?` for bold and italic text (`***both***` or `___both___`).
  * Merged **onto** the base text style if provided.
  * If `null`, `DefaultStyles.boldItalicStyle` (adds `FontWeight.bold` and `FontStyle.italic`) is used as a fallback.
* **`strikethroughStyle`**: `TextStyle?` for strikethrough text (`~~strike~~`).
  * Merged **onto** the base text style if provided.
  * If `null`, the default strikethrough effect is applied using the resolved `strikethroughThickness`. Providing this overrides `strikethroughThickness`.
* **`strikethroughThickness`**: `double?` Specifies the thickness of the strikethrough line.
  * This property is **only used if `strikethroughStyle` is `null`**.
  * If both `strikethroughStyle` and `strikethroughThickness` are `null` in the entire ancestor chain, `DefaultStyles.defaultStrikethroughThickness` (`1.5`) is used.
* **`underlineStyle`**: `TextStyle?` for underlined text (`++underline++`).
  * Merged **onto** the base text style if provided.
  * If `null`, `DefaultStyles.underlineStyle` (adds `TextDecoration.underline`) is used as a fallback. The decoration color and thickness are derived from the base style or package defaults.
* **`highlightStyle`**: `TextStyle?` for highlighted text (`==highlight==`).
  * Merged **onto** the base text style if provided.
  * If `null`, a theme-aware default highlight style (e.g., using `Theme.of(context).colorScheme.tertiaryContainer` as background) is applied.
* **`codeStyle`**: `TextStyle?` for inline code text (`` `code` ``).
  * Merged **onto** the base text style if provided.
  * Overrides the default theme-based styling for code if specified.
* **`urlStyle`**: `TextStyle?` for link text (`[text](url)`) in its normal (non-hovered) state.
  * Merged **onto** the base text style if provided.
  * Overrides the default theme-based styling for links if specified.
* **`urlHoverStyle`**: `TextStyle?` for link text when hovered.
  * Merged **onto** the final *normal* link style (which includes base style and `urlStyle` if provided).
  * Allows defining specific hover appearances.
* **`urlMouseCursor`**: `MouseCursor?` The cursor to display when hovering over links.
  * Searches up the widget tree for the first non-null value.
  * If none found, defaults to `DefaultStyles.urlMouseCursor` (`SystemMouseCursors.click`).
* **`onUrlTap`**: Callback `Function(String url, String rawDisplayText)?` triggered when a link is tapped or clicked.
  * Searches up the widget tree for the first non-null callback.
  * Provides the resolved URL and the original, unparsed display text (e.g., `**bold** link`).
* **`onUrlHover`**: Callback `Function(String url, String rawDisplayText, bool isHovering)?` triggered when the mouse pointer enters or exits the bounds of a link.
  * Searches up the widget tree for the first non-null callback.
  * Provides the resolved URL, the raw display text, and the current hover state (`true` on enter, `false` on exit).

### Inheritance

When multiple `TextfOptions` are nested in the widget tree, options are inherited through the hierarchy. If a specific property (e.g., `boldStyle`, `strikethroughThickness`, `onUrlTap`) is `null` on the nearest ancestor `TextfOptions` widget, Textf automatically searches further up the widget tree for the first ancestor that *does* define that property. This allows for global defaults with specific overrides in subtrees.

```dart
TextfOptions(
  // Root level options (global defaults)
  boldStyle: TextStyle(fontWeight: FontWeight.w900),
  strikethroughThickness: 2.0, // Use thickness here, applies if style is null below
  urlStyle: TextStyle(color: Colors.blue),
  onUrlTap: (url, text) => print('Root tap: $url'),
  child: Column(
    crossAxisAlignment: CrossAxisAlignment.start, // Align text left for readability
    children: [
      Textf('This uses **blue links**, w900 bold, and ~~thickness 2.0~~.'),

      SizedBox(height: 16), // Add some spacing

      TextfOptions(
        // Override only URL style and strikethrough appearance for this subtree
        urlStyle: TextStyle(color: Colors.green),
        strikethroughStyle: TextStyle(decoration: TextDecoration.lineThrough, color: Colors.red, decorationThickness: 1.0), // Use full style here

        // boldStyle is inherited from the root
        // onUrlTap is inherited from the root
        // strikethroughThickness from root is IGNORED because strikethroughStyle is set here
        child: Textf('This uses **green links**, w900 bold, and ~~red line thickness 1.0~~.'),
      ),

      SizedBox(height: 16),

      TextfOptions(
         // Override only thickness, inherit bold/url/tap from root
         strikethroughThickness: 0.5,
         child: Textf('This uses **blue links**, w900 bold, and ~~very thin thickness 0.5~~.'),
      ),
    ],
  ),
)
```

## Styling Recommendations

To effectively style your `Textf` widgets and leverage the theme-aware defaults and customization options, follow these recommendations:

1. **Use `DefaultTextStyle` for Base Styles:**
    * **What:** Apply base styling like font size, default text color, or font family by wrapping `Textf` (or a common ancestor) with `DefaultTextStyle`.
    * **Why:** This is the standard Flutter approach for inherited text styles. It ensures that `Textf`'s theme-aware defaults (for code and links) and relative format styles (bold, italic) are correctly merged onto a consistent base style provided by your app's theme or your explicit `DefaultTextStyle`.

    ```dart
    // Good: Set base style via DefaultTextStyle
    DefaultTextStyle(
      style: Theme.of(context).textTheme.bodyLarge!.copyWith(color: Colors.deepPurple),
      child: Textf(
        'This text uses the default style. **Bold** inherits it, and `code` uses theme colors based on it.',
      ),
    )
    ```

2. **Use `TextfOptions` for Format-Specific Styles:**
    * **What:** Use `TextfOptions` to customize the appearance of specific formatting types (e.g., making bold text blue, changing link underlines, setting a custom code background).
    * **Why:** `TextfOptions` provides targeted overrides for how formatted segments look, taking precedence over theme and package defaults for those specific formats. See the "Customizing with TextfOptions" section for details.

3. **Use `Textf`'s `style` Parameter Cautiously:**
    * **What:** The `style` parameter directly on the `Textf` widget.
    * **Why:** Use this primarily for one-off style overrides on a specific `Textf` instance *where you don't want it to inherit from `DefaultTextStyle`*. Be aware that providing an explicit `style` here **replaces** the `DefaultTextStyle` when the parser calculates its internal base style. If this explicit `style` is incomplete (e.g., only sets `fontSize`), it can interfere with the correct application of theme-based defaults (like code background/color) for that specific instance. Prefer `DefaultTextStyle` for setting the base.

    ```dart
    // Use with caution: Might interfere with theme defaults for code/links within this Textf
    Textf(
      'Specific override `code`.',
      style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic), // Overrides DefaultTextStyle here
    )
    ```

4. **Understand Styling Precedence:**
    * `Textf` resolves styles in this order (highest priority first):
        1. **`TextfOptions`:** Specific style defined for the format type (e.g., `boldStyle`, `urlStyle`) found in the nearest ancestor `TextfOptions`.
        2. **Theme/Package Defaults (if no Option):**
            * For `code`, links, and `highlight`: Theme-aware defaults derived from `ThemeData` (e.g., `colorScheme.primary` for links).
            * For `bold`, `italic`, `strikethrough`, `underline`: Relative styles applied to the base style (e.g., adding `FontWeight.bold`).
        3. **Base Style:** The style inherited from `DefaultTextStyle` or provided directly via `Textf`'s `style` parameter.

By following these guidelines, you can ensure predictable styling that integrates well with your application's theme while retaining full control over specific formatting appearances via `TextfOptions`.

## Properties

Textf supports all the same styling properties as Flutter's standard Text widget:

```dart
Textf(
  'Formatted **text** example',
  style: TextStyle(fontSize: 16),
  strutStyle: StrutStyle(...),
  textAlign: TextAlign.center,
  textDirection: TextDirection.ltr,
  locale: Locale('en', 'US'),
  softWrap: true,
  overflow: TextOverflow.ellipsis,
  textScaler: TextScaler.linear(1.2),
  maxLines: 2,
  semanticsLabel: 'Example text',
)
```

## Performance

Textf is designed with performance in mind:

* **Optimized parsing** - Efficient tokenization algorithm
* **Smart caching** - Automatically caches parse results
* **Fast paths** - Quick handling of plain text without formatting
* **Memory efficient** - Minimal memory overhead

Performance benchmarks show Textf maintains smooth rendering (60+ FPS) even with frequent updates and complex formatting. Memory usage scales linearly with text length.

## Limitations

Textf is intentionally focused on inline formatting only:

* **Maximum nesting depth of 2 formatting levels**
* No support for block elements (headings, lists, quotes, etc.)
* No support for images
* Designed for inline formatting and links only, not full Markdown rendering

If you need more comprehensive Markdown features, consider a full Markdown package.

## Roadmap

### Implemented Features

* ‚úÖ Bold formatting with `**text**` or `__text__`
* ‚úÖ Italic formatting with `*text*` or `_text_`
* ‚úÖ Combined bold+italic with `***text***` or `___text___`
* ‚úÖ Strikethrough with `~~text~~`
* ‚úÖ Inline code with `` `code` ``
* ‚úÖ Underline with `++underline++`
* ‚úÖ Highlight with `==highlight==`
* ‚úÖ Nested formatting (up to 2 levels deep)
* ‚úÖ Escaped characters with backslash
* ‚úÖ Fast paths for plain text
* ‚úÖ Link support with `[text](url)`
* ‚úÖ Custom styles for each formatting type
* ‚úÖ Full support for Flutter text properties

### Planned Features

* üî≤ Superscript and subscript with `^text^` and `~text~`: Textf('E = mc^2^ and H~2~O')
* üî≤ RTL language optimization
* üî≤ Improved accessibility features

## When to Use Text*f*

* ‚úÖ When you need simple inline text formatting
* ‚úÖ When performance is critical
* ‚úÖ When you want a familiar Flutter Text-like API
* ‚úÖ For chat messages, comments, captions, or UI labels
* ‚úÖ For internationalized text with formatting
* ‚ùå When you need full Markdown with blocks, links, images
* ‚ùå When you need HTML rendering
* ‚ùå For complex document rendering

## Internationalization (i18n)

Text*f* is particularly valuable for applications requiring internationalization:

### Why Text*f* is Great for i18n

* **Translator-friendly syntax** - Simple formatting that non-technical translators can understand
* **Consistent across languages** - Maintain formatting regardless of text length or language
* **Error-tolerant** - Gracefully handles formatting mistakes that might occur during translation
* **No HTML required** - Avoid HTML tags that might break during translation workflows

### Example with i18n

```dart
// In your translation file (e.g., app_en.arb)
{
  "welcomeMessage": "Welcome to **Flutter**, the _beautiful_ way to build apps!",
  "errorMessage": "__Oops!__ Something went *wrong*. Please try again."
}

// In your widget
Textf(
  AppLocalizations.of(context)!.welcomeMessage,
  style: Theme.of(context).textTheme.bodyLarge,
)
```

This approach allows translators to focus on the content while preserving formatting instructions as simple text markers rather than complex HTML or widgets.

## Error Handling

Textf handles malformed formatting gracefully:

* Unclosed tags are treated as plain text
* Excessive nesting is prevented
* Escaped characters are properly rendered

## API Documentation

For complete API documentation, see the [API reference](https://pub.dev/documentation/textf/latest/) on pub.dev.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

<!-- END FILE: [v0.6.1] README.md -->

<!-- BEGIN FILE: [v0.6.1] CHANGELOG.md -->
# Changelog

All notable changes to the `textf` package will be documented in this file.

## 0.6.1

### Changed

- Formatted codebase for consistency and readability
- Updated documentation for clarity and completeness

## 0.6.0

### BREAKING CHANGES

- **Style Inheritance Logic:** The logic for inheriting `TextStyle` properties from nested `TextfOptions` has been completely refactored to be more intuitive and powerful.
  - **Previous Behavior:** A `TextStyle` property (like `boldStyle`) in a child `TextfOptions` would completely overwrite the style from a parent. For example, a child's `decoration` would replace the parent's `decoration`.
  - **New Behavior:** `TextStyle` properties are now merged down the tree. Decorations from parent and child `TextfOptions` are intelligently combined, allowing for layering (e.g., adding a strikethrough to text that is already underlined by a parent).

### Fixed

- TextfOptions does not combine decorations from nested widgets (#3)

## 0.5.1

### Added

- Example for pub.dev

## 0.5.0

### Breaking Changes

- **Hover Callbacks:** Changed hover callback parameters from positional to named parameters for improved API clarity. The `onUrlHover` callback now uses `isHovering` as a named parameter:

  ```dart
  // Before:
  onUrlHover: (url, displayText, true)

  // After:
  onUrlHover: (url, displayText, isHovering: true)
  ```

### Added

- **Enhanced Code Analysis:** Integrated `very_good_analysis` and `dart_code_metrics` for improved code quality and consistency
- **Unit Tests:** Added comprehensive unit tests for `NestingValidator` class

## 0.4.1

### Removed

- Removed unnecessary files

## 0.4.0

2025-05-18

### Added

- **Underline Formatting:** Implemented support for underline formatting with `++text++` syntax.

- **Highlight Formatting:** Implemented support for highlight formatting with `==text==` syntax.

- **Improved Decoration Handling:** Default styles for strikethrough and underline now attempt to combine with existing decorations on the base style, allowing for concurrent `++~~underline and strikethrough~~++`. `decorationColor` and `decorationThickness` from the most recently applied default decoration or `TextfOptions` will take precedence for the combined decoration.

### Changed

- **TextfOptions:** Extended with `underlineStyle` and `highlightStyle` properties.
- **Link Formatting:**
  - Nested text decorations within link display text (e.g., `[~~strikethrough~~](url)`) are now correctly combined with the link's own decoration (e.g., underline), ensuring both are visually applied.
  - Improved application of `TextfOptions.urlHoverStyle`, ensuring hover-specific styles correctly merge with the link's resolved normal appearance, preserving properties like color and font size unless explicitly overridden by the hover style.
- **Internal Refactoring:** Enhanced `TokenType` enum to directly indicate if a token is for links or formatting. This improves internal parsing logic in `PairingResolver` and `TextfParser` for minor performance gains and better code clarity. (Thanks @timmaffett!)

## 0.3.0

2025-04-18

### Added

- **Theme-Aware Default Styling:** Implemented theme-aware default styling for inline code (`` `code` ``) and links (`[text](url)`). Their appearance now automatically adapts to the application's `ThemeData` (e.g., using `colorScheme.primary` for links, theme-appropriate background/text for code) unless overridden by `TextfOptions`.
- **`strikethroughThickness` Option:** Added the `strikethroughThickness` property to `TextfOptions` to allow customizing the line thickness for `~~strikethrough~~` text when not providing a full `strikethroughStyle`.
- **`TextScaler` Support:** Added support for the `textScaler` property, allowing `Textf` to respect system font scaling settings and custom `TextScaler` instances, similar to the standard `Text` widget.

### Changed

- **Documentation:** Significantly enhanced `README.md` with detailed explanations of all `TextfOptions` properties, their inheritance behavior, and added styling recommendations.
- **Code Font Defaults:** Improved default font family fallbacks for inline code (`code`) for better cross-platform rendering when a specific `codeStyle` is not provided (uses `RobotoMono`, `Menlo`, `Courier New`, `monospace`).

### Removed

- **Internal Caching:** Removed the internal caching mechanism for parsed results to simplify the parsing logic and resolve potential inconsistencies during hot reload. Performance remains optimized through efficient algorithms.

### Fixed

- **Internal:** Updated internal tests to correctly account for the new theme-aware default styles.

## 0.2.1

2025-04-12

### Fixed

- **Hot Reload Reliability:** Fixed an issue where changes made to `TextfOptions` (e.g., custom colors, styles) or internal formatting logic might not render correctly immediately after using hot reload during development. The internal parser cache is now properly invalidated only in debug mode during `reassemble`, ensuring UI consistency and improving the development workflow without affecting release build performance.

## 0.2.0

2025-04-12

### Added

- **Link Support**: Implemented full support for Markdown-style links with `[text](url)` syntax
  - Added interactive link styling with customizable colors and decorations
  - Created hover effects for links with mouse cursor changes
  - Enabled nested formatting within link text (e.g., `[**bold** link](url)`)
  - Added `onUrlTap` and `onUrlHover` callbacks for link interaction

- **TextfOptions**: Introduced a new widget to customize text formatting styles
  - Global styling options for all formatting types (bold, italic, code, etc.)
  - Configurable link appearance and behavior
  - Inheritance-based configuration through the widget tree

- **Enhanced Styling**: Added support for more detailed text styling
  - Font family customization for code blocks
  - Expanded default styles for each formatting type

### Fixed

- Updated default font family for inline code text to RobotoMono for better readability
- Enabled trailing commas in analysis options for code consistency

## 0.1.1

2025-04-05

### Changed

- Updated pubspec.yaml with simpler description to meet pub.dev guidelines
- Added publisher information to pubspec.yaml
- Removed example directory from .pubignore for better documentation

### Fixed

- Formatted code for tests to meet Dart style guidelines

## 0.1.0

2025-04-04

### Added

- Initial release of Textf lightweight text formatting widget
- Support for bold formatting with `**text**` or `__text__`
- Support for italic formatting with `*text*` or `_text_`
- Support for combined bold+italic with `***text***` or `___text___`
- Support for strikethrough with `~~text~~`
- Support for inline code with `` `code` ``
- Escape character support with backslash
- Performance optimization with caching
- Nested formatting support (up to 2 levels deep)

## 0.0.1

- Initial release of Textf widget.

<!-- END FILE: [v0.6.1] CHANGELOG.md -->

<!-- BEGIN FILE: [v0.6.1] LICENSE -->
MIT License

Copyright (c) 2025 Philipp H. Gerber

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

<!-- END FILE: [v0.6.1] LICENSE -->

<!-- BEGIN FILE: [v0.6.1] pubspec.yaml -->
name: textf
description: >
  A Flutter widget for inline text formatting ‚Äî fully compatible with Flutter‚Äôs Text widget.
  Easily replace Text with Textf to add simple formatting.
version: 0.6.1
homepage: https://github.com/PhilippHGerber/textf
repository: https://github.com/PhilippHGerber/textf
issue_tracker: https://github.com/PhilippHGerber/textf/issues

environment:
  sdk: ">=3.0.0 <4.0.0"
  flutter: ">=3.0.0"

dependencies:
  flutter:
    sdk: flutter

dev_dependencies:
  flutter_test:
    sdk: flutter
  very_good_analysis: ^9.0.0

topics:
  - text
  - widgets
  - markdown
  - formatting

screenshots:
  - description: "Textf Logo"
    path: pub/textf.webp

<!-- END FILE: [v0.6.1] pubspec.yaml -->

<!-- BEGIN FILE: [v0.6.1] analysis_options.yaml -->
include: package:very_good_analysis/analysis_options.yaml

formatter:
  page_width: 100
#  trailing_commas: preserve

analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
    - "benchmark/**"

  errors:
    unused_import: warning
    todo: ignore

linter:
  rules:
    # Allow relative imports for files within the same package
    always_use_package_imports: false
    # Prefer using relative imports within the same package
    prefer_relative_imports: true
    # Allow lines to exceed 80 characters
    lines_longer_than_80_chars: false
    # Prefer using const constructors where possible
    prefer_const_constructors: true
    # Prefer declaring local variables as final if they are not reassigned
    prefer_final_locals: true
    # Use trailing commas for all parameter lists and argument lists.
    require_trailing_commas: true
    # Allow mutable literal lists/maps/sets even if they could be const
    prefer_const_literals_to_create_immutables: false
    # Allow explicitly typing closure parameters
    avoid_types_on_closure_parameters: false
    # Allow TODOs without the Flutter-style format (e.g., missing author tags)
    flutter_style_todos: false
    # Omit type annotations for local variables.
    omit_local_variable_types: false

dart_code_metrics:
  rules:
    - avoid-cascade-after-if-null
    - avoid-duplicate-named-imports
    - avoid-dynamic
    - avoid-global-state
    - avoid-late-keyword
    - avoid-non-null-assertion
    - avoid-self-compare
    - avoid-substring
    - avoid-throw-in-catch-block
    - avoid-top-level-members-in-tests
    - binary-expression-operand-order
    - double-literal-format
    - no-boolean-literal-compare
    - no-empty-block
    - no-equal-then-else
    - no-magic-number
    - prefer-conditional-expressions
    - prefer-enums-by-name
    - prefer-first
    - prefer-immediate-return
    - prefer-iterable-of
    - prefer-last
    - prefer-match-file-name

<!-- END FILE: [v0.6.1] analysis_options.yaml -->

<!-- BEGIN FILE: [v0.6.1] lib/src/core/constants.dart -->
/// Asterisk character * (ASCII code 42)
///
/// Used for bold formatting (**) and italic formatting (*).
const int kAsterisk = 0x2A;

/// Underscore character _ (ASCII code 95)
///
/// Alternative marker for bold formatting (__) and italic formatting (_).
const int kUnderscore = 0x5F;

/// Tilde character ~ (ASCII code 126)
///
/// Used for strikethrough formatting (~~).
const int kTilde = 0x7E;

/// Backtick character ` (ASCII code 96)
///
/// Used for inline code formatting.
const int kBacktick = 0x60;

/// Equals character = (ASCII code 61)
/// Used for highlight formatting (==).
const int kEquals = 0x3D;

/// Plus character + (ASCII code 43)
/// Used for underline formatting (++).
const int kPlus = 0x2B;

/// Escape character \ (ASCII code 92)
///
/// Used to escape formatting characters, preventing them from being interpreted
/// as formatting markers.
const int kEscape = 0x5C;

/// Opening square bracket [ (ASCII code 91)
///
/// Used at the start of a link to denote the link text.
const int kOpenBracket = 0x5B;

/// Closing square bracket ] (ASCII code 93)
///
/// Used at the end of link text.
const int kCloseBracket = 0x5D;

/// Opening parenthesis ( (ASCII code 40)
///
/// Used at the start of a link URL.
const int kOpenParen = 0x28;

/// Closing parenthesis ) (ASCII code 41)
///
/// Used at the end of a link URL.
const int kCloseParen = 0x29;

<!-- END FILE: [v0.6.1] lib/src/core/constants.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/core/default_styles.dart -->
import 'package:flutter/material.dart';

/// Provides default styling behaviours used as fallbacks by TextfStyleResolver.
///
/// This class centralizes fallback styling configurations when neither
/// TextfOptions nor the application Theme provide specific guidance for a
/// particular formatting type.
class DefaultStyles {
  /// Default mouse cursor for URLs.
  /// Used as a fallback by TextfStyleResolver when no cursor is specified
  /// via TextfOptions in the widget tree.
  static const MouseCursor urlMouseCursor = SystemMouseCursors.click;

  /// Default alpha values for highlight background color.
  static const highlightAlphaDark = 0.4;

  /// Default alpha values for highlight background color.
  static const highlightAlphaLight = 0.5;

  /// Default font family fallback list for inline code (`code`).
  /// Used by TextfStyleResolver when applying theme-based code styling
  /// if no specific `codeStyle` (with font information) is provided via TextfOptions.
  /// Includes 'monospace' as a final generic fallback.
  static const List<String> defaultCodeFontFamilyFallback = [
    'RobotoMono', // Commonly included via assets in Flutter projects using this package
    'Menlo', // Common monospace font on macOS
    'Courier New', // Common monospace font on Windows
    'monospace', // Generic CSS/platform fallback
  ];

  /// Default thickness for the strikethrough line decoration (`~~strikethrough~~`).
  /// Used by TextfStyleResolver when applying the default strikethrough effect
  /// if no specific `strikethroughThickness` is provided via TextfOptions.
  static const double defaultStrikethroughThickness = 1.5;

  /// Applies default bold formatting (`**bold**` or `__bold__`) to a base style.
  /// Used as a fallback by TextfStyleResolver if no `boldStyle` is found via TextfOptions.
  static TextStyle boldStyle(TextStyle baseStyle) {
    return baseStyle.copyWith(fontWeight: FontWeight.bold);
  }

  /// Applies default italic formatting (`*italic*` or `_italic_`) to a base style.
  /// Used as a fallback by TextfStyleResolver if no `italicStyle` is found via TextfOptions.
  static TextStyle italicStyle(TextStyle baseStyle) {
    return baseStyle.copyWith(fontStyle: FontStyle.italic);
  }

  /// Applies default bold and italic formatting (`***both***` or `___both___`) to a base style.
  /// Used as a fallback by TextfStyleResolver if no `boldItalicStyle` is found via TextfOptions.
  static TextStyle boldItalicStyle(TextStyle baseStyle) {
    return baseStyle.copyWith(
      fontWeight: FontWeight.bold,
      fontStyle: FontStyle.italic,
    );
  }

  /// Applies default strikethrough formatting (`~~strikethrough~~`) to a base style,
  /// using the specified line thickness.
  /// Used as a fallback by TextfStyleResolver if no `strikethroughStyle` is found
  /// via TextfOptions. The thickness resolved by the resolver (considering TextfOptions
  /// or the default) is passed in here.
  static TextStyle strikethroughStyle(
    TextStyle baseStyle, {
    double thickness = defaultStrikethroughThickness,
  }) {
    TextDecoration newDecoration = TextDecoration.lineThrough;
    // Combine with existing decoration if present
    if (baseStyle.decoration != null) {
      // Prevent combining with itself if somehow applied twice (defensive)
      final decoration = baseStyle.decoration;
      if (decoration != null && decoration.contains(TextDecoration.lineThrough)) {
        newDecoration = decoration;
      } else if (decoration != null) {
        newDecoration = TextDecoration.combine([decoration, TextDecoration.lineThrough]);
      }
    }

    // Use the base color for the line if available, otherwise let Flutter decide.
    // If combining decorations, the original decorationColor might be for a different part.
    // It's safer to let Flutter pick or for the user to specify a combined decorationColor via TextfOptions.
    // For simplicity here, we might just use baseStyle.color if no decorationColor is set.
    final Color? decorationColorToApply = baseStyle.decorationColor ?? baseStyle.color;

    return baseStyle.copyWith(
      decoration: newDecoration,
      decorationColor: decorationColorToApply,
      decorationThickness: thickness,
    );
  }

  /// Applies default underline formatting (`++underline++`) to a base style.
  /// Used as a fallback by TextfStyleResolver if no `underlineStyle` is found via TextfOptions.
  static TextStyle underlineStyle(TextStyle baseStyle) {
    TextDecoration newDecoration = TextDecoration.underline;
    // Combine with existing decoration if present
    final TextDecoration? decoration = baseStyle.decoration;
    if (decoration != null) {
      // Prevent combining with itself (defensive)
      newDecoration = decoration.contains(TextDecoration.underline)
          ? decoration
          : TextDecoration.combine([decoration, TextDecoration.underline]);
    }

    final Color? decorationColorToApply = baseStyle.decorationColor ?? baseStyle.color;

    return baseStyle.copyWith(
      decoration: newDecoration,
      decorationColor: decorationColorToApply,
      // Use baseStyle.decorationThickness if available, otherwise a sensible default or null.
      // This thickness applies to the new underline part.
      decorationThickness: baseStyle.decorationThickness ?? 1.0,
    );
  }

  /// Applies a simple default highlight formatting (`==highlight==`) to a base style.
  /// This is a very basic fallback. A theme-aware highlight style is generally preferred
  /// and would be implemented in `TextfStyleResolver`.
  /// Used as a fallback by TextfStyleResolver if no `highlightStyle` is found via TextfOptions
  /// AND no theme-based default is implemented or chosen in the resolver.
  static TextStyle highlightStyle(TextStyle baseStyle) {
    // A common, though not necessarily theme-adaptive, highlight color.
    // Brightness check could make it slightly more adaptive if used as a true last resort.
    final baseStyleColor = baseStyle.color;
    final bool isDark = baseStyleColor != null &&
        ThemeData.estimateBrightnessForColor(baseStyleColor) == Brightness.dark;

    return baseStyle.copyWith(
      backgroundColor: isDark
          ? Colors.yellow.withValues(alpha: highlightAlphaDark)
          : Colors.yellow.withValues(alpha: highlightAlphaLight),
      // Retain the original text color unless a specific contrast logic is needed.
      // color: baseStyle.color, // Text color usually remains the same for highlight
    );
  }
}

<!-- END FILE: [v0.6.1] lib/src/core/default_styles.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/core/formatting_utils.dart -->
import 'constants.dart';

/// Utility functions for text formatting operations.
class FormattingUtils {
  /// Checks if text contains any potential formatting characters.
  ///
  ///
  /// This is an optimization to quickly determine if text needs
  /// further parsing for formatting.
  ///
  /// This includes all characters that might trigger special formatting:
  /// asterisks, underscores, tildes, backticks, brackets, parentheses, and escapes.
  /// Use this for initial fast-path detection of potential formatting.
  static bool hasFormatting(String text) {
    for (int i = 0; i < text.length; i++) {
      final int char = text.codeUnitAt(i);
      if (char == kAsterisk ||
          char == kUnderscore ||
          char == kTilde ||
          char == kBacktick ||
          char == kEquals ||
          char == kPlus ||
          char == kEscape ||
          char == kOpenBracket ||
          char == kCloseBracket ||
          char == kOpenParen ||
          char == kCloseParen) {
        return true;
      }
    }

    return false;
  }

  /// Checks if text contains formatting marker characters only.
  ///
  /// This specifically checks for characters that indicate text styling
  /// (bold, italic, strikethrough, code) but not structural elements like links.
  /// Use this when checking for formatting within link text or other contexts
  /// where link syntax itself should be ignored.
  static bool hasFormattingMarkers(String text) {
    for (int i = 0; i < text.length; i++) {
      final int char = text.codeUnitAt(i);
      if (char == kAsterisk || // *
          char == kUnderscore || // _
          char == kTilde || // ~
          char == kBacktick || // `
          char == kEquals || // =
          char == kPlus || // +
          char == kEscape) {
        // \
        return true;
      }
    }

    return false;
  }
}

<!-- END FILE: [v0.6.1] lib/src/core/formatting_utils.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/models/format_stack_entry.dart -->
import 'token_type.dart';

/// Helper class for tracking format stack entries during parsing.
///
/// Each entry represents a formatting marker that has been opened
/// but not yet closed during the parsing process. This class helps
/// in tracking the nesting of formatting styles and ensures that
/// they are properly applied and removed in the correct order.
class FormatStackEntry {
  /// Creates a new format stack entry.
  const FormatStackEntry({
    required this.index,
    required this.matchingIndex,
    required this.type,
  });

  /// Index of the opening formatting marker in the token list.
  final int index;

  /// Index of the matching closing marker in the token list.
  final int matchingIndex;

  /// Type of the formatting marker.
  final TokenType type;

  @override
  String toString() => 'FormatStackEntry($type, $index -> $matchingIndex)';
}

<!-- END FILE: [v0.6.1] lib/src/models/format_stack_entry.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/models/parser_state.dart -->
import 'package:flutter/material.dart';

import '../styling/textf_style_resolver.dart';
import 'format_stack_entry.dart';
import 'token_type.dart';

/// Encapsulates the state of the parser during the text processing.
///
/// This class maintains all the necessary variables during the parsing process,
/// including the input tokens, the base text style, matching marker pairs,
/// the current formatting stack, and the style resolver. It also provides
/// methods for common state operations like flushing accumulated text
/// with the currently applied formatting.
class ParserState {
  /// Creates a new parser state.
  ///
  /// Requires the token list, the base text style, the map of valid
  /// matching marker pairs, and the style resolver.
  ParserState({
    required this.tokens,
    required this.baseStyle,
    required this.matchingPairs,
    required this.styleResolver,
    this.textScaler,
  });

  /// The list of tokens generated by the tokenizer for the input text.
  final List<Token> tokens;

  /// The base text style provided, potentially merged with DefaultTextStyle.
  /// This style acts as the starting point before applying any formatting.
  final TextStyle baseStyle;

  /// A map where keys are indices of opening formatting markers and values
  /// are the indices of their corresponding closing markers (and vice-versa).
  /// This map only contains *valid* pairs after nesting validation.
  final Map<int, int> matchingPairs;

  /// The style resolver instance used to determine the final style for
  /// each text segment, considering options, theme, and defaults.
  final TextfStyleResolver styleResolver;

  /// The list where generated InlineSpans (TextSpan, WidgetSpan) are collected.
  final List<InlineSpan> spans = [];

  /// A buffer for accumulating plain text content between formatting markers.
  String textBuffer = '';

  /// A stack tracking the currently active (opened but not yet closed)
  /// formatting markers. Used to determine the style for the textBuffer.
  final List<FormatStackEntry> formatStack = [];

  /// A set containing the indices of tokens that have already been processed
  /// by a handler (e.g., as part of a link structure or a formatting pair).
  /// Used to prevent double processing.
  final Set<int> processedIndices = {};

  /// An optional `TextScaler` for scaling the text.
  final TextScaler? textScaler;

  /// Flushes the accumulated `textBuffer` as a `TextSpan` with the current formatting applied.
  ///
  /// This method calculates the effective text style by starting with `baseStyle`
  /// and iteratively applying the styles corresponding to the markers currently
  /// on the `formatStack`, using the `styleResolver`. It then creates a `TextSpan`
  /// with the calculated style and the buffered text, adds it to the `spans` list,
  /// and clears the `textBuffer`.
  ///
  /// - [context]: The BuildContext, needed by the styleResolver. Although the resolver
  ///              already holds the context, passing it here ensures clarity or
  ///              allows for potential future flexibility if the resolver becomes context-dependent per call.
  ///              Alternatively, the resolver could just use its own stored context.
  ///              Let's keep it for now for clarity, assuming the resolver might need it per-call.
  void flushText(BuildContext context) {
    if (textBuffer.isEmpty) return; // Nothing to flush

    // Calculate the current style based on the format stack and the resolver
    TextStyle currentStyle = baseStyle;
    for (final FormatStackEntry entry in formatStack) {
      // Apply the style for the active format marker using the resolver
      currentStyle = styleResolver.resolveStyle(entry.type, currentStyle);
    }

    // Create and add the TextSpan
    spans.add(TextSpan(text: textBuffer, style: currentStyle));

    // Clear the buffer for the next segment
    textBuffer = '';
  }
}

<!-- END FILE: [v0.6.1] lib/src/models/parser_state.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/models/token_type.dart -->
/// Represents different types of formatting tokens in the parsing process.
///
/// Each type corresponds to a specific formatting feature supported by the Textf widget.
enum TokenType {
  /// Regular text content with no special formatting.
  text,

  /// Bold and italic formatting marker: '***' or '___'
  boldItalicMarker(isFormattingMarker: true),

  /// Bold formatting marker: '**' or '__'
  boldMarker(isFormattingMarker: true),

  /// Italic formatting marker: '*' or '_'
  italicMarker(isFormattingMarker: true),

  /// Strikethrough formatting marker: '~~'
  strikeMarker(isFormattingMarker: true),

  /// Inline code formatting marker: '`'
  codeMarker(isFormattingMarker: true),

  /// Highlight formatting marker: '=='
  highlightMarker(isFormattingMarker: true),

  /// Underline formatting marker: '++'
  underlineMarker(isFormattingMarker: true),

  /// Opening square bracket for link: '['
  linkStart(isLinkToken: true),

  /// Text content to be displayed for a link
  linkText(isLinkToken: true),

  /// Closing square bracket followed by opening parenthesis: ']('
  linkSeparator(isLinkToken: true),

  /// URL content of a link
  linkUrl(isLinkToken: true),

  /// Closing parenthesis for link: ')'
  linkEnd(isLinkToken: true),
  ;

  const TokenType({this.isFormattingMarker = false, this.isLinkToken = false});

  /// Indicates whether this token type is standard formatting marker.
  final bool isFormattingMarker;

  /// Indicates whether this token type is part of a link.
  final bool isLinkToken;
}

/// Represents a single token in the parsing process.
///
/// A token can be either a formatting marker or a segment of regular text.
/// Each token tracks its type, content value, and position within the original string.
class Token {
  /// Creates a new token with the specified properties.
  const Token(this.type, this.value, this.position, this.length);

  /// The type of this token (e.g., boldMarker, text).
  final TokenType type;

  /// The actual text content of this token.
  final String value;

  /// The starting position of this token in the original string.
  final int position;

  /// The length of this token in characters.
  final int length;

  @override
  String toString() => 'Token($type, "$value" at $position)';
}

<!-- END FILE: [v0.6.1] lib/src/models/token_type.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/parsing/textf_parser.dart -->
import 'package:flutter/material.dart';

import '../core/formatting_utils.dart';
import '../models/parser_state.dart';
import '../models/token_type.dart';
import '../styling/textf_style_resolver.dart';
import 'components/format_handler.dart';
import 'components/link_handler.dart';
import 'components/pairing_resolver.dart';
import 'textf_tokenizer.dart';

/// Parser for formatted text that converts formatting markers into styled text spans.
///
/// The [TextfParser] processes tokenized text, identifies matching formatting markers,
/// handles nesting, resolves styling using `TextfStyleResolver` (considering options,
/// theme, and defaults), and generates properly styled [InlineSpan] objects for rendering.
///
/// Key features:
/// - Style resolution aware of TextfOptions and application Theme.
/// - Fast paths for empty or plain unformatted text.
/// - Handles nested formatting.
/// - Handles malformed formatting by treating unpaired markers as plain text.
/// - Escaped character support (handled by the tokenizer).
/// - Support for [link text](url) with nested formatting inside links.
class TextfParser {
  /// Creates a new [TextfParser] instance.
  ///
  /// - [tokenizer]: An optional custom tokenizer instance. If not provided,
  ///   a default [TextfTokenizer] is created.
  TextfParser({
    TextfTokenizer? tokenizer,
  }) : _tokenizer = tokenizer ?? TextfTokenizer();

  /// TextfTokenizer instance used to break down text into tokens.
  final TextfTokenizer _tokenizer;

  /// Parses formatted text into a list of styled [InlineSpan] objects.
  ///
  /// This method orchestrates the parsing process:
  /// 1. Handles fast paths for empty or plain text (text without any potential markers).
  /// 2. Tokenizes the input text using the configured [TextfTokenizer].
  /// 3. Creates a `TextfStyleResolver` using the provided `context` to handle style lookups.
  /// 4. Identifies matching, valid pairs of formatting markers (e.g., `*...*`) using `PairingResolver`.
  ///    This step ensures only correctly paired markers are considered for formatting.
  /// 5. Creates a `ParserState` to manage the parsing progress, including tokens, valid pairs,
  ///    the style resolver, the current text buffer, active style stack, and processed token indices.
  /// 6. Iterates through the tokens:
  ///    - Skips tokens that have already been processed (e.g., as part of a link or format pair).
  ///    - Appends plain text tokens (`TokenType.text`) to the `ParserState`'s text buffer.
  ///    - If a `TokenType.linkStart` (`[`) is encountered, delegates processing to `LinkHandler`
  ///      to attempt parsing a complete `[link text](url)` structure. The handler manages
  ///      nested formatting within the link text and marks processed tokens.
  ///    - If a formatting marker token (`*`, `_`, `**`, `__`, `***`, `___`, `~`, `` ` ``) is found:
  ///        - Checks if this specific token instance is part of a *valid pair* identified in step 4.
  ///        - If **paired**, delegates processing to `FormatHandler`. This handler manages the
  ///          style stack (pushing/popping styles), flushes the text buffer with the previous style,
  ///          and marks both the opening and closing marker tokens as processed.
  ///        - If **unpaired**, treats the marker's literal value (e.g., "*") as plain text and
  ///          appends it to the `ParserState`'s text buffer. Marks the unpaired marker token as processed.
  ///    - Treats any other unexpected token types encountered during the loop as plain text.
  /// 7. After iterating through all tokens, flushes any remaining text in the `ParserState`'s
  ///    buffer using the current style context via `state.flushText()`.
  /// 8. Returns the final list of generated [InlineSpan] objects from the `ParserState`.
  ///
  /// - [text]: The input string potentially containing formatting markers.
  /// - [context]: The current build context, required for theme and options lookup by the `TextfStyleResolver`.
  /// - [baseStyle]: The base text style to apply to unformatted text segments and as the foundation for styled segments.
  ///
  /// Returns a list of [InlineSpan] objects representing the styled text.
  List<InlineSpan> parse(
    String text,
    BuildContext context,
    TextStyle baseStyle, {
    TextScaler? textScaler,
  }) {
    // Fast path for empty text
    if (text.isEmpty) {
      return <InlineSpan>[];
    }

    // Fast path for plain text without formatting markers
    // Note: FormattingUtils.hasFormatting checks for *any* potential marker,
    // including unpaired ones or link syntax characters.
    if (!FormattingUtils.hasFormatting(text)) {
      // No potential formatting, return simple TextSpan list
      return <InlineSpan>[TextSpan(text: text, style: baseStyle)];
    }

    // --- Main Parsing Logic ---

    // 1. Tokenize the input text
    final tokens = _tokenizer.tokenize(text);

    // 2. Create the Style Resolver using the current context
    final resolver = TextfStyleResolver(context);

    // 3. Identify matching *valid* pairs of formatting markers
    final validPairs = PairingResolver.identifyPairs(tokens);

    // 4. Create the ParserState, passing the resolver and only valid pairs
    final state = ParserState(
      tokens: tokens,
      baseStyle: baseStyle,
      matchingPairs: validPairs, // Use the validated pairs
      styleResolver: resolver,
      textScaler: textScaler,
    );

    // 5. Process tokens sequentially
    for (int i = 0; i < tokens.length; i++) {
      // Skip tokens already processed by handlers (e.g., inside a link or a valid format pair)
      if (state.processedIndices.contains(i)) continue;

      final token = tokens[i];

      // --- Token Processing Logic ---
      if (token.type == TokenType.text) {
        // It's plain text, just append to the buffer
        state.textBuffer += token.value;
        // No need to mark plain text as processed unless state management requires it
      } else if (token.type == TokenType.linkStart) {
        // Potential link start '['. Delegate to LinkHandler.
        final int? nextIndex = LinkHandler.processLink(context, state, i);
        if (nextIndex != null) {
          // LinkHandler processed a full link `[...](...)`.
          // It marked all involved tokens as processed.
          // Advance loop counter past the processed link.
          i = nextIndex - 1; // nextIndex is the index *after* ')', loop needs index of ')'
        }
      }
      // Is it a formatting marker (bold, italic, code, strike, etc.)?
      else if (token.type.isFormattingMarker) {
        // Check if this specific marker instance is part of a *valid* pair.
        if (state.matchingPairs.containsKey(i)) {
          // Yes, it's part of a valid pair (either opening or closing).
          // Delegate to FormatHandler to manage the stack and buffer.
          // FormatHandler will mark both this token and its pair as processed.
          FormatHandler.processFormat(context, state, i, token);
        } else {
          // No, this marker instance is *not* part of a valid pair (e.g., "**abc" or "*abc").
          // Treat its literal value as plain text.
          state.textBuffer += token.value;
          // Mark this specific token as processed so it doesn't get reconsidered.
          state.processedIndices.add(i);
        }
      }
      // Handle other token types (like linkSeparator, linkUrl, linkEnd) that might
      // be encountered if not part of a structure successfully processed by LinkHandler.
      // Treat them as plain text.
      else {
        // Fallback: Treat any other unexpected token type as plain text.
        state.textBuffer += token.value;
        state.processedIndices.add(i); // Mark as processed
      }
      // --- End Token Processing Logic ---
    }

    // 6. Flush any remaining text in the buffer after the loop finishes
    state.flushText(context);

    return state.spans;
  }
}

<!-- END FILE: [v0.6.1] lib/src/parsing/textf_parser.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/parsing/textf_tokenizer.dart -->
// ignore_for_file: no-magic-number

import '../core/constants.dart';
import '../models/token_type.dart';

/// Tokenizes text into formatting markers and content segments.
///
/// The TextfTokenizer breaks down input text into a sequence of [Token] objects that
/// represent either formatting markers (like bold, italic) or regular text content.
/// It focuses solely on identifying tokens without validating their pairing or nesting.
///
/// This class is optimized for performance with a character-by-character approach
/// and special handling for escape sequences.
///
/// Example:
/// ```dart
/// final tokenizer = TextfTokenizer();
/// final tokens = tokenizer.tokenize('Hello **world**');
/// // Results in 3 tokens: "Hello ", "**" (bold marker), "world", "**" (bold marker)
/// ```
class TextfTokenizer {
  /// Tokenizes the input text into a list of [Token] objects.
  ///
  /// This method processes the text character by character, identifying formatting
  /// markers and regular text segments. It recognizes:
  /// - Bold markers: ** or __
  /// - Italic markers: * or _
  /// - Bold+Italic markers: *** or ___
  /// - Strikethrough markers: ~~
  /// - Code markers: `
  /// - Underline markers: ++
  /// - Highlight markers: ==
  /// - Escaped characters: \* \_ \~ \` \\ \+ \= \[ \] \( \)
  ///
  /// The method is optimized for performance by:
  /// - Pre-processing text into code units
  /// - Using direct character code comparisons
  /// - Minimizing string operations
  ///
  /// @param text The input text to tokenize
  /// @return A list of [Token] objects representing the text components
  List<Token> tokenize(String text) {
    final tokens = <Token>[];
    int pos = 0;
    int textStart = 0;
    final int length = text.length;

    // Helper to add accumulated text as a token
    void addTextToken(int start, int end) {
      if (end > start) {
        tokens.add(
          Token(
            TokenType.text,
            text.substring(start, end),
            start,
            end - start,
          ),
        );
      }
    }

    // Performance optimization: pre-process code units
    final List<int> codeUnits = text.codeUnits;

    while (pos < length) {
      final int startPosInLoop = pos;
      final int currentChar = codeUnits[pos];

      // Handle escape character
      if (currentChar == kEscape && pos + 1 < length) {
        final int nextChar = codeUnits[pos + 1];
        // Check if next char is a formatting character or link-related character
        if (nextChar == kAsterisk ||
            nextChar == kUnderscore ||
            nextChar == kTilde ||
            nextChar == kBacktick ||
            nextChar == kPlus ||
            nextChar == kEquals ||
            nextChar == kEscape ||
            nextChar == kOpenBracket ||
            nextChar == kCloseBracket ||
            nextChar == kOpenParen ||
            nextChar == kCloseParen) {
          addTextToken(textStart, pos);
          // Just add the escaped character as normal text
          tokens.add(
            Token(
              TokenType.text,
              String.fromCharCode(nextChar),
              pos + 1, // Position of the character itself
              1, // Length of the character itself
            ),
          );
          pos += 2; // Skip escape character and the escaped character
          textStart = pos;
          continue;
        }
      }

      // Identify token patterns without semantic interpretation
      if (currentChar == kAsterisk) {
        // Check for bold+italic (***)
        if (pos + 2 < length && //
            codeUnits[pos + 1] == kAsterisk &&
            codeUnits[pos + 2] == kAsterisk) {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.boldItalicMarker, '***', pos, 3));
          pos += 3;
          textStart = pos;
        }
        // Check for bold (**)
        else if (pos + 1 < length && codeUnits[pos + 1] == kAsterisk) {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.boldMarker, '**', pos, 2));
          pos += 2;
          textStart = pos;
        }
        // Italic (*)
        else {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.italicMarker, '*', pos, 1));
          pos++;
          textStart = pos;
        }
      } else if (currentChar == kUnderscore) {
        // Check for bold+italic (___)
        if (pos + 2 < length && //
            codeUnits[pos + 1] == kUnderscore &&
            codeUnits[pos + 2] == kUnderscore) {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.boldItalicMarker, '___', pos, 3));
          pos += 3;
          textStart = pos;
        }
        // Check for bold (__)
        else if (pos + 1 < length && codeUnits[pos + 1] == kUnderscore) {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.boldMarker, '__', pos, 2));
          pos += 2;
          textStart = pos;
        }
        // Italic (_)
        else {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.italicMarker, '_', pos, 1));
          pos++;
          textStart = pos;
        }
      } else if (currentChar == kTilde) {
        // Check for strikethrough (~~)
        if (pos + 1 < length && codeUnits[pos + 1] == kTilde) {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.strikeMarker, '~~', pos, 2));
          pos += 2;
          textStart = pos;
        } else {
          // Single tilde treated as plain text, handled by falling through
          pos++;
        }
      } else if (currentChar == kBacktick) {
        // Inline code (`)
        addTextToken(textStart, pos);
        tokens.add(Token(TokenType.codeMarker, '`', pos, 1));
        pos++;
        textStart = pos;
      } else if (currentChar == kPlus) {
        // Check for underline (++)
        if (pos + 1 < length && codeUnits[pos + 1] == kPlus) {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.underlineMarker, '++', pos, 2));
          pos += 2;
          textStart = pos;
        } else {
          // Single plus treated as plain text, will be handled by final pos increment
          pos++;
        }
      } else if (currentChar == kEquals) {
        // Check for highlight (==)
        if (pos + 1 < length && codeUnits[pos + 1] == kEquals) {
          addTextToken(textStart, pos);
          tokens.add(Token(TokenType.highlightMarker, '==', pos, 2));
          pos += 2;
          textStart = pos;
        } else {
          // Single equals treated as plain text, will be handled by final pos increment
          pos++;
        }
      } //
      else if (currentChar == kOpenBracket) {
        // Opening square bracket for link
        addTextToken(textStart, pos);

        // Start link parsing
        final int linkStartPos = pos;
        pos++; // Move past '['

        // Find the end of link text
        final int linkTextStart = pos;
        int nestLevel = 0;
        int linkTextEnd = -1;

        while (pos < length) {
          // Inner loop for link text
          final int c = codeUnits[pos];

          // Handle escape sequences (original simple version)
          if (c == kEscape && pos + 1 < length) {
            pos += 2;
            continue;
          }

          // Track nested brackets
          if (c == kOpenBracket) {
            nestLevel++;
          } else if (c == kCloseBracket) {
            if (nestLevel > 0) {
              nestLevel--;
            } else {
              // This is the closing bracket for our link text
              linkTextEnd = pos;

              // Check if followed by opening parenthesis for URL
              if (pos + 1 < length && codeUnits[pos + 1] == kOpenParen) {
                break; // Found '](', proceed to URL parsing
              } else {
                // Not a valid link separator ']( )'.
                // The ']' found was not part of a valid link structure here.
                linkTextEnd = -1; // Mark that we didn't find a valid end for a link text segment
                // that leads to a URL.
                // The original code from llms.txt effectively did:
                // pos++; continue;
                // This means it continues scanning the inner loop.
                // If the loop finishes and linkTextEnd is still -1,
                // the outer 'if (linkTextEnd != -1 && ...)' will fail,
                // and the 'else' branch (treating '[' as text) will be taken.
                // We need to ensure this loop continues or breaks correctly.
                // To match original llms.txt behavior if `](` is not found after `]`:
                // it means the `[` was not a start of a link that completes with `](...)`.
                // The code would try to find another `]` if `pos++` happens here,
                // or if `break` happens, the outer `if(linkTextEnd != -1 ...)` fails.
                // Let's ensure the `break` happens so outer `if` fails.
                break; // Exit this inner loop. `linkTextEnd` is set, but `(` check failed.
                // The outer `if` will then determine if it's a full link.
              }
            }
          }
          pos++;
        }

        // Check if we found a proper link structure "[text]("
        // `pos` is currently at `linkTextEnd` (']') or at `length` if `]` wasn't found.
        // If `break` happened from `if (pos + 1 < length && codeUnits[pos + 1] == kOpenParen)`,
        // then `pos` points to `]`.
        if (linkTextEnd != -1 &&
            (linkTextEnd + 1) < length &&
            codeUnits[linkTextEnd + 1] == kOpenParen) {
          // Valid '[text](' structure found.
          tokens.add(Token(TokenType.linkStart, '[', linkStartPos, 1));

          if (linkTextEnd > linkTextStart) {
            // If there's actual text between [ and ]
            tokens.add(
              Token(
                TokenType.text, // It's just text at this stage
                text.substring(linkTextStart, linkTextEnd),
                linkTextStart,
                linkTextEnd - linkTextStart,
              ),
            );
          } else {
            // Empty link text, e.g. [](url)
            tokens.add(Token(TokenType.text, '', linkTextStart, 0));
          }

          tokens.add(Token(TokenType.linkSeparator, '](', linkTextEnd, 2));
          pos = linkTextEnd + 2; // Move main `pos` past ']('

          // Now collect the URL
          final int urlStart = pos;
          int urlEnd = -1;
          nestLevel = 0; // For nested parentheses within URL

          while (pos < length) {
            // Inner loop for URL
            final int c = codeUnits[pos];
            if (c == kEscape && pos + 1 < length) {
              pos += 2; // Original simple escape skipping
              continue;
            }
            if (c == kOpenParen) {
              nestLevel++;
            } else if (c == kCloseParen) {
              if (nestLevel > 0) {
                nestLevel--;
              } else {
                urlEnd = pos; // Position of ')'
                break; // Found ')'
              }
            }
            pos++;
          } // End of inner loop for URL

          if (urlEnd != -1) {
            // Valid URL found
            if (urlEnd > urlStart) {
              // If there's actual text for URL
              tokens.add(
                Token(
                  TokenType.text, // URL is also just text at this stage
                  text.substring(urlStart, urlEnd),
                  urlStart,
                  urlEnd - urlStart,
                ),
              );
            } else {
              // Empty URL, e.g. [text]()
              tokens.add(Token(TokenType.text, '', urlStart, 0));
            }
            tokens.add(Token(TokenType.linkEnd, ')', urlEnd, 1));
            pos = urlEnd + 1; // Move main `pos` past ')'
            textStart = pos; // Reset textStart for the next segment of plain text.
          } else {
            // Malformed URL (e.g., [text](url without closing paren).
            // The original fallback: treat the initial `[` at `linkStartPos` as plain text
            // and let subsequent characters be re-evaluated by the main loop.
            // To achieve this, we must discard any link tokens already added for this attempt
            // and reset `pos` and `textStart` correctly.
            tokens
              ..removeLast() // Remove linkSeparator
              ..removeLast() // Remove linkText (or empty linkText token)
              ..removeLast() // Remove linkStart
              // Now, treat the original '[' as text.
              ..add(Token(TokenType.text, '[', linkStartPos, 1)); // Add '[' as text
            pos = linkStartPos + 1; // Set main `pos` to parse after the '['
            textStart = pos; // Reset textStart.
          }
        } else {
          // Not a complete link structure (e.g. "[text" or "[text]no_paren").
          // Treat the initial '[' as plain text.
          // `addTextToken(textStart, linkStartPos)` was already called.
          tokens.add(Token(TokenType.text, '[', linkStartPos, 1));
          pos = linkStartPos + 1; // Continue parsing after the '['
          textStart = pos; // Reset textStart for the next segment of plain text.
        }
      }
      // Fallback for other characters that are not part of other rules
      // (e.g. single `]`, `(`, `)` not consumed by link logic, or any other char)
      else {
        pos++;
      }

      // Safety check to ensure forward progress if no specific token was matched
      // and pos wasn't advanced by one of the specific rules.
      if (pos == startPosInLoop && pos < length) {
        // This means the character at `startPosInLoop` was not handled by any
        // of the if/else if blocks that would advance `pos`.
        // This typically means it's a plain text character.
        // The `pos++` in the final `else` block above should handle most plain chars.
        // This is an ultimate fallback.
        pos++;
      }
    }

    // Add any remaining text
    addTextToken(textStart, pos);

    return tokens;
  }
}

<!-- END FILE: [v0.6.1] lib/src/parsing/textf_tokenizer.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/styling/textf_style_resolver.dart -->
import 'package:flutter/material.dart';

import '../core/default_styles.dart';
import '../models/token_type.dart';
import '../widgets/textf_options.dart'; // Needed for options lookup

/// A class responsible for resolving the final TextStyle for formatted text segments.
///
/// It orchestrates the application of styles based on the following precedence:
/// 1. Explicit styles defined in the nearest ancestor `TextfOptions`.
/// 2. Styles inherited from higher `TextfOptions` ancestors.
/// 3. Theme-based default styles derived from the application's `ThemeData`
///    (for code, links, highlight).
/// 4. Relative default styles from `DefaultStyles`
///    (for bold, italic, strikethrough, underline).
///
/// The resolved style is always merged with the provided `baseStyle`.
class TextfStyleResolver {
  /// Creates a style resolver for the given context.
  TextfStyleResolver(this.context)
      : _theme = Theme.of(context),
        _nearestOptions = TextfOptions.maybeOf(context); // Find nearest options once

  /// The context in which the resolver operates.
  final BuildContext context;
  // Store theme and options for potential reuse within a single resolve cycle,
  // though looking them up on demand is also fine.
  final ThemeData _theme;
  final TextfOptions? _nearestOptions;

  /// Resolves the final TextStyle for a given token type and base style.
  ///
  /// Use this for standard formatting types like bold, italic, code, strikethrough,
  /// underline, highlight.
  /// For links, use `resolveLinkStyle` and `resolveLinkHoverStyle`.
  ///
  /// - [type]: The type of formatting marker (e.g., `TokenType.boldMarker`).
  /// - [baseStyle]: The style of the text segment *before* applying this format.
  ///
  /// Returns the final `TextStyle` to be applied.
  TextStyle resolveStyle(TokenType type, TextStyle baseStyle) {
    // Get the effective style from TextfOptions hierarchy first.
    // The getEffective... methods handle the lookup and return null if no option is set.
    final TextStyle? optionsStyle = _getEffectiveStyleFromOptions(type, baseStyle);

    if (optionsStyle != null) {
      // Precedence 1 & 2: Use the style derived from TextfOptions
      // The getEffective... methods already merge with the base style correctly.
      return optionsStyle;
    } else {
      // Precedence 3 & 4: No TextfOptions override found, use Theme or Default fallback
      switch (type) {
        case TokenType.boldMarker:
          return DefaultStyles.boldStyle(baseStyle); // Relative default
        case TokenType.italicMarker:
          return DefaultStyles.italicStyle(baseStyle); // Relative default
        case TokenType.boldItalicMarker:
          return DefaultStyles.boldItalicStyle(baseStyle); // Relative default
        case TokenType.strikeMarker:
          // No full style override from options, use default effect.
          // Check if a specific thickness is provided via options.
          final double? thicknessOption =
              _nearestOptions?.getEffectiveStrikethroughThickness(context);
          // Use the option thickness if provided, otherwise use the default thickness.
          final double finalThickness =
              thicknessOption ?? DefaultStyles.defaultStrikethroughThickness;

          // Apply the default strikethrough effect with the resolved thickness.
          return DefaultStyles.strikethroughStyle(
            baseStyle,
            thickness: finalThickness,
          );
        case TokenType.codeMarker:
          return _getThemeBasedCodeStyle(baseStyle); // Theme-based default
        case TokenType.underlineMarker:
          return DefaultStyles.underlineStyle(baseStyle); // Relative default
        case TokenType.highlightMarker:
          return _getThemeBasedHighlightStyle(baseStyle); // Theme-based default
        // Link styles are handled separately by resolveLinkStyle/resolveLinkHoverStyle
        case TokenType.linkStart:
        case TokenType.linkText:
        case TokenType.linkSeparator:
        case TokenType.linkUrl:
        case TokenType.linkEnd:
        case TokenType.text:
          return baseStyle; // No formatting applied
      }
    }
  }

  /// Resolves the final NORMAL TextStyle for a URL link.
  ///
  /// Checks TextfOptions first, then falls back to a theme-based style.
  /// Merges the result with the provided `baseStyle`.
  ///
  /// - [baseStyle]: The style of the link text *before* applying link-specific formatting
  ///                (might already include bold, italic etc. if the link is nested).
  ///
  /// Returns the final normal `TextStyle` for the link.
  TextStyle resolveLinkStyle(TextStyle baseStyle) {
    final TextStyle? optionsStyle = _nearestOptions?.getEffectiveUrlStyle(context, baseStyle);

    return optionsStyle ?? _getThemeBasedLinkStyle(baseStyle);
  }

  /// Resolves the final HOVER TextStyle for a URL link.
  ///
  /// Checks TextfOptions first, then falls back to a theme-based style
  /// (which, by default, might be the same as the normal style unless overridden).
  /// Merges the result with the provided `baseStyle`.
  ///
  /// - [baseStyle]: The style of the link text *before* applying link-specific formatting.
  ///
  /// Returns the final hover `TextStyle` for the link.
  TextStyle resolveLinkHoverStyle(TextStyle baseStyle) {
    // 1. Resolve the normal link style first
    final TextStyle normalLinkStyle = resolveLinkStyle(baseStyle);
    // 2. Try to get a hover-specific style from options, merging it onto the normalLinkStyle
    final TextStyle? optionsStyle =
        _nearestOptions?.getEffectiveUrlHoverStyle(context, normalLinkStyle);

    return optionsStyle ?? normalLinkStyle;
  }

  /// Resolves the effective MouseCursor for a URL link.
  ///
  /// Checks TextfOptions first, then falls back to `DefaultStyles.urlMouseCursor`.
  MouseCursor resolveLinkMouseCursor() {
    return _nearestOptions?.getEffectiveUrlMouseCursor(context) ?? DefaultStyles.urlMouseCursor;
  }

  /// Resolves the effective onUrlTap callback for a URL link.
  ///
  /// Checks TextfOptions hierarchy for the callback. Returns null if none found.
  void Function(String url, String displayText)? resolveOnUrlTap() {
    return _nearestOptions?.getEffectiveOnUrlTap(context);
  }

  /// Resolves the effective onUrlHover callback for a URL link.
  ///
  /// Checks TextfOptions hierarchy for the callback. Returns null if none found.
  void Function(String url, String displayText, {required bool isHovering})? resolveOnUrlHover() {
    return _nearestOptions?.getEffectiveOnUrlHover(context);
  }

  // --- Private Helper Methods ---

  /// Internal helper to retrieve the effective style from TextfOptions hierarchy.
  /// Returns null if no option is defined for the given type.
  TextStyle? _getEffectiveStyleFromOptions(TokenType type, TextStyle baseStyle) {
    final TextfOptions? options = _nearestOptions;
    if (options == null) return null;

    // Call the appropriate getter on the TextfOptions instance.
    // These methods handle the ancestor lookup internally.
    switch (type) {
      case TokenType.boldMarker:
        return options.getEffectiveBoldStyle(context, baseStyle);
      case TokenType.italicMarker:
        return options.getEffectiveItalicStyle(context, baseStyle);
      case TokenType.boldItalicMarker:
        return options.getEffectiveBoldItalicStyle(context, baseStyle);
      case TokenType.strikeMarker:
        return options.getEffectiveStrikethroughStyle(context, baseStyle);
      case TokenType.codeMarker:
        return options.getEffectiveCodeStyle(context, baseStyle);
      case TokenType.underlineMarker:
        return options.getEffectiveUnderlineStyle(context, baseStyle);
      case TokenType.highlightMarker:
        return options.getEffectiveHighlightStyle(context, baseStyle);
      // Link styles are handled by resolveLinkStyle/resolveLinkHoverStyle directly
      case TokenType.linkStart:
      case TokenType.linkText:
      case TokenType.linkSeparator:
      case TokenType.linkUrl:
      case TokenType.linkEnd:
      case TokenType.text:
        return null; // No specific option style for these types
    }
  }

  /// Internal helper to create the default code style based on the current theme.
  TextStyle _getThemeBasedCodeStyle(TextStyle baseStyle) {
    final ColorScheme colorScheme = _theme.colorScheme;
    // final TextTheme textTheme = _theme.textTheme; // Potentially use textTheme for font details

    final Color codeBackgroundColor = colorScheme.surfaceContainer; // Example theme color
    final Color codeForegroundColor = colorScheme.onSurfaceVariant; // Example theme color

    // Use monospace font family
    const String codeFontFamily = 'monospace';
    // Use the constant list directly from DefaultStyles
    const List<String> codeFontFamilyFallback = DefaultStyles.defaultCodeFontFamilyFallback;

    // Merge theme defaults with the base style
    return baseStyle.copyWith(
      fontFamily: codeFontFamily,
      fontFamilyFallback: codeFontFamilyFallback,
      backgroundColor: codeBackgroundColor,
      color: codeForegroundColor,
      letterSpacing: baseStyle.letterSpacing ?? 0,
    );
  }

  /// Internal helper to create the default link style based on the current theme.
  TextStyle _getThemeBasedLinkStyle(TextStyle baseStyle) {
    final Color themeLinkColor = _theme.colorScheme.primary; // Use primary color

    // Merge theme link appearance (color, decoration) ON TOP of the base style.
    return baseStyle.merge(
      TextStyle(
        color: themeLinkColor,
        decoration: TextDecoration.underline, // Default underline for links
        decorationColor: themeLinkColor,
      ),
    );
  }

  /// Internal helper to create the default highlight style based on the current theme.
  TextStyle _getThemeBasedHighlightStyle(TextStyle baseStyle) {
    final ColorScheme colorScheme = _theme.colorScheme;

    // A common "highlighter yellow":
    // force yellow for now to see it clearly
    final Color highlightBgColor = colorScheme.brightness == Brightness.light
        ? Colors.yellow.withValues(alpha: DefaultStyles.highlightAlphaLight)
        : Colors.yellow.shade700.withValues(alpha: DefaultStyles.highlightAlphaDark);
    final Color highlightTextColor = baseStyle.color ??
        (colorScheme.brightness == Brightness.light ? Colors.black87 : Colors.white);

    return baseStyle.copyWith(
      backgroundColor: highlightBgColor,
      color: highlightTextColor,
    );
  }
}

<!-- END FILE: [v0.6.1] lib/src/styling/textf_style_resolver.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/widgets/textf.dart -->
import 'dart:ui' as ui show TextHeightBehavior;

import 'package:flutter/material.dart';

import '../parsing/textf_parser.dart';
import 'internal/textf_renderer.dart';

/// A lightweight text widget for simple inline formatting.
///
/// [Textf] provides basic text formatting capabilities similar to a subset of Markdown,
/// focusing only on inline styles like bold, italic, strikethrough, and code.
/// It's designed for simple use cases where you need basic text formatting without
/// the overhead of a full Markdown rendering solution.
///
/// ## Supported formatting
/// * `**bold**` or `__bold__` for **bold** text
/// * `*italic*` or `_italic_` for *italic* text
/// * `***bold and italic***` or `___bold and italic___` for ***bold and italic*** text
/// * `~~strikethrough~~` for ~~strikethrough~~ text
/// * `` `code` `` for `code` text
/// * `[link text](url)` for [links](https://example.com)
///
/// Links support nested formatting such as `[**bold** link](url)`.

///
/// ## Usage example
/// ```dart
/// Textf(
///   'Hello **bold** *italic* ~~strikethrough~~ `code`',
///   style: TextStyle(fontSize: 16),
/// )
/// ```
///
/// ## Limitations
/// - Maximum nesting depth of 2 formatting levels
/// - When nesting, use different marker types (e.g., **bold with _italic_**)
/// - No support for block elements (headings, lists, quotes, etc.)
/// - No support for links or images
/// - Designed for inline formatting only, not full Markdown rendering
///
/// To escape formatting characters use a backslash: `\*not italic\*`
///
/// The widget supports standard text styling properties like [style], [textAlign],
/// and [overflow], similar to the standard Text widget.
class Textf extends StatelessWidget {
  /// Creates a text widget with inline formatting capabilities.
  ///
  /// The [data] parameter is the text string that contains formatting markers.
  /// All other parameters function identically to Flutter's standard [Text] widget.
  ///
  /// Example:
  /// ```dart
  /// Textf(
  ///   'Hello **world** with *formatting*',
  ///   style: TextStyle(fontSize: 16),
  ///   textAlign: TextAlign.center,
  /// )
  /// ```
  ///
  /// The base [style] will be applied to all text, with formatting markers
  /// modifying it where specified. For example, bold markers will apply
  /// FontWeight.bold to the specified text segments.
  const Textf(
    this.data, {
    super.key,
    this.style,
    this.strutStyle,
    this.textAlign,
    this.textDirection,
    this.locale,
    this.softWrap,
    this.overflow,
    this.textScaler,
    this.maxLines,
    this.semanticsLabel,
    this.textWidthBasis,
    this.textHeightBehavior,
    this.selectionColor,
  });

  /// The text to display with formatting
  final String data;

  /// The base text style to apply to the text
  final TextStyle? style;

  /// The strut style to use for vertical layout
  final StrutStyle? strutStyle;

  /// How the text should be aligned horizontally
  final TextAlign? textAlign;

  /// The directionality of the text
  final TextDirection? textDirection;

  /// The locale to use for the text
  final Locale? locale;

  /// Whether the text should break at soft line breaks
  final bool? softWrap;

  /// How visual overflow should be handled
  final TextOverflow? overflow;

  /// The text scaling factor to apply
  final TextScaler? textScaler;

  /// The maximum number of lines for the text to span
  final int? maxLines;

  /// An alternative semantics label for the text
  final String? semanticsLabel;

  /// Defines how the paragraph width is determined
  final TextWidthBasis? textWidthBasis;

  /// Defines how the paragraph will position lines vertically
  final ui.TextHeightBehavior? textHeightBehavior;

  /// The color to use when painting the selection
  final Color? selectionColor;

  // Private static instance for default usage
  static final TextfParser _defaultParser = TextfParser();

  /// Builds the widget by parsing the formatted text into spans and
  /// rendering it using a Text.rich widget.
  ///
  /// The parsing process converts formatting markers into appropriate TextSpan
  /// objects with the correct styling applied. The resulting spans are then
  /// combined and passed to a Text.rich widget along with the other parameters.
  @override
  Widget build(BuildContext context) {
    return TextfRenderer(
      data: data,
      style: style,
      parser: _defaultParser,
      strutStyle: strutStyle,
      textAlign: textAlign,
      textDirection: textDirection,
      locale: locale,
      softWrap: softWrap,
      overflow: overflow,
      textScaler: textScaler,
      maxLines: maxLines,
      semanticsLabel: semanticsLabel,
      textWidthBasis: textWidthBasis,
      textHeightBehavior: textHeightBehavior,
      selectionColor: selectionColor,
    );
  }
}

<!-- END FILE: [v0.6.1] lib/src/widgets/textf.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/widgets/textf_options.dart -->
import 'package:flutter/material.dart';

/// Merges two [TextStyle] objects with special handling for [TextDecoration].
///
/// Unlike the standard [TextStyle.merge], this function intelligently combines
/// decorations from both styles instead of letting the [optionsStyle]'s decoration
/// completely overwrite the [baseStyle]'s.
///
/// The merging logic is as follows:
/// 1.  All properties from [optionsStyle] (e.g., `color`, `fontWeight`,
///     `fontSize`) take precedence over [baseStyle], except for decoration.
/// 2.  Decoration-related properties (`decorationColor`, `decorationThickness`,
///     `decorationStyle`) from [optionsStyle] are given priority.
/// 3.  The `decoration` property itself is combined:
///     - If both styles have active, distinct decorations, they are combined
///       using [TextDecoration.combine].
///     - If [optionsStyle] specifies `TextDecoration.none`, any decoration from
///       [baseStyle] is removed.
///     - In all other cases, the standard merge logic applies (i.e., the
///       [optionsStyle]'s decoration is used).
///
/// This ensures that nested [TextfOptions] can layer decorations (e.g., add a
/// strikethrough to an existing underline) in an intuitive way.
///
/// - [baseStyle]: The base style, typically from a parent `TextfOptions` or
///   a `DefaultTextStyle`.
/// - [optionsStyle]: The style from the current `TextfOptions` widget, which
///   should take precedence.
///
/// Returns a new [TextStyle] with the properties correctly merged and
/// decorations combined.
TextStyle _mergeStyles(TextStyle baseStyle, TextStyle optionsStyle) {
  final TextDecoration? baseDecoration = baseStyle.decoration;
  final TextDecoration? optionDecoration = optionsStyle.decoration;

  TextDecoration? finalDecoration;

  final bool shouldCombine = optionDecoration != null &&
      optionDecoration != TextDecoration.none &&
      baseDecoration != null &&
      baseDecoration != TextDecoration.none &&
      !baseDecoration.contains(optionDecoration);

  if (shouldCombine) {
    finalDecoration = TextDecoration.combine([baseDecoration, optionDecoration]);
  } else {
    finalDecoration = optionDecoration ?? baseDecoration;
  }

  return baseStyle.merge(optionsStyle).copyWith(
        decoration: finalDecoration,
      );
}

/// Configuration options for Textf widgets within a specific scope.
///
/// This widget uses the `InheritedWidget` pattern to make configuration
/// available to all descendant `Textf` widgets. It allows for hierarchical
/// styling and behavior management.
///
/// ## Style Inheritance Logic
///
/// `TextStyle` properties (like `boldStyle`, `urlStyle`, etc.) are resolved
/// using a **recursive merge strategy**. The system collects all `TextfOptions`
/// widgets up the tree and merges their styles starting from the top-most
/// (root) ancestor down to the nearest one.
///
/// This allows for powerful and intuitive style composition. For example, a
/// parent `TextfOptions` can define a `boldStyle` with a red color, and a
/// child `TextfOptions` can define its own `boldStyle` with only a bold font
/// weight. The final resolved style for bold text in that subtree will be
/// **both red and bold**.
///
/// The final, fully-merged style from the `TextfOptions` hierarchy is then
/// applied on top of the `Textf` widget's base style (from `DefaultTextStyle`
/// or the `style` parameter).
///
/// ## Callback and Value Inheritance Logic
///
/// Non-style properties that cannot be merged (like `onUrlTap`, `onUrlHover`,
/// and `urlMouseCursor`) use a **"nearest ancestor wins"** strategy. The first
/// non-null value found when searching up the widget tree from the `Textf`
/// widget is the one that will be used.
class TextfOptions extends InheritedWidget {
  /// Creates a new TextfOptions instance to provide configuration down the tree.
  const TextfOptions({
    required super.child,
    super.key,
    this.onUrlTap,
    this.onUrlHover,
    this.urlMouseCursor,
    this.urlStyle,
    this.urlHoverStyle,
    this.boldStyle,
    this.italicStyle,
    this.boldItalicStyle,
    this.strikethroughStyle,
    this.codeStyle,
    this.strikethroughThickness,
    this.underlineStyle,
    this.highlightStyle,
  });

  /// Callback function executed when tapping or clicking on a URL.
  /// Provides the resolved `url` and the raw `displayText` including any
  /// original formatting markers (e.g., `**bold link**`).
  final void Function(String url, String displayText)? onUrlTap;

  /// Callback function executed when the mouse pointer enters or exits a URL.
  /// Provides the resolved `url`, the raw `displayText`, and the hover state
  /// (`isHovering` is `true` on enter, `false` on exit).
  final void Function(String url, String displayText, {required bool isHovering})? onUrlHover;

  /// The [TextStyle] for link text (`[text](url)`) in its normal (non-hovered) state.
  /// Merged onto the base style if provided.
  final TextStyle? urlStyle;

  /// The [TextStyle] for link text when hovered.
  /// This style is merged on top of the link's final normal style.
  final TextStyle? urlHoverStyle;

  /// The [MouseCursor] to display when hovering over a URL link.
  final MouseCursor? urlMouseCursor;

  /// The [TextStyle] for bold text (`**bold**` or `__bold__`).
  /// Merged onto the base style if provided.
  final TextStyle? boldStyle;

  /// The [TextStyle] for italic text (`*italic*` or `_italic_`).
  /// Merged onto the base style if provided.
  final TextStyle? italicStyle;

  /// The [TextStyle] for bold and italic text (`***both***` or `___both___`).
  /// Merged onto the base style if provided.
  final TextStyle? boldItalicStyle;

  /// The [TextStyle] for strikethrough text (`~~strike~~`).
  /// Merged onto the base style if provided.
  final TextStyle? strikethroughStyle;

  /// The [TextStyle] for inline code text (`` `code` ``).
  /// Merged onto the base style if provided.
  final TextStyle? codeStyle;

  /// A specific thickness for the strikethrough line decoration.
  /// This property is **only used if `strikethroughStyle` is `null`**.
  final double? strikethroughThickness;

  /// The [TextStyle] for underlined text (`++underline++`).
  /// Merged onto the base style if provided.
  final TextStyle? underlineStyle;

  /// The [TextStyle] for highlighted text (`==highlight==`).
  /// Merged onto the base style if provided.
  final TextStyle? highlightStyle;

  /// Finds the nearest [TextfOptions] ancestor in the widget tree.
  ///
  /// Returns null if no ancestor is found. This establishes a dependency on the
  /// nearest `TextfOptions`, so the calling widget will rebuild if it changes.
  static TextfOptions? maybeOf(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<TextfOptions>();
  }

  /// Finds the nearest [TextfOptions] ancestor and establishes a dependency.
  ///
  /// Throws a [FlutterError] if no ancestor is found.
  static TextfOptions of(BuildContext context) {
    final TextfOptions? result = context.dependOnInheritedWidgetOfExactType<TextfOptions>();
    if (result == null) {
      throw FlutterError(
        'No TextfOptions found in context. To use TextfOptions.of, a TextfOptions widget must be an ancestor of the calling widget.',
      );
    }
    return result;
  }

  // ===== STATIC HELPERS FOR STYLE RESOLUTION LOGIC =====

  /// Gathers all [TextfOptions] widgets from the current context upwards.
  /// The returned list is ordered from the nearest ancestor to the furthest.
  static List<TextfOptions> _getAncestorOptions(BuildContext context) {
    final List<TextfOptions> optionsHierarchy = [];
    context.visitAncestorElements((element) {
      if (element.widget is TextfOptions) {
        optionsHierarchy.add(element.widget as TextfOptions);
      }
      return true; // Continue visiting all the way to the root.
    });
    return optionsHierarchy;
  }

  /// Merges a specific [TextStyle] property from the entire options hierarchy.
  ///
  /// It achieves this by reversing the ancestor list (to start from the
  /// top-most parent) and iteratively merging styles downwards.
  static TextStyle? _getMergedStyleFromHierarchy(
    BuildContext context,
    TextStyle? Function(TextfOptions) getter,
  ) {
    final List<TextfOptions> hierarchy = _getAncestorOptions(context);
    if (hierarchy.isEmpty) {
      return null;
    }

    // Reverse the list to start from the top-most ancestor and merge down.
    final Iterable<TextfOptions> reversedHierarchy = hierarchy.reversed;
    TextStyle? finalStyle;

    for (final options in reversedHierarchy) {
      final TextStyle? localStyle = getter(options);
      if (localStyle != null) {
        finalStyle = finalStyle == null ? localStyle : _mergeStyles(finalStyle, localStyle);
      }
    }
    return finalStyle;
  }

  /// Finds the first non-null value for a given property by searching up
  /// the widget tree (from nearest to furthest).
  ///
  /// This is used for non-mergeable properties like callbacks and enums where
  /// a "nearest wins" strategy is appropriate.
  static T? _findFirstAncestorValue<T>(
    BuildContext context,
    T? Function(TextfOptions) getter,
  ) {
    final List<TextfOptions> hierarchy = _getAncestorOptions(context);
    for (final options in hierarchy) {
      final T? value = getter(options);
      if (value != null) {
        return value; // Found the nearest value, stop searching.
      }
    }
    return null; // Reached the top with no value found.
  }

  // ===== EFFECTIVE GETTERS (Used by TextfStyleResolver) =====

  /// Resolves the final merged `boldStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveBoldStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle = _getMergedStyleFromHierarchy(context, (o) => o.boldStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the final merged `italicStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveItalicStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle = _getMergedStyleFromHierarchy(context, (o) => o.italicStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the final merged `boldItalicStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveBoldItalicStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle = _getMergedStyleFromHierarchy(context, (o) => o.boldItalicStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the final merged `strikethroughStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveStrikethroughStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle =
        _getMergedStyleFromHierarchy(context, (o) => o.strikethroughStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the final merged `codeStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveCodeStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle = _getMergedStyleFromHierarchy(context, (o) => o.codeStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the final merged `urlStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveUrlStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle = _getMergedStyleFromHierarchy(context, (o) => o.urlStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the final merged `urlHoverStyle` and merges it onto the final `normalLinkStyle`.
  TextStyle? getEffectiveUrlHoverStyle(BuildContext context, TextStyle normalLinkStyle) {
    final TextStyle? hoverOptionsStyle =
        _getMergedStyleFromHierarchy(context, (o) => o.urlHoverStyle);
    if (hoverOptionsStyle == null) return null;
    return _mergeStyles(normalLinkStyle, hoverOptionsStyle);
  }

  /// Resolves the final merged `underlineStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveUnderlineStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle = _getMergedStyleFromHierarchy(context, (o) => o.underlineStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the final merged `highlightStyle` from the hierarchy and merges it onto `baseStyle`.
  TextStyle? getEffectiveHighlightStyle(BuildContext context, TextStyle baseStyle) {
    final TextStyle? optionsStyle = _getMergedStyleFromHierarchy(context, (o) => o.highlightStyle);
    return optionsStyle == null ? null : _mergeStyles(baseStyle, optionsStyle);
  }

  /// Resolves the nearest `onUrlTap` callback from the hierarchy.
  void Function(String url, String displayText)? getEffectiveOnUrlTap(BuildContext context) {
    return _findFirstAncestorValue(context, (o) => o.onUrlTap);
  }

  /// Resolves the nearest `onUrlHover` callback from the hierarchy.
  void Function(String url, String displayText, {required bool isHovering})? getEffectiveOnUrlHover(
    BuildContext context,
  ) {
    return _findFirstAncestorValue(context, (o) => o.onUrlHover);
  }

  /// Resolves the nearest `urlMouseCursor` from the hierarchy.
  MouseCursor? getEffectiveUrlMouseCursor(BuildContext context) {
    return _findFirstAncestorValue(context, (o) => o.urlMouseCursor);
  }

  /// Resolves the nearest `strikethroughThickness` from the hierarchy.
  double? getEffectiveStrikethroughThickness(BuildContext context) {
    return _findFirstAncestorValue(context, (o) => o.strikethroughThickness);
  }

  @override
  bool updateShouldNotify(TextfOptions oldWidget) {
    // Comparing only the properties of this specific instance.
    return onUrlTap != oldWidget.onUrlTap ||
        onUrlHover != oldWidget.onUrlHover ||
        urlStyle != oldWidget.urlStyle ||
        urlHoverStyle != oldWidget.urlHoverStyle ||
        urlMouseCursor != oldWidget.urlMouseCursor ||
        boldStyle != oldWidget.boldStyle ||
        italicStyle != oldWidget.italicStyle ||
        boldItalicStyle != oldWidget.boldItalicStyle ||
        strikethroughStyle != oldWidget.strikethroughStyle ||
        codeStyle != oldWidget.codeStyle ||
        strikethroughThickness != oldWidget.strikethroughThickness ||
        underlineStyle != oldWidget.underlineStyle ||
        highlightStyle != oldWidget.highlightStyle;
  }
}

<!-- END FILE: [v0.6.1] lib/src/widgets/textf_options.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/parsing/components/format_handler.dart -->
import 'package:flutter/material.dart';

import '../../models/format_stack_entry.dart';
import '../../models/parser_state.dart';
import '../../models/token_type.dart';

/// Handles the processing of formatting tokens (bold, italic, etc.) during parsing.
///
/// This class is responsible for managing the `formatStack` within the `ParserState`
/// based on opening and closing formatting markers identified by the `PairingResolver`.
/// It ensures that `state.flushText()` is called before format changes occur,
/// allowing the `ParserState` (using the `TextfStyleResolver`) to apply the correct
/// style to the text segments.
class FormatHandler {
  /// Processes a formatting token (bold, italic, strike, code) and updates the parser state.
  ///
  /// This method handles both opening and closing formatting markers:
  /// - For opening markers: It flushes any preceding text, adds the marker to the format stack,
  ///   and marks the token as processed.
  /// - For closing markers: It flushes the text *within* the format, removes the corresponding
  ///   marker from the stack, and marks the token as processed.
  /// - Unpaired markers are treated as plain text (handled by the caller loop in TextfParser).
  ///
  /// - [context]: The BuildContext, needed by `state.flushText`.
  /// - [state]: The current parser state holding the tokens, stack, buffer, etc.
  /// - [index]: The index of the token being processed in `state.tokens`.
  /// - [token]: The formatting token to process.
  static void processFormat(
    BuildContext context,
    ParserState state,
    int index,
    Token token,
  ) {
    // Find the index of the matching counterpart for this token.
    // This relies on the pre-calculated `matchingPairs` map in the state,
    // which only contains valid, nested pairs.
    final int? matchingIndex = state.matchingPairs[index];

    if (matchingIndex != null) {
      // This is a valid formatting marker with a matching pair.
      if (matchingIndex > index) {
        // This is an OPENING marker (its match is further down the list).
        _handleOpeningMarker(context, state, index, token, matchingIndex);
      } else {
        // This is a CLOSING marker (its match is earlier in the list).
        _handleClosingMarker(context, state, index, matchingIndex);
      }
    }
    // If matchingIndex is null, it's an unpaired marker.
    // The main loop in TextfParser should handle adding unpaired markers
    // to the text buffer as plain text before calling this function.
    // No action needed here for unpaired markers.
  }

  /// Handles an opening formatting marker.
  ///
  /// Flushes any preceding text, pushes the new format onto the stack,
  /// and marks the token as processed.
  static void _handleOpeningMarker(
    BuildContext context,
    ParserState state,
    int index,
    Token token,
    int matchingIndex, // Index of the corresponding closing marker
  ) {
    // Flush any accumulated text *before* this new formatting starts.
    // The flushed text will have the style active *before* this marker.
    state.flushText(context);

    // Push the new format onto the stack.
    state.formatStack.add(
      FormatStackEntry(
        index: index, // Store index of this opening marker
        matchingIndex: matchingIndex, // Store index of its closing counterpart
        type: token.type, // Store the type of format being applied
      ),
    );

    // Mark this opening marker token as processed so the main loop skips it.
    state.processedIndices.add(index);
  }

  /// Handles a closing formatting marker.
  ///
  /// Flushes the text segment that was *inside* the format being closed,
  /// removes the corresponding format entry from the stack, and marks
  /// the token as processed.
  static void _handleClosingMarker(
    BuildContext context,
    ParserState state,
    int index, // The index of this closing marker token
    int matchingIndex, // The index of the corresponding opening marker
  ) {
    // First, flush the text that was formatted with the style we are about to remove.
    // `flushText` uses the current `formatStack` (which still includes the style
    // being closed) to calculate the style.
    state.flushText(context);

    // Mark this closing marker token as processed.
    state.processedIndices.add(index);

    // Find and remove the corresponding opening entry from the format stack.
    // We search from the end of the stack for the entry whose `index` matches
    // the `matchingIndex` of the closing marker we are handling.
    int stackIndexToRemove = -1;
    for (int j = state.formatStack.length - 1; j >= 0; j--) {
      if (state.formatStack[j].index == matchingIndex) {
        stackIndexToRemove = j;
        break;
      }
    }

    // If found (which it should be, as we only process valid pairs), remove it.
    if (stackIndexToRemove != -1) {
      state.formatStack.removeAt(stackIndexToRemove);
    }
    // If not found (unexpected, indicates an issue in pairing/nesting logic),
    // we've already flushed the text, so the visual result might be reasonable,
    // but it indicates a potential internal inconsistency. No error is thrown here.
  }
}

<!-- END FILE: [v0.6.1] lib/src/parsing/components/format_handler.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/parsing/components/link_handler.dart -->
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

import '../../models/parser_state.dart';
import '../../models/token_type.dart';
import '../../widgets/internal/hoverable_link_span.dart';
import '../textf_parser.dart';
import '../textf_tokenizer.dart';

/// Handles the processing of link tokens during parsing.
///
/// This class recognizes complete link structures `[text](url)` and creates
/// interactive `WidgetSpan`s containing `HoverableLinkSpan` widgets.
/// It utilizes the `TextfStyleResolver` from the `ParserState` to determine
/// link-specific styling (normal, hover), mouse cursor, and interaction callbacks,
/// considering `TextfOptions`, `Theme`, and defaults.
class LinkHandler {
  // Link structure constants
  static const int _linkTextOffset = 1;
  static const int _linkSeparatorOffset = 2;
  static const int _linkUrlOffset = 3;
  static const int _linkEndOffset = 4;
  static const int _linkTokenCount = 5;

  /// Processes a potential link structure starting at the given `index`.
  ///
  /// If a valid `[text](url)` structure is found:
  /// 1. Calculates the style inherited from surrounding formatting markers.
  /// 2. Uses the `styleResolver` in `state` to get the final normal style,
  ///    hover style, cursor, and callbacks for the link.
  /// 3. Parses the `text` part of the link for any nested formatting, using
  ///    the resolved normal link style as the base for this inner parsing.
  /// 4. Creates a `HoverableLinkSpan` widget within a `WidgetSpan`.
  /// 5. Adds the `WidgetSpan` to `state.spans`.
  /// 6. Marks the consumed link tokens as processed in `state.processedIndices`.
  /// 7. Returns the index immediately following the link structure.
  ///
  /// If no valid link structure is found, it treats the starting `[` as plain text,
  /// adds it to the `state.textBuffer`, marks it as processed, and returns `null`.
  ///
  /// - [context]: The BuildContext (passed down, potentially used by callbacks).
  /// - [state]: The current parser state containing tokens, stack, resolver, etc.
  /// - [index]: The index of the `TokenType.linkStart` token (`[`).
  ///
  /// Returns the new token index after processing the link structure, or `null`.
  static int? processLink(
    BuildContext context, // Keep context for potential callback needs
    ParserState state,
    int index,
  ) {
    // Flush any preceding text before potentially starting a link
    state.flushText(context);

    final tokens = state.tokens;

    // Check if the sequence starting at `index` forms a complete link structure
    if (_isCompleteLink(tokens, index)) {
      // --- Valid Link Found ---

      // Extract raw text and URL
      final linkTextToken = tokens[index + _linkTextOffset];
      final linkUrlToken = tokens[index + _linkUrlOffset];
      final rawLinkText = linkTextToken.value;
      final rawLinkUrl = linkUrlToken.value;
      final normalizedUrl = normalizeUrl(rawLinkUrl);

      // 1. Calculate the style inherited from formatting markers *outside* the link
      TextStyle inheritedStyle = state.baseStyle;
      for (final entry in state.formatStack) {
        // Use the resolver to apply styles from the current stack
        inheritedStyle = state.styleResolver.resolveStyle(entry.type, inheritedStyle);
      }

      // 2. Resolve link-specific styles, cursor, and callbacks using the resolver
      //    Pass the calculated inheritedStyle as the base for link style resolution.
      final TextStyle finalLinkStyle = state.styleResolver.resolveLinkStyle(inheritedStyle);
      final TextStyle finalLinkHoverStyle =
          state.styleResolver.resolveLinkHoverStyle(inheritedStyle);
      final MouseCursor effectiveCursor = state.styleResolver.resolveLinkMouseCursor();
      final void Function(String url, String displayText)? effectiveOnTap =
          state.styleResolver.resolveOnUrlTap();
      final void Function(String url, String displayText, {required bool isHovering})?
          effectiveOnHover = state.styleResolver.resolveOnUrlHover();

      // 3. Prepare TapGestureRecognizer if needed
      TapGestureRecognizer? recognizer;
      if (effectiveOnTap != null) {
        recognizer = TapGestureRecognizer()
          ..onTap = () => effectiveOnTap(normalizedUrl, rawLinkText);
        // Remember to handle recognizer disposal if necessary, usually managed
        // by the widget holding the TextSpan tree (e.g., dispose in HoverableLinkSpanState).
      }

      // 4. Parse the inner link text (between []) for nested formatting
      List<InlineSpan> childrenSpans = [];
      String? spanText; // Will hold plain text if no inner formatting

      final tokenizerForLinkText = TextfTokenizer();
      final linkTextTokens = tokenizerForLinkText.tokenize(rawLinkText);
      final bool containsFormattingMarkers =
          linkTextTokens.any((token) => token.type != TokenType.text);

      if (containsFormattingMarkers) {
        // Parse inner content, using the *resolved normal link style* as the base
        final innerParser = TextfParser(); // Use a separate parser instance
        childrenSpans = innerParser.parse(
          rawLinkText,
          context, // Pass context for the inner parse
          finalLinkStyle, // Use the calculated link style as base
        );
        spanText = null;
      } else {
        // Plain text content, remove escape characters
        spanText = rawLinkText.replaceAllMapped(
          RegExp(r'\\([*_~`\[\]()\\])'),
          (match) => match.group(1) ?? '',
        );
        childrenSpans = [];
      }

      // 5. Create the HoverableLinkSpan widget
      final hoverableWidget = HoverableLinkSpan(
        url: normalizedUrl,
        rawDisplayText: rawLinkText,
        initialChildrenSpans: childrenSpans, // Parsed inner content
        initialPlainText: spanText, // Plain inner content
        normalStyle: finalLinkStyle, // Resolved normal style
        hoverStyle: finalLinkHoverStyle, // Resolved hover style
        tapRecognizer: recognizer,
        mouseCursor: effectiveCursor, // Resolved cursor
        onHoverCallback: effectiveOnHover, // Resolved hover callback
      );

      // 6. Add the widget as a WidgetSpan
      state.spans.add(
        WidgetSpan(
          child: hoverableWidget,
          alignment: PlaceholderAlignment.baseline,
          baseline: TextBaseline.alphabetic,
        ),
      );

      // 7. Mark all 5 link tokens as processed
      _markLinkTokensProcessed(state, index);

      // 8. Return the index *after* the link structure (after ')')
      return index + _linkTokenCount;
    } else {
      // --- Not a valid link structure ---
      // Treat the opening bracket '[' as plain text.
      state.textBuffer += tokens[index].value; // Add '[' character
      state.processedIndices.add(index); // Mark '[' as processed

      // Let the main parsing loop continue from the next token
      return null;
    }
  }

  /// Normalizes a URL string (e.g., adds 'http://' if scheme is missing).
  @visibleForTesting
  static String normalizeUrl(String url) {
    final String normalizedUrl = url.trim();
    if (!normalizedUrl.contains(':') && //
        !normalizedUrl.startsWith('/') &&
        !normalizedUrl.startsWith('#') &&
        normalizedUrl.contains('.')) {
      return 'http://$normalizedUrl';
    }

    return normalizedUrl;
  }

  /// Checks if tokens starting at `index` form a complete `[text](url)` structure.
  static bool _isCompleteLink(List<Token> tokens, int index) {
    // Needs 5 tokens: linkStart, text, linkSeparator, urlText, linkEnd
    if (index + _linkEndOffset >= tokens.length) {
      return false;
    }

    return tokens[index].type == TokenType.linkStart &&
        tokens[index + _linkTextOffset].type == TokenType.text && // Link text (can be empty)
        tokens[index + _linkSeparatorOffset].type == TokenType.linkSeparator && // `](`
        tokens[index + _linkUrlOffset].type == TokenType.text && // URL text (can be empty)
        tokens[index + _linkEndOffset].type == TokenType.linkEnd; // `)`
  }

  /// Marks the 5 tokens forming a complete link structure as processed.
  static void _markLinkTokensProcessed(ParserState state, int startIndex) {
    // Mark '[', 'text', '](', 'url', ')' as processed
    for (int i = 0; i < _linkTokenCount; i++) {
      state.processedIndices.add(startIndex + i);
    }
  }
}

<!-- END FILE: [v0.6.1] lib/src/parsing/components/link_handler.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/parsing/components/nesting_validator.dart -->
import '../../models/token_type.dart';

/// Validates proper nesting of formatting markers.
///
/// This class ensures that formatting markers are properly nested,
/// which is important for correct rendering of formatted text.
/// It identifies and removes invalid pairs that would cause
/// improper nesting of formatting.
class NestingValidator {
  /// Maximum formatting nesting depth allowed by the parser.
  ///
  /// This limits how many layers of formatting can be nested:
  /// - Bold text = 1 level
  /// - Bold text containing italic text = 2 levels
  /// - Bold text containing italic text with strikethrough = 3 levels (exceeds max)
  ///
  /// When the nesting depth exceeds this limit, additional formatting markers
  /// are treated as plain text to maintain predictable rendering behavior.
  static const int maxDepth = 2;

  /// Validates proper nesting of formatting markers and returns valid pairs.
  ///
  /// This method:
  /// 1. Checks that opening and closing markers follow a proper nesting structure
  /// 2. Identifies improperly nested markers
  /// 3. Removes invalid pairs that would cause improper nesting
  ///
  /// @param tokens The list of tokens to validate
  /// @param candidatePairs The initial pairs identified by the pairing resolver
  /// @return A map of validated pairs with invalid ones removed
  static Map<int, int> validatePairs(
    List<Token> tokens,
    Map<int, int> candidatePairs,
  ) {
    final Map<int, int> validatedPairs = Map.from(candidatePairs);
    final List<int> openingStack = [];
    final Set<int> invalidPairs = {};

    // Check each token for proper nesting
    for (int i = 0; i < tokens.length; i++) {
      final token = tokens[i];

      if (token.type == TokenType.text) continue;

      final matchingIndex = candidatePairs[i];
      if (matchingIndex == null) continue; // Skip unpaired markers

      if (matchingIndex > i) {
        // This is an opening marker

        // Check nesting depth limit
        if (openingStack.length >= maxDepth) {
          // Exceeds maximum nesting depth, mark as invalid
          invalidPairs
            ..add(i)
            ..add(matchingIndex);
          continue;
        }

        openingStack.add(i);
      } else {
        // This is a closing marker
        if (openingStack.isNotEmpty && openingStack.last == matchingIndex) {
          // Proper nesting - remove from stack
          openingStack.removeLast();
        } else {
          // Improper nesting
          _handleImproperNesting(
            openingStack,
            matchingIndex,
            invalidPairs,
            candidatePairs,
          );
        }
      }
    }

    // Remove invalid pairs
    for (final index in invalidPairs) {
      validatedPairs.remove(index);
    }

    return validatedPairs;
  }

  /// Handles improperly nested formatting markers.
  ///
  /// This method identifies and marks as invalid all pairs that are
  /// improperly nested within the current formatting context.
  ///
  /// @param openingStack The stack of opening markers
  /// @param matchingIndex The index of the matching opening marker
  /// @param invalidPairs The set of invalid pair indices
  /// @param pairs The complete map of pairs
  static void _handleImproperNesting(
    List<int> openingStack,
    int matchingIndex,
    Set<int> invalidPairs,
    Map<int, int> pairs,
  ) {
    // Find position of matching opening marker in stack
    int openingPos = -1;
    for (int j = 0; j < openingStack.length; j++) {
      if (openingStack[j] == matchingIndex) {
        openingPos = j;
        break;
      }
    }

    if (openingPos != -1) {
      // Mark all pairs from openingPos to end as invalid
      for (int j = openingPos; j < openingStack.length; j++) {
        final openIndex = openingStack[j];
        final closeIndex = pairs[openIndex]!;

        invalidPairs
          ..add(openIndex)
          ..add(closeIndex);
      }

      // Remove processed markers
      openingStack.removeRange(openingPos, openingStack.length);
    }
  }
}

<!-- END FILE: [v0.6.1] lib/src/parsing/components/nesting_validator.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/parsing/components/pairing_resolver.dart -->
import '../../models/token_type.dart';
import 'nesting_validator.dart';

/// Identifies matching pairs of formatting markers in a token list.
///
/// This class handles the process of matching opening and closing
/// formatting markers, which is a critical step in the parsing process.
/// It includes optimizations for handling different marker types and
/// robust error handling for malformed input.
class PairingResolver {
  /// Identifies matching pairs of formatting markers.
  ///
  /// This method:
  /// 1. Identifies simple pairs based on token type
  /// 2. Applies context-aware pairing for ambiguous cases (not currently implemented, but structure allows)
  /// 3. Validates proper nesting of the identified pairs using NestingValidator.
  ///
  /// @param tokens The list of tokens to analyze
  /// @return A map where keys are token indices and values are their matching pair indices
  static Map<int, int> identifyPairs(List<Token> tokens) {
    final Map<int, int> pairs = {};

    // First pass: identify simple pairs by type
    _identifySimplePairs(tokens, pairs);

    // Validate nesting and remove invalid pairs
    return NestingValidator.validatePairs(tokens, pairs);
  }

  /// Identifies simple pairs of matching markers based on token type.
  ///
  /// This method uses a stack-based approach to pair opening and closing
  /// markers of the same type in a left-to-right pass.
  ///
  /// @param tokens The list of tokens to analyze
  /// @param pairs The map to populate with identified pairs
  static void _identifySimplePairs(List<Token> tokens, Map<int, int> pairs) {
    // Stack of opening markers for each type
    final Map<TokenType, List<int>> openingStacks = {
      TokenType.boldMarker: [],
      TokenType.italicMarker: [],
      TokenType.boldItalicMarker: [],
      TokenType.strikeMarker: [],
      TokenType.codeMarker: [],
      TokenType.underlineMarker: [],
      TokenType.highlightMarker: [],
    };

    // First pass - pair markers based on type
    for (int i = 0; i < tokens.length; i++) {
      final token = tokens[i];

      // Only consider formatting markers for pairing.
      // Text tokens and link-specific tokens are ignored here.
      if (!token.type.isFormattingMarker) {
        continue;
      }

      // Get the stack for the current token's type.
      // If the token type is not in openingStacks (e.g., an unknown formatting marker),
      // it will be skipped, which is the desired behavior.
      final stack = openingStacks[token.type];
      if (stack == null) continue; // Should not happen for known formatting markers

      if (stack.isEmpty) {
        // No opening marker of this type on the stack yet - treat this as an opening marker.
        stack.add(i);
      } else {
        // An opening marker of this type exists on the stack - pair it with this closing marker.
        final int openingIndex = stack.removeLast();

        // Record the pair (bidirectionally)
        pairs[openingIndex] = i;
        pairs[i] = openingIndex;
      }
    }
    // At this point, any markers remaining on the stacks in `openingStacks`
    // are unpaired opening markers. They will not be included in the `pairs` map.
  }
}

<!-- END FILE: [v0.6.1] lib/src/parsing/components/pairing_resolver.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/widgets/internal/hoverable_link_span.dart -->
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// An internal StatefulWidget used by Textf's LinkHandler to render interactive links
/// that can visually change style on hover.
///
/// This widget manages its own hover state (`_isHovering`) and switches
/// between the provided `normalStyle` and `hoverStyle`. It renders a
/// single `Text.rich` containing the link's content (either plain text
/// or pre-parsed child spans passed via `initialChildrenSpans` or `initialPlainText`).
///
/// It's intended to be wrapped within a `WidgetSpan` by the `LinkHandler`.
class HoverableLinkSpan extends StatefulWidget {
  /// Creates an internal widget to manage hover state and interaction for a link.
  const HoverableLinkSpan({
    required this.url,
    required this.rawDisplayText,
    required this.initialChildrenSpans,
    required this.normalStyle,
    required this.hoverStyle,
    required this.tapRecognizer,
    required this.mouseCursor,
    super.key,
    this.initialPlainText,
    this.onHoverCallback,
  });

  /// The target URL of the link.
  final String url;

  /// The original, raw display text of the link as it appeared in the
  /// source string (including formatting markers). Used for callbacks.
  final String rawDisplayText;

  /// Pre-parsed list of `InlineSpan` children if the link's display
  /// text itself contained formatting (e.g., `[**bold** link](url)`).
  /// Should be empty if `initialPlainText` is provided.
  final List<InlineSpan> initialChildrenSpans;

  /// The plain display text of the link, used if `initialChildrenSpans` is empty.
  final String? initialPlainText;

  /// The style to apply when the link is not hovered. Resolved by TextfStyleResolver.
  final TextStyle normalStyle;

  /// The style to apply when the link is hovered. Resolved by TextfStyleResolver.
  final TextStyle hoverStyle;

  /// An optional pre-configured `TapGestureRecognizer` for handling taps.
  /// Created by LinkHandler if an `onUrlTap` callback is available.
  final TapGestureRecognizer? tapRecognizer;

  /// The mouse cursor to display when hovering over the link. Resolved by TextfStyleResolver.
  final MouseCursor mouseCursor;

  /// An optional callback function triggered when the hover state changes.
  /// Resolved by TextfStyleResolver. Provides the URL, the raw display text,
  /// and the new hover state (`true` for enter, `false` for exit).
  final void Function(String url, String rawDisplayText, {required bool isHovering})?
      onHoverCallback;

  @override
  State<HoverableLinkSpan> createState() => HoverableLinkSpanState();
}

/// The state class for [HoverableLinkSpan] that manages hover interactions
/// and applies the appropriate styles based on hover state.
class HoverableLinkSpanState extends State<HoverableLinkSpan> {
  /// Tracks whether the mouse cursor is currently over this specific link instance.
  bool _isHovering = false;

  /// Handles the pointer entering the bounds of the link.
  void _onEnter(PointerEnterEvent event) {
    if (mounted) {
      setState(() => _isHovering = true);
      // Notify listener about hover start, passing URL and raw text
      widget.onHoverCallback?.call(widget.url, widget.rawDisplayText, isHovering: true);
    }
  }

  /// Handles the pointer exiting the bounds of the link.
  void _onExit(PointerExitEvent event) {
    if (mounted) {
      setState(() => _isHovering = false);
      // Notify listener about hover end
      widget.onHoverCallback?.call(widget.url, widget.rawDisplayText, isHovering: false);
    }
  }

  /// Recursively applies interaction handlers (tap recognizer, hover callbacks, cursor)
  /// and the correct style (normal or hover) to a given InlineSpan and its children.
  /// This ensures that the entire clickable/hoverable area of the link reacts appropriately.
  InlineSpan _applyInteraction(InlineSpan span) {
    if (span is TextSpan) {
      final TextStyle innerSpanOriginalStyle = span.style ?? widget.normalStyle;
      final TextStyle targetLinkAppearance = _isHovering ? widget.hoverStyle : widget.normalStyle;

      // Determine the final decoration for this span segment
      TextDecoration? finalDecoration;

      // The decoration from the link itself (e.g., underline from normalStyle/hoverStyle)
      final TextDecoration? linkBaseDecoration = targetLinkAppearance.decoration;

      // The decoration already present on the inner span (e.g., lineThrough, or combine)
      final TextDecoration? innerExistingDecoration = innerSpanOriginalStyle.decoration;

      finalDecoration = (linkBaseDecoration != null && linkBaseDecoration != TextDecoration.none)
          ? ((innerExistingDecoration != null && innerExistingDecoration != TextDecoration.none)
              ? (innerExistingDecoration.contains(linkBaseDecoration)
                  ? innerExistingDecoration
                  : TextDecoration.combine([innerExistingDecoration, linkBaseDecoration]))
              : linkBaseDecoration)
          : innerExistingDecoration;

      // Determine final decoration color and thickness
      // Priority:
      // 1. If targetLinkAppearance (the link's current style) defines them.
      // 2. Else, if innerSpanOriginalStyle defines them.
      // 3. Else, null (let Flutter decide or inherit).
      // This logic might need refinement based on desired visual outcome for combined decorations.
      // For now, let the targetLinkAppearance's properties (if set) take precedence for the overall link feel.
      final Color? finalDecorationColor =
          targetLinkAppearance.decorationColor ?? innerSpanOriginalStyle.decorationColor;
      final double? finalDecorationThickness =
          targetLinkAppearance.decorationThickness ?? innerSpanOriginalStyle.decorationThickness;

      final TextStyle finalSpanStyle = innerSpanOriginalStyle.copyWith(
        color: targetLinkAppearance.color ?? innerSpanOriginalStyle.color,
        decoration: finalDecoration,
        decorationColor: finalDecorationColor,
        decorationThickness: finalDecorationThickness,
        // Preserve other properties from innerSpanOriginalStyle like fontWeight, fontStyle, backgroundColor
        // by not specifying them here if targetLinkAppearance doesn't override them.
        // backgroundColor, letterSpacing etc. should come from innerSpanOriginalStyle unless
        // targetLinkAppearance explicitly sets them (which it usually doesn't for these).
      );

      return TextSpan(
        text: span.text,
        children: span.children?.map(_applyInteraction).toList(),
        style: finalSpanStyle,
        recognizer: widget.tapRecognizer,
        semanticsLabel: span.semanticsLabel,
        locale: span.locale,
        spellOut: span.spellOut,
      );
    }

    return span;
  }

  @override
  void dispose() {
    // If a TapGestureRecognizer was created and passed in,
    // it must be disposed when the widget is removed to prevent memory leaks.
    widget.tapRecognizer?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Determine the initial content spans: either the pre-parsed children
    // or a single TextSpan containing the plain text.
    // Note: The initial spans/text don't yet have the interaction handlers attached.
    final List<InlineSpan> initialContentSpans = widget.initialChildrenSpans.isNotEmpty
        ? widget.initialChildrenSpans
        // If plain text, wrap it in a TextSpan. Use normalStyle as the base here,
        // though _applyInteraction will merge the final normal/hover style again.
        : [TextSpan(text: widget.initialPlainText, style: widget.normalStyle)];

    // Apply interaction handlers and correct styling (normal/hover) recursively
    // to the initial content spans.
    final List<InlineSpan> interactiveSpans = initialContentSpans
        .map(_applyInteraction) // Apply handlers and styles
        .toList();

    // Render the resulting interactive spans within a Text.rich widget.
    // The outer TextSpan has no text or style itself, just acts as a container.
    return MouseRegion(
      cursor: widget.mouseCursor, // Der √ºbergebene Cursor (z.B. help)
      onEnter: _onEnter, // Eigene Methode f√ºr Hover-Effekte
      onExit: _onExit, // Eigene Methode f√ºr Hover-Effekte
      opaque: false, // Wichtig f√ºr Textselektion
      child: Text.rich(
        TextSpan(
          children: interactiveSpans,
        ),
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] lib/src/widgets/internal/hoverable_link_span.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/src/widgets/internal/textf_renderer.dart -->
import 'dart:ui' as ui show TextHeightBehavior;

import 'package:flutter/material.dart';

import '../../parsing/textf_parser.dart';

/// Internal StatefulWidget that handles parsing, styling resolution via the parser,
/// and hot reload notification. It bridges the Textf widget parameters with
/// the parsing and rendering logic provided by the TextfParser.
class TextfRenderer extends StatefulWidget {
  /// Creates a new TextfRenderer widget.
  const TextfRenderer({
    required this.data,
    required this.style,
    required this.parser,
    required this.strutStyle,
    required this.textAlign,
    required this.textDirection,
    required this.locale,
    required this.softWrap,
    required this.overflow,
    required this.textScaler,
    required this.maxLines,
    required this.semanticsLabel,
    required this.textWidthBasis,
    required this.textHeightBehavior,
    required this.selectionColor,
    super.key,
  });

  /// The text data containing potential formatting markers.
  final String data;

  /// The explicit base text style provided to the Textf widget.
  /// If null, DefaultTextStyle will be used.
  final TextStyle? style;

  /// The parser instance responsible for converting the data string
  /// into a list of InlineSpans, using its internal style resolver.
  final TextfParser parser;

  /// {@macro flutter.widgets.basic.strutStyle}
  final StrutStyle? strutStyle;

  /// {@macro flutter.widgets.basic.textAlign}
  final TextAlign? textAlign;

  /// {@macro flutter.widgets.basic.textDirection}
  final TextDirection? textDirection;

  /// {@macro flutter.widgets.basic.locale}
  final Locale? locale;

  /// {@macro flutter.widgets.basic.softWrap}
  final bool? softWrap;

  /// {@macro flutter.widgets.basic.overflow}
  final TextOverflow? overflow;

  /// {@macro flutter.widgets.basic.textScaler}
  final TextScaler? textScaler;

  /// {@macro flutter.widgets.basic.maxLines}
  final int? maxLines;

  /// {@macro flutter.widgets.basic.semanticsLabel}
  final String? semanticsLabel;

  /// {@macro flutter.widgets.basic.textWidthBasis}
  final TextWidthBasis? textWidthBasis;

  /// {@macro flutter.widgets.basic.textHeightBehavior}
  final ui.TextHeightBehavior? textHeightBehavior;

  /// {@macro flutter.widgets.basic.selectionColor}
  final Color? selectionColor;

  @override
  State<TextfRenderer> createState() => TextfRendererState();
}

/// The state class for [TextfRenderer] that builds the text widget
class TextfRendererState extends State<TextfRenderer> {
  @override
  Widget build(BuildContext context) {
    // Determine the effective base text style for parsing.
    // It considers the widget's explicit style and the ambient DefaultTextStyle.
    final DefaultTextStyle defaultTextStyle = DefaultTextStyle.of(context);
    final TextStyle currentBaseStyle = widget.style ?? defaultTextStyle.style;
    final TextScaler effectiveScaler = widget.textScaler ?? MediaQuery.textScalerOf(context);

    // Invoke the parser. The parser instance (widget.parser) is expected
    // to handle the creation and usage of TextfStyleResolver internally
    // using the provided context.
    final List<InlineSpan> spans = widget.parser.parse(
      widget.data,
      context, // Pass the current BuildContext, needed by the style resolver within the parser.
      currentBaseStyle,
      textScaler: effectiveScaler,
    );

    // Render the parsed spans using Text.rich.
    // Pass all the standard Text properties through.
    return Text.rich(
      TextSpan(
        // The root TextSpan's style is taken from the explicit widget style.
        // If widget.style is null, Text.rich implicitly uses DefaultTextStyle.
        // The `currentBaseStyle` was used by the parser for *calculating* child styles.
        style: widget.style,
        children: spans,
      ),
      strutStyle: widget.strutStyle,
      textAlign: widget.textAlign,
      textDirection: widget.textDirection,
      locale: widget.locale,
      softWrap: widget.softWrap,
      overflow: widget.overflow,
      textScaler: effectiveScaler,
      maxLines: widget.maxLines,
      semanticsLabel: widget.semanticsLabel,
      textWidthBasis: widget.textWidthBasis,
      textHeightBehavior: widget.textHeightBehavior,
      selectionColor: widget.selectionColor,
    );
  }
}

<!-- END FILE: [v0.6.1] lib/src/widgets/internal/textf_renderer.dart -->

<!-- BEGIN FILE: [v0.6.1] lib/textf.dart -->
/// A lightweight text widget library for simple inline formatting.
///
/// This library provides the Textf widget which supports basic
/// markdown-like formatting for text in Flutter applications.
library;

// Export the widget for public use
export 'src/widgets/textf.dart';
export 'src/widgets/textf_options.dart';

<!-- END FILE: [v0.6.1] lib/textf.dart -->

<!-- BEGIN FILE: [v0.6.1] example/lib/main.dart -->
/// A simple example demonstrating the core features of the Textf package.
///
/// This example shows:
/// - Basic text formatting without configuration
/// - Custom styling with TextfOptions
/// - Interactive links with hover effects
library;

import 'package:flutter/material.dart';
import 'package:textf/textf.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Textf Demo',
      theme: ThemeData(colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue), useMaterial3: true),
      home: const MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  const MyHomePage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: const Text('Textf Examples'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Example 1: Basic usage with default styling
            const Text('Example 1: Basic Usage', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const SizedBox(height: 16),

            // Textf supports markdown-like syntax out of the box
            const Textf('This is **bold** text and this is *italic*.', style: TextStyle(fontSize: 16)),
            const SizedBox(height: 8),

            // Strikethrough and inline code formatting
            const Textf('Text with ~~strikethrough~~ and `inline code`.', style: TextStyle(fontSize: 16)),
            const SizedBox(height: 8),

            // Additional formatting options
            const Textf('Also supports ++underline++ and ==highlight==!', style: TextStyle(fontSize: 16)),
            const SizedBox(height: 8),

            // Links are rendered with theme colors by default
            const Textf('A [link to Flutter](https://flutter.dev) in text.', style: TextStyle(fontSize: 16)),

            const SizedBox(height: 32),

            // Example 2: Custom styling with TextfOptions
            const Text(
              'Example 2: Custom Styling with TextfOptions',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),

            // TextfOptions allows customization of formatting styles
            TextfOptions(
              // Make bold text red and extra bold
              boldStyle: const TextStyle(fontWeight: FontWeight.w900, color: Colors.red),

              // Add background to inline code
              codeStyle: TextStyle(backgroundColor: Colors.green.shade200, fontStyle: FontStyle.italic),

              // Style links: blue without underline
              urlStyle: const TextStyle(color: Colors.blue, decoration: TextDecoration.none),

              // Add underline on hover
              urlHoverStyle: const TextStyle(
                color: Colors.blue,
                decoration: TextDecoration.underline,
                decorationColor: Colors.blue,
              ),

              // Handle link clicks
              onUrlTap: (url, displayText) {
                debugPrint('Link clicked: $displayText -> $url');
              },

              // Handle hover state changes
              onUrlHover: (url, displayText, {required bool isHovering}) {
                debugPrint('Hovering over "$displayText": $isHovering');
              },

              // All Textf widgets inside this will use these custom styles
              child: const Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Textf('**Red bold text** with normal text.', style: TextStyle(fontSize: 16)),
                  SizedBox(height: 8),
                  Textf('Code has `green background` with italic style.', style: TextStyle(fontSize: 16)),
                  SizedBox(height: 8),
                  Textf(
                    'Links are [blue without underline](https://example.com) - '
                    'they get underlined on hover.',
                    style: TextStyle(fontSize: 16),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/lib/main.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/README.md -->
# Textf Example App

This example app demonstrates various use cases of the Textf widget, showcasing its formatting capabilities and real-world applications.

## Getting Started

1. **Navigate to the example directory:**

    ```bash
    cd example/textf_core
    ```

2. **Ensure Full Project Structure:**
    Run the following command within the `textf_flex` directory. This ensures all necessary platform-specific directories (`android`, `ios`, `web`, etc.) and files are present, even if they were missing (e.g., after cloning). It will *not* overwrite your existing code in `lib/` or your `pubspec.yaml`.

    ```bash
    flutter create .
    ```

3. **Ensure Dependencies are Installed:**

    Fetch the packages:

    ```bash
    flutter pub get
    ```

4. **Run the app:**

    ```bash
    flutter run
    ```

## What's Included

The example app contains:

- **Basic Formatting** - Bold, italic, strikethrough, and code formatting examples
- **Nested Formatting** - Demonstration of proper nesting with different marker types
- **Complex Formatting** - Unicode support, custom styling, and overflow handling
- **Chat Bubbles** - Interactive chat interface with formatted messages
- **Notifications** - System notification examples with formatted text
- **URL Examples** - URL fromatting and callback examples
- **Screenshot Generator** - Create and capture formatted text with custom styling

## Screenshots

The app includes a screenshot tool to help generate examples for your own documentation.

## Directory Structure

```bash
textf_core
‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îú‚îÄ‚îÄ main.dart
‚îÇ   ‚îú‚îÄ‚îÄ screens
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ basic_formatting_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat_example_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ complex_formatting_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nested_formatting_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notification_example_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ screenshot_screen.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ theme_example_screen.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ url_example_screen.dart
‚îÇ   ‚îî‚îÄ‚îÄ widgets
‚îÇ       ‚îî‚îÄ‚îÄ example_card.dart
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ analysis_options.yaml
‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îî‚îÄ‚îÄ fonts
‚îÇ       ‚îú‚îÄ‚îÄ RobotoMono-Italic-VariableFont_wght.ttf
‚îÇ       ‚îî‚îÄ‚îÄ RobotoMono-VariableFont_wght.ttf
‚îî‚îÄ‚îÄ pubspec.yaml
```

## Creating Screenshot Examples

Use the screenshot tool to create examples for documentation:

1. Navigate to the "Screenshot Generator" screen
2. Enter your formatted text with Markdown-style syntax
3. Customize the appearance using the formatting options
4. Tap "Capture Screenshot" to save the image

<!-- END FILE: [v0.6.1] example/textf_core/README.md -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/pubspec.yaml -->
name: textf_core
description: A new Flutter project to showcase Textf library.
publish_to: "none"
version: 0.2.0

environment:
  sdk: ">=3.0.0 <4.0.0"
  flutter: ">=3.0.0"

dependencies:
  cupertino_icons: ^1.0.2
  flutter:
    sdk: flutter
  share_plus: ^10.1.4
  super_clipboard: ^0.8.24
  textf: ^0.6.1
  url_launcher: ^6.3.1

# dependency_overrides:
#   textf:
#     path: ../../

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0

flutter:
  uses-material-design: true

  assets:
    - assets/fonts/

  fonts:
    - family: RobotoMono
      fonts:
        - asset: assets/fonts/RobotoMono-VariableFont_wght.ttf
        - asset: assets/fonts/RobotoMono-Italic-VariableFont_wght.ttf
          style: italic

<!-- END FILE: [v0.6.1] example/textf_core/pubspec.yaml -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/analysis_options.yaml -->
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

analyzer:
linter:
  rules:
    require_trailing_commas: true
    prefer_relative_imports: true
formatter:
  page_width: 120
<!-- END FILE: [v0.6.1] example/textf_core/analysis_options.yaml -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/main.dart -->
// example/lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'screens/home_screen.dart';

void main() {
  runApp(const TextfExampleApp());
}

class TextfExampleApp extends StatefulWidget {
  const TextfExampleApp({super.key});

  @override
  State<TextfExampleApp> createState() => _TextfExampleAppState();
}

class _TextfExampleAppState extends State<TextfExampleApp> {
  // Use ValueNotifier for simple state management
  // Initialize with system preference or default to dark
  late final ValueNotifier<ThemeMode> _themeModeNotifier;

  @override
  void initState() {
    super.initState();
    // Read initial system theme preference
    final Brightness platformBrightness = SchedulerBinding.instance.platformDispatcher.platformBrightness;
    _themeModeNotifier = ValueNotifier(platformBrightness == Brightness.dark ? ThemeMode.dark : ThemeMode.light);
  }

  @override
  void dispose() {
    _themeModeNotifier.dispose();
    super.dispose();
  }

  void _toggleThemeMode() {
    _themeModeNotifier.value = _themeModeNotifier.value == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;
  }

  @override
  Widget build(BuildContext context) {
    // Listen to the notifier to rebuild MaterialApp when the theme changes
    return ValueListenableBuilder<ThemeMode>(
      valueListenable: _themeModeNotifier,
      builder: (context, currentMode, child) {
        return MaterialApp(
          debugShowCheckedModeBanner: false,
          title: 'Textf Example',
          // Define explicit light and dark themes
          theme: ThemeData(
            colorScheme: ColorScheme.fromSeed(
              seedColor: Colors.blue,
              brightness: Brightness.light,
            ),
            useMaterial3: true,
          ),
          darkTheme: ThemeData(
            colorScheme: ColorScheme.fromSeed(
              seedColor: Colors.blue,
              brightness: Brightness.dark,
            ),
            useMaterial3: true,
          ),
          themeMode: currentMode,
          home: HomeScreen(
            currentThemeMode: currentMode,
            toggleThemeMode: _toggleThemeMode,
          ),
        );
      },
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/main.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/basic_formatting_screen.dart -->
// example/textf_core/lib/screens/basic_formatting_screen.dart
import 'package:flutter/material.dart';
import 'package:textf/textf.dart';

import '../widgets/example_card.dart';

class BasicFormattingScreen extends StatelessWidget {
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const BasicFormattingScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  Widget build(BuildContext context) {
    // Determine the icon based on the current theme mode
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;
    return Scaffold(
      appBar: AppBar(
        title: const Text('Basic Formatting'),
        actions: [
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: toggleThemeMode,
          ),
        ],
      ),
      body: SelectionArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: const [
            ExampleCard(
              title: 'Bold',
              description: 'Use ** or __ to make text bold',
              code: "Textf('This is **bold** text')",
              child: Textf('This is **bold** text'),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Italic',
              description: 'Use * or _ to make text italic',
              code: "Textf('This is *italic* text')",
              child: Textf('This is *italic* text'),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Bold and Italic',
              description: 'Use *** or ___ for both bold and italic',
              code: "Textf('This is ***bold and italic*** text')",
              child: Textf('This is ***bold and italic*** text'),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Strikethrough',
              description: 'Use ~~ for strikethrough text',
              code: "Textf('This is ~~strikethrough~~ text')",
              child: Textf('This is ~~strikethrough~~ text'),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Underline',
              description: 'Use ++ for underlined text',
              code: "Textf('This is ++underlined++ text')",
              child: Textf('This is ++underlined++ text'),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Highlight',
              description: 'Use == for highlighted text (theme-aware default)',
              code: "Textf('This is ==highlighted== text')",
              child: Textf('This is ==highlighted== text'),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Code',
              description: 'Use backticks for inline code (theme-aware default)',
              code: "Textf('This is `code` text')",
              child: Textf('This is `code` text'),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Escaped Characters',
              description: 'Use backslash to escape formatting characters',
              code:
                  "Textf('Escape: \\*bold\\*, \\_italic\\_, \\~\\~strike\\~\\~, \\+\\+underline\\+\\+, \\=\\=highlight\\=\\=, \\`code\\`')",
              child: Textf(
                'Escape: \\*bold\\*, \\_italic\\_, \\~\\~strike\\~\\~, \\+\\+underline\\+\\+, \\=\\=highlight\\=\\=, \\`code\\`',
              ),
            ),
          ],
        ),
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/basic_formatting_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/chat_example_screen.dart -->
import 'package:flutter/material.dart';
import 'package:textf/textf.dart';

import '../widgets/example_card.dart';

class ChatExampleScreen extends StatelessWidget {
  // Add theme constructor parameters
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const ChatExampleScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  Widget build(BuildContext context) {
    // Add theme icon logic
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Chat Bubble Example'),
        actions: [
          // Add actions here
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: toggleThemeMode,
          ),
        ],
      ),
      body: SelectionArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            ExampleCard(
              // No need to pass theme info to ExampleCard directly
              title: 'Chat Bubble',
              description: 'Formatted text in a chat bubble using theme colors', // Updated description
              code: '''Container(
  padding: EdgeInsets.all(12),
  decoration: BoxDecoration(
    color: Colors.blue.shade100,
    borderRadius: BorderRadius.circular(12),
  ),
  child: Textf(
    'Hey! Did you read that **important** article '
    'I sent you about _Flutter performance_?',
    style: TextStyle(fontSize: 16),
  ),
)''',
              child: SizedBox(
                width: double.infinity,
                child: Align(
                  alignment: Alignment.centerRight,
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 250),
                    child: const ChatBubble(
                      // Use const if no params change
                      isMe: true,
                      message: 'Hey! Did you read that **important** article I sent you about _Flutter performance_?',
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 16),

            SizedBox(
              width: double.infinity,
              child: Align(
                alignment: Alignment.centerLeft,
                child: ConstrainedBox(
                  constraints: const BoxConstraints(maxWidth: 250),
                  child: const ChatBubble(
                    // Use const
                    isMe: false,
                    message:
                        'Yes! I found the section about **widget rebuilds** particularly _insightful_. We should apply those techniques to our ~~slow~~ `app`!',
                  ),
                ),
              ),
            ),
            const SizedBox(height: 24),
            Text(
              'Interactive Chat Example',
              style: Theme.of(context).textTheme.titleLarge, // Use theme style
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            // Full chat example
            const ChatExample(), // Use const
          ],
        ),
      ),
    );
  }
}

class ChatBubble extends StatelessWidget {
  final bool isMe;
  final String message;

  const ChatBubble({
    super.key,
    required this.isMe,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context); // Get theme
    // Use theme colors for bubbles
    final bubbleColor = isMe ? theme.colorScheme.primaryContainer : theme.colorScheme.surfaceContainerHighest;
    // Determine appropriate text color based on bubble color for contrast
    final textColor = isMe ? theme.colorScheme.onPrimaryContainer : theme.colorScheme.onSurfaceVariant; // Or onSurface

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8), // Adjusted padding
      decoration: BoxDecoration(
        color: bubbleColor, // Use theme color
        borderRadius: BorderRadius.only(
          topLeft: const Radius.circular(12),
          topRight: const Radius.circular(12),
          bottomLeft: Radius.circular(isMe ? 12 : 0),
          bottomRight: Radius.circular(isMe ? 0 : 12),
        ),
      ),
      child: Textf(
        message,
        // Set explicit text color for contrast
        style: TextStyle(fontSize: 16, color: textColor),
      ),
    );
  }
}

class ChatExample extends StatefulWidget {
  const ChatExample({super.key});

  @override
  State<ChatExample> createState() => _ChatExampleState();
}

class _ChatExampleState extends State<ChatExample> {
  final List<ChatMessage> _messages = [
    ChatMessage(
      message: 'Hey! Did you read that **important** article I sent you about _Flutter performance_?',
      isMe: true,
    ),
    ChatMessage(
      message: 'Yes! I found the section about **widget rebuilds** particularly _insightful_.',
      isMe: false,
    ),
    ChatMessage(
      message: 'We should apply those techniques to our ~~slow~~ `app`! ++Remember to check the docs++.',
      isMe: false,
    ),
    ChatMessage(
      message:
          'Also check out the default [link](https://flutter.dev) and `code` styling, ++underline++ and ==highlighting==.',
      isMe: true,
    ),
  ];

  final TextEditingController _textController = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  bool _isMe = true; // Keep toggling for demo

  @override
  void dispose() {
    _textController.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  void _handleSubmitted(String text) {
    if (text.trim().isEmpty) return; // Don't add empty messages
    _textController.clear();
    setState(() {
      _messages.insert(
        0, // Insert at the beginning for reverse list view
        ChatMessage(
          message: text,
          isMe: _isMe,
        ),
      );
      _isMe = !_isMe; // Toggle sender for demo purposes
    });
    // Delay focus request slightly if needed
    // Future.delayed(Duration(milliseconds: 50), () => _focusNode.requestFocus());
    _focusNode.requestFocus();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context); // Get theme

    return Column(
      children: [
        Container(
          height: 300,
          decoration: BoxDecoration(
            // Use theme color for list background
            color: theme.colorScheme.surfaceContainerLow,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: theme.colorScheme.outlineVariant.withValues(alpha: .5)),
          ),
          child: ListView.builder(
            padding: const EdgeInsets.all(8.0),
            reverse: true, // Keep reverse order
            itemCount: _messages.length,
            itemBuilder: (context, index) {
              // Access messages directly in reverse order for clarity
              final message = _messages[index];
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: Align(
                  alignment: message.isMe ? Alignment.centerRight : Alignment.centerLeft,
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 250),
                    child: ChatBubble(
                      // ChatBubble now handles its own theme colors
                      isMe: message.isMe,
                      message: message.message,
                    ),
                  ),
                ),
              );
            },
          ),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: TextField(
                // TextField adapts to theme automatically
                controller: _textController,
                focusNode: _focusNode,
                decoration: InputDecoration(
                  hintText: 'Type message (**bold**, _italic_, `code`, [link](url))...',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(24),
                    borderSide: BorderSide(
                      // Use theme color for border
                      color: theme.colorScheme.outline,
                    ),
                  ),
                  enabledBorder: OutlineInputBorder(
                    // Border when not focused
                    borderRadius: BorderRadius.circular(24),
                    borderSide: BorderSide(
                      color: theme.colorScheme.outline.withValues(alpha: .7),
                    ),
                  ),
                  focusedBorder: OutlineInputBorder(
                    // Border when focused
                    borderRadius: BorderRadius.circular(24),
                    borderSide: BorderSide(
                      color: theme.colorScheme.primary, // Highlight with primary color
                      width: 1.5,
                    ),
                  ),
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 10, // Adjusted padding
                  ),
                  isDense: true, // Make it more compact
                ),
                onSubmitted: _handleSubmitted,
                textInputAction: TextInputAction.send, // Action button on keyboard
                onTapOutside: (event) {
                  // Dismiss keyboard on tap outside
                  FocusScope.of(context).unfocus();
                },
              ),
            ),
            const SizedBox(width: 8),
            // Consider using IconButton for sending for better alignment/theming
            IconButton.filled(
              // Use filled tonal for less emphasis than primary filled
              style: IconButton.styleFrom(
                backgroundColor: theme.colorScheme.primaryContainer,
                foregroundColor: theme.colorScheme.onPrimaryContainer,
              ),
              tooltip: 'Send',
              icon: const Icon(Icons.send),
              onPressed: () {
                if (_textController.text.isNotEmpty) {
                  _handleSubmitted(_textController.text);
                }
              },
            ),
            // FloatingActionButton(
            //   mini: true,
            //   onPressed: () {
            //     if (_textController.text.isNotEmpty) {
            //       _handleSubmitted(_textController.text);
            //     }
            //   },
            //   child: const Icon(Icons.send),
            // ),
          ],
        ),
      ],
    );
  }
}

// ChatMessage class remains the same
class ChatMessage {
  final String message;
  final bool isMe;

  ChatMessage({
    required this.message,
    required this.isMe,
  });
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/chat_example_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/complex_formatting_screen.dart -->
// example/textf_core/lib/screens/complex_formatting_screen.dart
import 'package:flutter/material.dart';
import 'package:textf/textf.dart';

import '../widgets/example_card.dart';

class ComplexFormattingScreen extends StatelessWidget {
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const ComplexFormattingScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  Widget build(BuildContext context) {
    // Determine the icon based on the current theme mode
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;
    return Scaffold(
      appBar: AppBar(
        title: const Text('Complex Formatting'),
        actions: [
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: toggleThemeMode,
          ),
        ],
      ),
      body: SelectionArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            ExampleCard(
              title: 'Mixed Formatting',
              description: 'Combining multiple formatting styles in one text',
              code: '''
Textf(
  'The **quick** _brown_ fox jumps over '
  'the ~~lazy~~ ++wily++ ==alert== `dog`.'
)''',
              child: Textf(
                'The **quick** _brown_ fox jumps over '
                'the ~~lazy~~ ++wily++ ==alert== `dog`.',
              ),
            ),
            const SizedBox(height: 16),
            ExampleCard(
              title: 'Style Customization with TextfOptions',
              description: 'Using custom text style properties via TextfOptions for new formats',
              code: '''
TextfOptions(
  underlineStyle: TextStyle(
    decorationColor: Colors.deepOrange,
    decorationStyle: TextDecorationStyle.dotted,
    decorationThickness: 2,
  ),
  highlightStyle: TextStyle(
    backgroundColor: Colors.tealAccent.withOpacity(0.4),
    color: Colors.black,
    fontStyle: FontStyle.italic,
  ),
  child: Textf(
    '**Styled** _text_ with ~~formatting~~, '
    '++custom underline++, and ==custom highlight==.',
    style: TextStyle(
      fontSize: 18,
      height: 1.5,
    ),
    textAlign: TextAlign.center,
  ),
)''',
              child: TextfOptions(
                underlineStyle: const TextStyle(
                  decorationColor: Colors.deepOrange,
                  decorationStyle: TextDecorationStyle.dotted,
                  decorationThickness: 2,
                ),
                highlightStyle: TextStyle(
                  backgroundColor: Colors.tealAccent.withValues(alpha: .4),
                  color: Colors.black, // Text color for highlight
                  fontStyle: FontStyle.italic,
                ),
                child: Textf(
                  '**Styled** _text_ with ~~formatting~~, '
                  '++custom underline++, and ==custom highlight==.',
                  style: const TextStyle(
                    fontSize: 18,
                    height: 1.5,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            ),
            const SizedBox(height: 16),
            const ExampleCard(
              title: 'Unicode and Emoji Support',
              description: 'Formatting with non-Latin scripts and emoji, including new formats',
              code: "Textf('**‰Ω†Â•Ω‰∏ñÁïå** *ÏïàÎÖïÌïòÏÑ∏Ïöî* ~~–ü—Ä–∏–≤–µ—Ç~~ `üåç` ++ü§Ø++ ==üëÄ==')",
              child: Textf(
                '**‰Ω†Â•Ω‰∏ñÁïå** *ÏïàÎÖïÌïòÏÑ∏Ïöî* ~~–ü—Ä–∏–≤–µ—Ç~~ `üåç` ++ü§Ø++ ==üëÄ==',
              ),
            ),
            const SizedBox(height: 16),
            ExampleCard(
              title: 'Long Text with Overflow',
              description: 'Handling long text with ellipsis, including new formats',
              code: '''
Textf(
  'This is a **very long** text with _multiple_ '
  'formatting styles that will ~~likely~~ '
  'overflow, ++be underlined++, ==get highlighted==, '
  'and `demonstrate` how ellipsis works '
  'with formatted text.',
  maxLines: 2,
  overflow: TextOverflow.ellipsis,
)''',
              child: Textf(
                'This is a **very long** text with _multiple_ '
                'formatting styles that will ~~likely~~ '
                'overflow, ++be underlined++, ==get highlighted==, '
                'and `demonstrate` how ellipsis works '
                'with formatted text.',
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ),
            const SizedBox(height: 16),
            const ExampleCard(
              title: 'Combined Decorations',
              description: 'Demonstrating combined strikethrough and underline',
              code: "Textf('This text is ++~~both underlined and strikethrough~~++. And also ~~++vice versa++~~.')",
              child: Textf('This text is ++~~both underlined and strikethrough~~++. And also ~~++vice versa++~~.'),
            ),
          ],
        ),
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/complex_formatting_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/home_screen.dart -->
// example/lib/screens/home_screen.dart
import 'package:flutter/material.dart';

import 'basic_formatting_screen.dart';
import 'chat_example_screen.dart';
import 'complex_formatting_screen.dart';
import 'nested_formatting_screen.dart';
import 'notification_example_screen.dart';
import 'screenshot_screen.dart';
import 'theme_example_screen.dart';
import 'url_example_screen.dart';

class HomeScreen extends StatelessWidget {
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const HomeScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  Widget build(BuildContext context) {
    // Determine the icon based on the current theme mode
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon = currentBrightness == Brightness.dark
        ? Icons.light_mode_outlined // Icon to show when it's dark (will switch to light)
        : Icons.dark_mode_outlined; // Icon to show when it's light (will switch to dark)

    return Scaffold(
      appBar: AppBar(
        title: const Text('Textf Examples'),
        actions: [
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: toggleThemeMode, // Use the callback passed down
          ),
        ],
      ),
      body: SelectionArea(
        child: ListView(
          children: [
            // Add tile for the new Theme Example Screen
            _buildExampleTile(
              context,
              'Theme Examples',
              'Show default link/code styling adapting to themes',
              ThemeExampleScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
            _buildExampleTile(
              context,
              'Basic Formatting',
              'Simple examples of bold, italic, strikethrough, and code formatting',
              BasicFormattingScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
            _buildExampleTile(
              context,
              'Nested Formatting',
              'Examples of nested formatting styles',
              NestedFormattingScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
            _buildExampleTile(
              context,
              'Complex Formatting',
              'More advanced text formatting combinations',
              ComplexFormattingScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
            _buildExampleTile(
              context,
              'URL Examples',
              'Examples of URL formatting and interaction',
              UrlExampleScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
            _buildExampleTile(
              context,
              'Chat Bubble Example',
              'Example of formatting in a chat bubble',
              ChatExampleScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
            _buildExampleTile(
              context,
              'Notification Example',
              'Example of formatting in a notification',
              NotificationExampleScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
            _buildExampleTile(
              context,
              'Screenshot Generator',
              'Create custom formatted text and take screenshots',
              ScreenshotScreen(
                // Pass down theme info
                currentThemeMode: currentThemeMode,
                toggleThemeMode: toggleThemeMode,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildExampleTile(
    BuildContext context,
    String title,
    String subtitle,
    Widget destination, // Destination now already has theme info
  ) {
    return Card(
      // Use theme card settings
      // margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 6), // Reduced vertical margin
      child: ListTile(
        title: Text(title),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.arrow_forward_ios, size: 16),
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(builder: (context) => destination),
          );
        },
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/home_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/nested_formatting_screen.dart -->
import 'package:flutter/material.dart';
import 'package:textf/textf.dart';

import '../widgets/example_card.dart';

class NestedFormattingScreen extends StatelessWidget {
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const NestedFormattingScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });
  @override
  Widget build(BuildContext context) {
    // Determine the icon based on the current theme mode
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;
    return Scaffold(
      appBar: AppBar(
        title: const Text('Nested Formatting'),
        actions: [
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: toggleThemeMode,
          ),
        ],
      ),
      body: SelectionArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: const [
            ExampleCard(
              title: 'Bold with Italic',
              description: 'Bold text containing italic text (using different markers)',
              code: 'Textf(\n  \'**Bold with _italic_ inside**\',\n  \n)',
              child: Textf(
                '**Bold with _italic_ inside**',
              ),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Italic with Bold',
              description: 'Italic text containing bold text (using different markers)',
              code: 'Textf(\n  \'*Italic with __bold__ inside*\',\n  \n)',
              child: Textf(
                '*Italic with __bold__ inside*',
              ),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Bold with Code',
              description: 'Bold text containing code',
              code: 'Textf(\n  \'**Bold with `code` inside**\',\n  \n)',
              child: Textf(
                '**Bold with `code` inside**',
              ),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'Italic with Strikethrough',
              description: 'Italic text containing strikethrough text',
              code: 'Textf(\n  \'*Italic with ~~strikethrough~~ inside*\',\n  \n)',
              child: Textf(
                '*Italic with ~~strikethrough~~ inside*',
              ),
            ),
            SizedBox(height: 16),
            ExampleCard(
              title: 'What Not To Do',
              description: 'Using same marker type for nested formatting (may not work as expected)',
              code: 'Textf(\n  \'**Bold with *italic* inside**\',\n  \n)',
              child: Textf(
                '**Bold with *italic* inside**',
              ),
            ),
          ],
        ),
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/nested_formatting_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/notification_example_screen.dart -->
// example/lib/screens/notification_example_screen.dart
import 'package:flutter/material.dart';
import 'package:textf/textf.dart';

import '../widgets/example_card.dart';

class NotificationExampleScreen extends StatelessWidget {
  // Add theme constructor parameters
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const NotificationExampleScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  Widget build(BuildContext context) {
    // Add theme icon logic
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Notification Example'),
        actions: [
          // Add actions here
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: toggleThemeMode,
          ),
        ],
      ),
      body: SelectionArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            ExampleCard(
              // Use const
              title: 'Notification',
              description: 'Formatted text in a notification using default styles', // Updated desc
              code: '''
ListTile( // ... code remains the same
)''',
              child: Card(
                // Card uses theme elevation/color automatically
                child: ListTile(
                  leading: const Icon(Icons.notifications), // Icon color adapts
                  title: const Text('System Update'), // Text color adapts
                  subtitle: Textf(
                    // Textf default styles adapt
                    'Your device will restart in **5 minutes**. Save your work ~~or else~~!',
                    style: Theme.of(context).textTheme.bodyMedium, // Inherit from theme
                  ),
                ),
              ),
            ),
            const SizedBox(height: 24),
            Text(
              'More Notification Examples',
              style: Theme.of(context).textTheme.titleLarge, // Use theme style
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            // More notification examples (Semantic colors are OK)
            Card(
              // Use const if possible
              child: ListTile(
                leading: const Icon(Icons.warning_amber, color: Colors.orange),
                title: const Text('Battery Low'),
                subtitle: Textf(
                  'Your battery is at **15%**. Connect to a charger _soon_ to avoid shutdown.',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ),
            ),
            const SizedBox(height: 12),
            Card(
              // Use const
              child: ListTile(
                leading: const Icon(Icons.update, color: Colors.blue),
                title: const Text('App Update Available'),
                subtitle: Textf(
                  'Version **2.0.1** is now available with _new features_, ~~bug~~ `fixes` and a [link](https://example.com).', // Added link/code
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                trailing: const Icon(Icons.download),
              ),
            ),
            const SizedBox(height: 12),
            Card(
              // Use const
              child: ListTile(
                leading: const Icon(Icons.security, color: Colors.green),
                title: const Text('Security Alert'),
                subtitle: Textf(
                  'Your account was accessed from a **new device** in _New York_. Was this you?',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                trailing: Row(
                  // Actions are OK
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    TextButton(onPressed: () {}, child: const Text('Yes')),
                    const SizedBox(width: 8),
                    TextButton(
                      onPressed: () {},
                      style: TextButton.styleFrom(
                        foregroundColor: Theme.of(context).colorScheme.error,
                      ),
                      child: const Text('No'),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),
            // Interactive notification system
            Text(
              'Interactive Notification System',
              style: Theme.of(context).textTheme.titleLarge, // Use theme style
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            const NotificationSystem(), // Use const
          ],
        ),
      ),
    );
  }
}

class NotificationSystem extends StatefulWidget {
  const NotificationSystem({super.key});

  @override
  State<NotificationSystem> createState() => _NotificationSystemState();
}

class _NotificationSystemState extends State<NotificationSystem> {
  final List<NotificationItem> _notifications = [
    NotificationItem(
      icon: Icons.notifications,
      title: 'System Update',
      message: 'Your device will restart in **5 minutes**. Save your work ~~or else~~!',
      time: '10:45 AM',
    ),
    NotificationItem(
      icon: Icons.warning_amber,
      title: 'Battery Low',
      message: 'Your battery is at **15%**. Connect to a charger _soon_ to avoid shutdown.',
      time: '11:30 AM',
      iconColor: Colors.orange,
    ),
    NotificationItem(
      icon: Icons.update,
      title: 'App Update Available',
      message: 'Version **2.0.1** is now available with _new features_ and ~~bug~~ `fixes`.',
      time: '12:15 PM',
      iconColor: Colors.blue,
    ),
  ];

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context); // Get theme

    return Column(
      children: [
        Container(
          decoration: BoxDecoration(
            // Use theme colors
            color: theme.colorScheme.surfaceContainerLow,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: theme.colorScheme.outlineVariant.withValues(alpha: .5)),
          ),
          child: Column(
            children: [
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                decoration: BoxDecoration(
                  // Use theme color for header
                  color: theme.colorScheme.surfaceContainerHighest,
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(12),
                    topRight: Radius.circular(12),
                  ),
                ),
                child: Row(
                  children: [
                    Text(
                      'Notifications',
                      style: theme.textTheme.titleSmall, // Use theme style
                    ),
                    const Spacer(),
                    TextButton(
                      // Use TextButton for Clear All
                      onPressed: () {
                        setState(() {
                          _notifications.clear();
                        });
                      },
                      style: TextButton.styleFrom(
                        textStyle: theme.textTheme.labelMedium,
                        padding: EdgeInsets.zero,
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                      child: const Text('Clear All'),
                    ),
                  ],
                ),
              ),
              // Use Material version of Divider which adapts to theme
              const Divider(height: 1, thickness: 1),
              if (_notifications.isEmpty)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 16.0),
                  child: Text(
                    'No notifications',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                    textAlign: TextAlign.center,
                  ),
                )
              else
                ListView.separated(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: _notifications.length,
                  // Use Material Divider
                  separatorBuilder: (context, index) =>
                      const Divider(height: 1, thickness: 1, indent: 16, endIndent: 16),
                  itemBuilder: (context, index) {
                    final notification = _notifications[index];
                    return Dismissible(
                      key: ValueKey(notification.hashCode + index), // More robust key
                      background: Container(
                        color: theme.colorScheme.errorContainer, // Use theme color for background
                        alignment: Alignment.centerRight,
                        padding: const EdgeInsets.only(right: 16),
                        child: Icon(Icons.delete_outline, color: theme.colorScheme.onErrorContainer), // Use theme color
                      ),
                      direction: DismissDirection.endToStart,
                      onDismissed: (direction) {
                        setState(() {
                          _notifications.removeAt(index);
                        });
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('Notification "${notification.title}" dismissed.'),
                            duration: const Duration(seconds: 2),
                          ),
                        );
                      },
                      child: ListTile(
                        leading: Icon(
                          notification.icon,
                          color: notification.iconColor ?? theme.colorScheme.primary,
                        ), // Fallback icon color
                        title: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(notification.title),
                            Text(
                              notification.time,
                              style: theme.textTheme.bodySmall?.copyWith(
                                // Use theme style
                                color: theme.colorScheme.onSurfaceVariant,
                              ),
                            ),
                          ],
                        ),
                        subtitle: Textf(
                          notification.message,
                          style: theme.textTheme.bodyMedium, // Inherit base from theme
                        ),
                        dense: true, // Make tiles more compact
                      ),
                    );
                  },
                ),
            ],
          ),
        ),
        const SizedBox(height: 16),
        ElevatedButton.icon(
          // ElevatedButton adapts to theme
          onPressed: () {
            setState(() {
              _notifications.insert(
                // Insert at top
                0,
                NotificationItem(
                  icon: Icons.security,
                  title: 'Security Alert',
                  message: 'Your account was accessed from a **new device** in _New York_. Was this you?',
                  time: '${DateTime.now().hour}:${DateTime.now().minute.toString().padLeft(2, '0')}',
                  iconColor: Colors.green, // Keep semantic color
                ),
              );
            });
          },
          icon: const Icon(Icons.add),
          label: const Text('Add New Notification'),
        ),
      ],
    );
  }
}

// NotificationItem class remains the same
class NotificationItem {
  final IconData icon;
  final String title;
  final String message;
  final String time;
  final Color? iconColor; // Make optional

  NotificationItem({
    required this.icon,
    required this.title,
    required this.message,
    required this.time,
    this.iconColor, // Allow null
  });
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/notification_example_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/screenshot_screen.dart -->
// example/lib/screens/screenshot_screen.dart
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart'; // Import kDebugMode
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:super_clipboard/super_clipboard.dart';
import 'package:textf/textf.dart'; // Import TextfOptions

// Helper extension for cleaner null checks (optional)
extension TextStyleCopyWithExtension on TextStyle? {
  TextStyle copyWithNullable({
    bool? inherit,
    Color? color,
    Color? backgroundColor,
    double? fontSize,
    FontWeight? fontWeight,
    FontStyle? fontStyle,
    double? letterSpacing,
    double? wordSpacing,
    TextBaseline? textBaseline,
    double? height,
    Locale? locale,
    Paint? foreground,
    Paint? background,
    List<Shadow>? shadows,
    List<FontFeature>? fontFeatures,
    List<FontVariation>? fontVariations,
    TextDecoration? decoration,
    Color? decorationColor,
    TextDecorationStyle? decorationStyle,
    double? decorationThickness,
    String? debugLabel,
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    TextOverflow? overflow,
  }) {
    // If the current style is null, start with an empty TextStyle
    final currentStyle = this ?? const TextStyle();
    return currentStyle.copyWith(
      inherit: inherit,
      color: color,
      backgroundColor: backgroundColor,
      fontSize: fontSize,
      fontWeight: fontWeight,
      fontStyle: fontStyle,
      letterSpacing: letterSpacing,
      wordSpacing: wordSpacing,
      textBaseline: textBaseline,
      height: height,
      locale: locale,
      foreground: foreground,
      background: background,
      shadows: shadows,
      fontFeatures: fontFeatures,
      fontVariations: fontVariations,
      decoration: decoration,
      decorationColor: decorationColor,
      decorationStyle: decorationStyle,
      decorationThickness: decorationThickness,
      debugLabel: debugLabel,
      fontFamily: fontFamily,
      fontFamilyFallback: fontFamilyFallback,
      package: package,
      overflow: overflow,
    );
  }
}

class ScreenshotScreen extends StatefulWidget {
  // Add theme parameters
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const ScreenshotScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  State<ScreenshotScreen> createState() => _ScreenshotScreenState();
}

class _ScreenshotScreenState extends State<ScreenshotScreen> {
  final TextEditingController _textController = TextEditingController(
    text: 'Hello **bold** *italic* ~~strikethrought~~ ++underline++ ==highlight== `code` [link](https://example.com)',
  );
  final GlobalKey _screenshotKey = GlobalKey();

  // --- Base Styling State (Applied via DefaultTextStyle or Container) ---
  double _fontSize = 16;
  Color? _textColor; // Nullable: applied via DefaultTextStyle
  Color? _backgroundColor; // Nullable: applied via Container
  TextAlign _textAlign = TextAlign.left;
  double _textScaleFactor = 1.0;

  // --- TextfOptions State (Nullable to allow falling back to theme/defaults) ---
  TextStyle? _boldStyle;
  TextStyle? _italicStyle;
  TextStyle? _boldItalicStyle;
  TextStyle? _strikethroughStyle;
  TextStyle? _codeStyle;
  TextStyle? _urlStyle;
  TextStyle? _urlHoverStyle;
  MouseCursor? _urlMouseCursor;
  TextStyle? _underlineStyle;
  TextStyle? _highlightStyle;

  // --- Capture State ---
  bool _isCapturing = false;
  ui.Image? _capturedImage;
  Uint8List? _imageBytes;

  // --- Available Colors (Example lists) ---
  final List<Color> _availableColors = [
    Colors.black, Colors.white, Colors.grey.shade700, Colors.grey.shade200, // Basic
    Colors.blue.shade700, Colors.blue.shade100, // Blue tones
    Colors.red.shade700, Colors.red.shade100, // Red tones
    Colors.green.shade700, Colors.green.shade100, // Green tones
    Colors.purple.shade700, Colors.purple.shade100, // Purple tones
    Colors.orange.shade700, Colors.orange.shade100, // Orange tones
    Colors.teal.shade700, Colors.teal.shade100, // Teal tones
    Colors.yellow.shade800, Colors.yellow.shade100, // Yellow tones
  ];

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  // --- Capture/Copy/Share methods remain the same ---
  Future<void> _captureScreenshot() async {
    if (!mounted) return;
    setState(() => _isCapturing = true);

    try {
      // Short delay to ensure UI with potential TextfOptions changes is rendered
      await Future.delayed(const Duration(milliseconds: 150));

      RenderRepaintBoundary? boundary = _screenshotKey.currentContext?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        if (kDebugMode) {
          print("Error: Could not find RenderRepaintBoundary.");
        }
        throw Exception("Render boundary not found");
      }

      if (!mounted) return;
      ui.Image image = await boundary.toImage(pixelRatio: MediaQuery.of(context).devicePixelRatio);

      ByteData? byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      _imageBytes = byteData?.buffer.asUint8List();

      if (!mounted) return; // Check again after async gaps
      setState(() {
        _capturedImage = image;
        _isCapturing = false;
      });

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Screenshot captured! Long-press image to copy/share.'),
          duration: Duration(seconds: 3),
        ),
      );
    } catch (e) {
      if (kDebugMode) {
        print("Screenshot capture failed: $e");
      }
      if (!mounted) return;
      setState(() => _isCapturing = false);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to capture screenshot: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  Future<void> _copyImageToClipboard() async {
    if (_imageBytes == null) return;
    try {
      final clipboard = SystemClipboard.instance;
      if (clipboard == null) {
        throw Exception("Clipboard instance is not available.");
      }
      final item = DataWriterItem();
      item.add(Formats.png(_imageBytes!));
      await clipboard.write([item]);

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Image copied to clipboard'),
          duration: Duration(seconds: 2),
        ),
      );
    } catch (e) {
      if (kDebugMode) {
        print("Copy image failed: $e");
      }
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to copy image: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  Future<void> _showImageOptions() async {
    if (_imageBytes == null) return;

    showModalBottomSheet(
      context: context,
      builder: (context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.copy),
                title: const Text('Copy to Clipboard'),
                onTap: () {
                  Navigator.pop(context);
                  _copyImageToClipboard();
                },
              ),
              ListTile(
                leading: const Icon(Icons.share),
                title: const Text('Share Image'),
                onTap: () {
                  Navigator.pop(context);
                  _shareImage(); // Call share method
                },
              ),
            ],
          ),
        );
      },
    );
  }

  // Add a basic share method (requires share_plus)
  Future<void> _shareImage() async {
    if (_imageBytes == null) return;
    // Placeholder if share_plus is not added
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Share functionality requires the share_plus package (see example pubspec).'),
      ),
    );
  }
  // --- End Capture/Copy/Share methods ---

  @override
  Widget build(BuildContext context) {
    // Theme setup for AppBar icon
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;
    final theme = Theme.of(context); // Get theme for defaults

    // Determine the effective background color for the preview Container
    final Color effectiveBackgroundColor = _backgroundColor ?? theme.colorScheme.surface;

    // --- Build Method ---
    return Scaffold(
      appBar: AppBar(
        title: const Text('Screenshot Generator'),
        actions: [
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: widget.toggleThemeMode, // Use widget callback
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // --- Text Input ---
            const Text(
              'Enter formatted text:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: _textController,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                hintText: 'Enter text with **bold**, *italic*, `code`, '
                    '++underline++, ==highlight==, [link](url)...',
                helperText: 'Supports **bold**, *italic*, ~~strike~~, `code`, '
                    '++underline++, ==highlight==, [link](url)',
                isDense: true,
              ),
              maxLines: 3,
              onChanged: (value) {
                setState(() {}); // Rebuild preview on text change
              },
            ),
            const SizedBox(height: 16),

            // --- Formatting Options Expansion Tile ---
            ExpansionTile(
              title: const Text('Formatting Options'),
              initiallyExpanded: false,
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 8.0), // Reduced horizontal padding
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // --- Base Styling Section ---
                      _buildSectionHeader('Base Styling'),
                      _buildFontSizeSlider(),
                      _buildTextScalerSlider(),
                      _buildTextAlignSelector(),
                      _buildColorPickerRow(
                        label: 'Base Text Color:',
                        selectedColor: _textColor, // Use nullable state
                        onColorSelected: (color) => setState(() => _textColor = color),
                        onReset: () => setState(() => _textColor = null), // Reset to null
                      ),
                      _buildColorPickerRow(
                        label: 'Background Color:',
                        selectedColor: _backgroundColor, // Use nullable state
                        onColorSelected: (color) => setState(() => _backgroundColor = color),
                        onReset: () => setState(() => _backgroundColor = null), // Reset to null
                      ),
                      const Divider(height: 20),

                      // URL Mouse Cursor Override
                      _buildMouseCursorSelector(),
                    ],
                  ),
                ),
              ],
            ), // End ExpansionTile

            const SizedBox(height: 24),

            // --- Preview Section ---
            const Text(
              'Preview:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),

            // --- Refactored Preview Structure ---
            Center(
              // Ensure the RepaintBoundary captures the final composed widget
              child: RepaintBoundary(
                key: _screenshotKey,
                child: SizedBox(
                  width: double.infinity,
                  child: Card(
                    // Use theme card styling
                    clipBehavior: Clip.antiAlias, // Ensure container color respects border radius
                    // Apply background color here, falling back to theme surface
                    color: effectiveBackgroundColor,
                    child: Padding(
                      padding: const EdgeInsets.all(16.0), // Padding inside the card
                      // Apply base font size, alignment, and optional text color here
                      child: DefaultTextStyle.merge(
                        style: TextStyle(
                          fontSize: _fontSize,
                          color: _textColor, // If null, DefaultTextStyle inherits from theme
                        ),
                        child: TextfOptions(
                          // Pass the nullable option styles
                          boldStyle: _boldStyle,
                          italicStyle: _italicStyle,
                          boldItalicStyle: _boldItalicStyle,
                          strikethroughStyle: _strikethroughStyle,
                          codeStyle: _codeStyle,
                          urlStyle: _urlStyle,
                          urlHoverStyle: _urlHoverStyle,
                          urlMouseCursor: _urlMouseCursor,
                          underlineStyle: _underlineStyle,
                          highlightStyle: _highlightStyle,
                          // Important: Textf widget *without* the explicit style parameter
                          child: Textf(
                            _textController.text,
                            textAlign: _textAlign,
                            textScaler: TextScaler.linear(_textScaleFactor),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
            // --- End Refactored Preview Structure ---

            const SizedBox(height: 24),
            // --- Capture Button ---
            Center(
              child: ElevatedButton.icon(
                onPressed: _isCapturing ? null : _captureScreenshot,
                icon: const Icon(Icons.camera_alt_outlined),
                label: Text(_isCapturing ? 'Capturing...' : 'Capture Screenshot'),
              ),
            ),

            // --- Captured Image Display (remains the same) ---
            if (_capturedImage != null) ...[
              const SizedBox(height: 24),
              const Divider(),
              const SizedBox(height: 8),
              const Text(
                'Captured Screenshot:',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Center(
                child: Card(
                  elevation: 4,
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Column(
                      mainAxisSize: MainAxisSize.min, // Prevent excessive height
                      children: [
                        GestureDetector(
                          onLongPress: _showImageOptions,
                          child: ConstrainedBox(
                            constraints: BoxConstraints(
                              maxWidth: MediaQuery.of(context).size.width * 0.8, // Limit width
                              maxHeight: MediaQuery.of(context).size.height * 0.4, // Limit height
                            ),
                            child: RawImage(
                              image: _capturedImage,
                              fit: BoxFit.contain, // Use contain to see the whole image
                            ),
                          ),
                        ),
                        const SizedBox(height: 8),
                        const Text(
                          'Long-press image to copy/share',
                          style: TextStyle(fontSize: 12, color: Colors.grey),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  // --- Helper Widgets for Options UI ---

  // Builds a header for a section in the options
  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
      child: Text(title, style: Theme.of(context).textTheme.titleSmall),
    );
  }

  // Builds the Font Size Slider
  Widget _buildFontSizeSlider() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Font Size: ${_fontSize.round()}'),
          Slider(
            value: _fontSize,
            min: 12,
            max: 32,
            divisions: 20,
            label: _fontSize.round().toString(),
            onChanged: (value) {
              setState(() => _fontSize = value);
            },
          ),
        ],
      ),
    );
  }

  // Builds the Text Scale Factor Slider
  Widget _buildTextScalerSlider() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Text Scale Factor: ${_textScaleFactor.toStringAsFixed(1)}x'),
          Slider(
            value: _textScaleFactor,
            min: 0.5, // Minimaler Skalierungsfaktor
            max: 2.5, // Maximaler Skalierungsfaktor
            divisions: 20, // Anzahl der Schritte
            label: _textScaleFactor.toStringAsFixed(1),
            onChanged: (value) {
              setState(() => _textScaleFactor = value);
            },
          ),
        ],
      ),
    );
  }

  // Builds the Text Alignment Selector
  Widget _buildTextAlignSelector() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Text Alignment:'),
          const SizedBox(height: 4),
          SizedBox(
            width: double.infinity, // Make segmented button take full width
            child: SegmentedButton<TextAlign>(
              segments: const [
                ButtonSegment(value: TextAlign.left, icon: Icon(Icons.align_horizontal_left), label: Text('Left')),
                ButtonSegment(
                  value: TextAlign.center,
                  icon: Icon(Icons.align_horizontal_center),
                  label: Text('Center'),
                ),
                ButtonSegment(value: TextAlign.right, icon: Icon(Icons.align_horizontal_right), label: Text('Right')),
              ],
              selected: {_textAlign},
              onSelectionChanged: (Set<TextAlign> selection) {
                setState(() => _textAlign = selection.first);
              },
            ),
          ),
        ],
      ),
    );
  }

  // Builds a row for picking a color with a reset button
  Widget _buildColorPickerRow({
    required String label,
    required Color? selectedColor,
    required ValueChanged<Color?> onColorSelected,
    required VoidCallback onReset,
    String resetButtonLabel = 'Use Theme/Default',
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Text(label),
              const Spacer(),
              TextButton(
                style: TextButton.styleFrom(padding: EdgeInsets.zero, visualDensity: VisualDensity.compact),
                onPressed: onReset,
                child: Text(resetButtonLabel),
              ),
            ],
          ),
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: _availableColors.map((color) {
                final bool isSelected = selectedColor == color;
                return Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 4.0),
                  child: InkWell(
                    onTap: () => onColorSelected(color),
                    customBorder: const CircleBorder(),
                    child: Container(
                      width: 28,
                      height: 28,
                      decoration: BoxDecoration(
                        color: color,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: isSelected ? Colors.blueAccent : Colors.grey.shade400,
                          width: isSelected ? 3 : 1,
                        ),
                        boxShadow: isSelected
                            ? [
                                BoxShadow(
                                  color: Colors.blueAccent.withValues(alpha: .5),
                                  blurRadius: 3,
                                  spreadRadius: 1,
                                ),
                              ]
                            : null,
                      ),
                      child: (color == Colors.white || color.computeLuminance() > 0.8) && isSelected
                          ? const Icon(Icons.check, color: Colors.black54, size: 16)
                          : isSelected
                              ? const Icon(Icons.check, color: Colors.white70, size: 16)
                              : null,
                    ),
                  ),
                );
              }).toList(),
            ),
          ),
        ],
      ),
    );
  }

  // Builds the Mouse Cursor Selector
  Widget _buildMouseCursorSelector() {
    final availableCursors = {
      'Default': null, // Represents resetting to Textf default
      'Basic': SystemMouseCursors.basic,
      'Click': SystemMouseCursors.click,
      'Text': SystemMouseCursors.text,
      'Forbidden': SystemMouseCursors.forbidden,
    };

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('URL Mouse Cursor Override:'),
          const SizedBox(height: 4),
          DropdownButton<MouseCursor?>(
            value: _urlMouseCursor, // Current state
            isExpanded: true,
            items: availableCursors.entries.map((entry) {
              return DropdownMenuItem<MouseCursor?>(
                value: entry.value,
                child: Text(entry.key),
              );
            }).toList(),
            onChanged: (newValue) {
              setState(() => _urlMouseCursor = newValue);
            },
            // Display 'Default' when state is null
            hint: _urlMouseCursor == null ? const Text('Default (from Textf)') : null,
          ),
        ],
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/screenshot_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/theme_example_screen.dart -->
// example/lib/screens/theme_example_screen.dart
import 'package:flutter/material.dart';
import 'package:textf/textf.dart';

import '../widgets/example_card.dart';

class ThemeExampleScreen extends StatelessWidget {
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const ThemeExampleScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  Widget build(BuildContext context) {
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;
    final String themeName = currentBrightness == Brightness.dark ? "Dark" : "Light";

    return Scaffold(
      appBar: AppBar(
        title: const Text('Theme Awareness'),
        actions: [
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: toggleThemeMode,
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 16.0),
            child: Text(
              'Textf automatically adapts the default styling for links and inline code to the current application theme ($themeName Theme). Use the toggle button in the AppBar to see the changes.',
              style: Theme.of(context).textTheme.bodyLarge,
              textAlign: TextAlign.center,
            ),
          ),
          const Divider(height: 20),
          ExampleCard(
            title: 'Default Link Styling',
            description: 'Links ([text](url)) use the theme\'s primary color by default.',
            code: '''
Textf(
  'Visit the [Flutter website](https://flutter.dev) '
  'or the [Dart website](https://dart.dev).'
)
            ''',
            child: Textf(
              'Visit the [Flutter website](https://flutter.dev) or the [Dart website](https://dart.dev).',
              // Use a slightly larger font size for better visibility
              style: Theme.of(context).textTheme.bodyLarge,
            ),
          ),
          const SizedBox(height: 16),
          ExampleCard(
            title: 'Default Code Styling',
            description: 'Inline code (`code`) uses theme-appropriate background and text colors.',
            code: '''
Textf(
  'Check the `pubspec.yaml` and the `main.dart` files.'
)
            ''',
            child: Textf(
              'Check the `pubspec.yaml` and the `main.dart` files.',
              // Use a slightly larger font size for better visibility
              style: Theme.of(context).textTheme.bodyLarge,
            ),
          ),
          const SizedBox(height: 16),
          ExampleCard(
            title: 'Mixed Default Styles',
            description: 'Combine default link and code styles within regular text.',
            code: '''
Textf(
  'Refer to `TextfStyleResolver` in the [source code](https://github.com/PhilippHGerber/textf).'
)
            ''',
            child: Textf(
              'Refer to `TextfStyleResolver` in the [source code](https://github.com/PhilippHGerber/textf).',
              // Use a slightly larger font size for better visibility
              style: Theme.of(context).textTheme.bodyLarge,
            ),
          ),
        ],
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/theme_example_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/screens/url_example_screen.dart -->
// example/lib/screens/url_example_screen.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:textf/textf.dart';
import 'package:url_launcher/url_launcher.dart' as url_launcher;

import '../widgets/example_card.dart';

class UrlExampleScreen extends StatefulWidget {
  final ThemeMode currentThemeMode;
  final VoidCallback toggleThemeMode;

  const UrlExampleScreen({
    super.key,
    required this.currentThemeMode,
    required this.toggleThemeMode,
  });

  @override
  State<UrlExampleScreen> createState() => _UrlExampleScreenState();
}

class _UrlExampleScreenState extends State<UrlExampleScreen> {
  String _hoveredUrl = '';
  bool _isHovering = false;
  OverlayEntry? _overlayEntry;

  @override
  void dispose() {
    _removeOverlay();
    super.dispose();
  }

  void _handleUrlTap(String url, String rawDisplayText) {
    if (!mounted) return;
    _removeOverlay(); // Remove overlay BEFORE showing Snackbar

    ScaffoldMessenger.of(context).removeCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.link, color: Colors.white70, size: 18),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Link Tapped: $rawDisplayText',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 14,
                      color: Colors.white.withValues(alpha: 0.9),
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 2),
                  Text(
                    url,
                    style: const TextStyle(fontSize: 13, color: Colors.white70),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                ],
              ),
            ),
          ],
        ),
        backgroundColor: Colors.black87,
        duration: const Duration(seconds: 4),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        margin: const EdgeInsets.fromLTRB(12, 12, 12, 12),
        action: SnackBarAction(
          label: 'OPEN',
          textColor: Colors.lightBlueAccent,
          onPressed: () => _launchUrl(url),
        ),
      ),
    );
    // _launchUrl(url); // Optional auto-launch
  }

  void _handleUrlHover(String url, String rawDisplayText, {required bool isHovering}) {
    if (!mounted) return;
    // Optimization: Only update state/overlay if hover status or URL changes,
    // or if we are definitely starting to hover over a valid URL.
    if (isHovering != _isHovering || (isHovering && url != _hoveredUrl)) {
      setState(() {
        _hoveredUrl = isHovering ? url : '';
        _isHovering = isHovering;
      });

      if (isHovering && url.isNotEmpty) {
        _showUrlOverlay(url);
      } else {
        _removeOverlay();
      }
    } else if (!isHovering && _overlayEntry != null) {
      // Ensure overlay is removed if hover stops
      _removeOverlay();
    }
  }

  void _showUrlOverlay(String url) {
    _removeOverlay();

    _overlayEntry = OverlayEntry(
      builder: (context) => Positioned(
        bottom: 0,
        left: 0,
        right: 0,
        child: IgnorePointer(
          // Wrap with Material for context
          child: Material(
            type: MaterialType.transparency, // Don't draw Material background
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 5),
              // Use theme colors for better adaptation
              color: Theme.of(context)
                  . //
                  colorScheme
                  .surfaceContainerHighest
                  .withValues(
                    alpha: 0.95,
                  ),
              child: Text(
                url,
                style: TextStyle(
                  color: Theme.of(context) //
                      .colorScheme
                      .onSurfaceVariant,
                  fontSize: 12,
                  decoration: TextDecoration.none, // Prevent underline here
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ),
        ),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  void _removeOverlay() {
    if (_overlayEntry != null) {
      try {
        _overlayEntry?.remove();
      } catch (e) {
        // Might throw if called after dispose or during tree modifications, ignore.
        // print("Error removing overlay: $e");
      } finally {
        _overlayEntry = null;
        // If we are removing the overlay, reset the hover state too
        if (_isHovering && mounted) {
          setState(() {
            _isHovering = false;
            _hoveredUrl = '';
          });
        }
      }
    }
  }

  Future<void> _launchUrl(String url) async {
    // ... (launch URL logic remains the same)
    if (!mounted) return;

    final Uri uri = Uri.parse(url);
    final messenger = ScaffoldMessenger.of(context);

    try {
      final bool canLaunch = await url_launcher.canLaunchUrl(uri);
      if (!mounted) return; // Check mount status after async gap

      if (canLaunch) {
        final bool launched = await url_launcher.launchUrl(uri);
        if (!mounted) return;

        if (!launched) {
          // Handle case where launchUrl returns false despite canLaunchUrl being true
          messenger.showSnackBar(
            _buildUrlSnackBar('Could not open $url', Icons.warning_amber, Colors.orange.shade700),
          );
        }
      } else {
        messenger.showSnackBar(
          _buildUrlSnackBar('Cannot open URL: $url', Icons.error_outline, Colors.red.shade700),
        );
      }
    } catch (e) {
      if (!mounted) return;
      messenger.showSnackBar(
        _buildUrlSnackBar('Error opening URL: $e', Icons.error_outline, Colors.red.shade700),
      );
    }
  }

  SnackBar _buildUrlSnackBar(String message, IconData icon, Color backgroundColor) {
    // ... (SnackBar builder remains the same)
    return SnackBar(
      content: Row(
        children: [
          Icon(icon, color: Colors.white70),
          const SizedBox(width: 12),
          Expanded(child: Text(message)),
        ],
      ),
      backgroundColor: backgroundColor,
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      margin: const EdgeInsets.all(12),
      duration: const Duration(seconds: 3),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Determine the icon based on the current theme mode
    final Brightness currentBrightness = Theme.of(context).brightness;
    final IconData themeIcon =
        currentBrightness == Brightness.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined;
    return Scaffold(
      appBar: AppBar(
        title: const Text('URL Examples'),
        actions: [
          IconButton(
            icon: Icon(themeIcon),
            tooltip: 'Toggle Theme',
            onPressed: widget.toggleThemeMode,
          ),
        ],
      ),
      body: TextfOptions(
        // Parent options provide callbacks
        onUrlTap: _handleUrlTap,
        onUrlHover: _handleUrlHover,
        urlStyle: TextStyle(
          color: Colors.blue,
          decoration: TextDecoration.none,
        ),
        urlHoverStyle: TextStyle(
          color: Colors.blue,
          decoration: TextDecoration.underline,
          decorationColor: Colors.blue,
        ),
        urlMouseCursor: SystemMouseCursors.click,
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // Use standard list constructor
            // --- Basic URL Example ---
            const ExampleCard(
              title: 'Basic URL',
              description: 'Simple URL using default styling from TextfOptions',
              code: '''
Textf(
  'Visit [Flutter website](https://flutter.dev) '
  'for more information,
)''',
              child: Textf(
                'Visit [Flutter website](https://flutter.dev) for more information',
              ),
            ),
            const SizedBox(height: 16),

            // --- URL with Hover Effect Example ---
            const ExampleCard(
              title: 'URL with Hover Effect',
              description: 'Demonstrates URL hover interaction (hover to see URL at bottom)',
              code: '''
TextfOptions(
  urlStyle: TextStyle(
    color: Colors.blue,
    fontWeight: FontWeight.bold,
    decoration: TextDecoration.none,
  ),
  urlHoverStyle: TextStyle(
    color: Colors.blue,
    decoration: TextDecoration.underline,
    decorationColor: Colors.blue,
  ),
  child: Textf(
    'Hover over [this link](https://example.com) '
    'to see the effect',

  ),
)
''',
              child: TextfOptions(
                urlStyle: TextStyle(
                  color: Colors.blue,
                  decoration: TextDecoration.none,
                ),
                urlHoverStyle: TextStyle(
                  color: Colors.blue,
                  decoration: TextDecoration.underline,
                  decorationColor: Colors.blue,
                ),
                child: Textf(
                  'Hover over [this link](https://example.com) '
                  'to see the effect',
                ),
              ),
            ),
            const SizedBox(height: 16),

            // --- Multiple URLs Example ---
            const ExampleCard(
              title: 'Multiple URLs',
              description: 'Multiple URLs in a single text block',
              code: '''
Textf(
  'Visit [Flutter](https://flutter.dev) '
  'or [Dart](https://dart.dev) websites,
)''',
              child: Textf(
                'Visit [Flutter](https://flutter.dev) or [Dart](https://dart.dev) websites',
              ),
            ),
            const SizedBox(height: 16),

            // --- Formatted URL Text Example ---
            const ExampleCard(
              // THIS SHOULD NOW WORK FOR CLICK TOO
              title: 'Formatted URL Text',
              description: 'URL display text with other formatting applied',
              code: '''
Textf(
  'Check out [**bold link**](https://example.com) '
  'and [*italic link*](https://example.org)',
)''',
              child: Textf(
                'Check out [**bold link**](https://example.com) and [*italic link*](https://example.org)',
              ),
            ),
            const SizedBox(height: 16),

            // --- Nested Formatting Example ---
            const ExampleCard(
              // THIS SHOULD NOW WORK FOR CLICK TOO
              title: 'Nested Formatting in URL Text',
              description: 'URL display text with nested formatting (bold > italic)',
              code: '''
Textf(
  'Link with [**nested _italic_ style**](https://example.net)',
)''',
              child: Textf(
                'Link with [**nested _italic_ style**](https://example.net)',
              ),
            ),
            const SizedBox(height: 16),

            // --- Email URL Example ---
            const ExampleCard(
              title: 'Email URL',
              description: 'URL with mailto: protocol',
              code: '''
Textf(
  'Contact [support](mailto:support@example.com) '
  'for assistance',
)''',
              child: Textf(
                'Contact [support](mailto:support@example.com) for assistance',
              ),
            ),
            const SizedBox(height: 16),

            // --- Special Characters Example ---
            const ExampleCard(
              title: 'URL with Special Characters',
              description: 'URL containing query parameters and fragments',
              code: '''
Textf(
  'Search for [Package Textf]'
  '(https://pub.dev/packages?q=textf+markdown#results)',
)''',
              child: Textf(
                'Search for [Package Textf]'
                '(https://pub.dev/packages?q=textf+markdown#results)',
              ),
            ),
            const SizedBox(height: 16),

            // --- Normalization Example ---
            const ExampleCard(
              title: 'URL Needing Normalization',
              description: 'URL without protocol (should get http:// added)',
              code: 'Textf(\n  \'Visit [Google](google.com)\',\n)',
              child: Textf(
                'Visit [Google](google.com)',
              ),
            ),
            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/screens/url_example_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_core/lib/widgets/example_card.dart -->
// example/lib/widgets/example_card.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class ExampleCard extends StatelessWidget {
  final String title;
  final String description;
  final String code;
  final Widget child;

  const ExampleCard({
    super.key,
    required this.title,
    required this.description,
    required this.code,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context); // Get theme
    final codeStyleBase = theme.textTheme.bodyMedium?.copyWith(
          // Use bodyMedium as base for code
          fontFamily: 'RobotoMono',
          fontFamilyFallback: ['Menlo', 'Courier New', 'monospace'],
          fontSize: 12,
        ) ??
        const TextStyle(
          // Fallback if bodyMedium is null
          fontFamily: 'RobotoMono',
          fontFamilyFallback: ['Menlo', 'Courier New', 'monospace'],
          fontSize: 12,
        );

    return Card(
      // Use default Card theme for elevation/shape
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: theme.textTheme.titleLarge, // Use theme style
            ),
            const SizedBox(height: 8),
            Text(
              description,
              style: theme.textTheme.bodyMedium, // Use theme style
            ),
            const SizedBox(height: 16),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start, // Align top
              children: [
                Expanded(
                  child: Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      // Use theme color for code background
                      color: theme.colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      code.trim(), // Trim code block whitespace
                      // Apply base code style, color will come from theme
                      style: codeStyleBase.copyWith(
                        color: theme.colorScheme.onSurfaceVariant, // Explicit text color
                      ),
                    ),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.only(left: 4.0, top: 4.0), // Adjust padding
                  child: IconButton(
                    icon: const Icon(Icons.copy_outlined, size: 18), // Slightly smaller icon
                    tooltip: 'Copy code',
                    onPressed: () {
                      Clipboard.setData(ClipboardData(text: code));
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Code copied to clipboard'),
                          duration: Duration(seconds: 1),
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            // Result container
            Container(
              width: double.infinity, // Ensure it takes full width
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                // Use a slightly different theme color for result background
                color: theme.colorScheme.surfaceContainer,
                borderRadius: BorderRadius.circular(8),
                // Optional: Add a subtle border
                border: Border.all(
                  color: theme.colorScheme.outlineVariant.withValues(alpha: 0.5),
                  width: 1,
                ),
              ),
              // Apply default text style from theme to the child content
              child: DefaultTextStyle.merge(
                style: theme.textTheme.bodyMedium ?? const TextStyle(),
                child: child,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_core/lib/widgets/example_card.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_flex/README.md -->
# Textf + FlexColorScheme Example App

This example application demonstrates the integration of the `textf` widget with the popular `flex_color_scheme` package, showcasing how `textf`'s theme-aware features adapt to dynamically changing application themes.

## Purpose

* Showcase how `textf` automatically styles links and code blocks based on the active `ThemeData`.
* Demonstrate dynamic theme switching using various `FlexColorScheme` schemes.
* Provide visual examples of different `textf` formatting options within themed cards.
* Illustrate how `TextfOptions` can be used to override theme-based default styles.
* Show various standard Flutter UI elements adapting to the selected theme alongside `textf`.

## Features Demonstrated

* **Dynamic Theme Selection:** Choose from all available `FlexColorScheme` schemes via a dropdown in the AppBar.
* **Theme Mode Switching:** Toggle between Light, Dark, and System theme modes.
* **`textf` Theme Adaptation:** Observe how the default appearance of `[links](url)` (using `colorScheme.primary`) and `` `code` `` (using theme-appropriate background/text colors) changes with the theme.
* **Basic `textf` Formatting:** Examples of **bold**, *italic*, ~~strikethrough~~.
* **`TextfOptions` Overrides:** Examples showing how to customize specific styles (like link color or strikethrough thickness) using `TextfOptions`, taking precedence over the theme defaults.
* **UI Element Theming:** A dedicated card shows various Flutter widgets (Buttons, Chips, Slider, TextField, etc.) adopting the colors from the currently selected `FlexColorScheme` theme.

## Getting Started

1. **Navigate to the example directory:**

    ```bash
    cd example/textf_flex
    ```

2. **Ensure Full Project Structure:**
    Run the following command within the `textf_flex` directory. This ensures all necessary platform-specific directories (`android`, `ios`, `web`, etc.) and files are present, even if they were missing (e.g., after cloning). It will *not* overwrite your existing code in `lib/` or your `pubspec.yaml`.

    ```bash
    flutter create .
    ```

3. **Ensure Dependencies are Installed:**
    Make sure you have the necessary dependencies listed in `pubspec.yaml`, especially `flex_color_scheme` and the local path dependency for `textf`:

    ```yaml
    # example/textf_flex_example/pubspec.yaml
    dependencies:
      flutter:
        sdk: flutter
      flex_color_scheme: ^7.3.1 # Or latest
      textf:
        path: ../../ # Path to the main textf package
    ```

    Then, fetch the packages:

    ```bash
    flutter pub get
    ```

4. **Run the app:**

    ```bash
    flutter run
    ```

## How it Works

* **`main.dart`**: Manages the application's theme state (`selectedScheme`, `themeMode`). It uses `FlexThemeData.light()` and `FlexThemeData.dark()` to generate the `ThemeData` based on the selected scheme and passes the state and update callbacks down to the `HomeScreen`.
* **`home_screen.dart`**: Displays the main UI.
  * The `AppBar` contains the `DropdownButton` for selecting the `FlexScheme` and an `IconButton` to toggle the `ThemeMode`.
  * The body displays a `ListView` of `Card`s.
  * The `_buildExampleCard` helper function creates each card. Crucially, the `Textf` widgets within these cards are instantiated *without* an explicit `style` property, allowing them to inherit the base text style from the `DefaultTextStyle` provided by the theme. This enables the automatic theme adaptation for links and code.
  * Specific examples demonstrate wrapping `Textf` with `TextfOptions` to show how overrides work.

This setup clearly shows how `textf` integrates with Flutter's theming system, especially when using powerful theming packages like `FlexColorScheme`.

<!-- END FILE: [v0.6.1] example/textf_flex/README.md -->

<!-- BEGIN FILE: [v0.6.1] example/textf_flex/pubspec.yaml -->
name: textf_flex
description: A new Flutter project to showcase Textf library with flex_color_scheme
publish_to: "none"
version: 0.1.0

environment:
  sdk: ">=3.0.0 <4.0.0"
  flutter: ">=3.0.0"

dependencies:
  flex_color_scheme: ^8.2.0
  flutter:
    sdk: flutter
  textf: ^0.6.1

# dependency_overrides:
#   textf:
#     path: ../../

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0

flutter:
  uses-material-design: true

  assets:
    - assets/fonts/

  fonts:
    - family: RobotoMono
      fonts:
        - asset: assets/fonts/RobotoMono-VariableFont_wght.ttf
        - asset: assets/fonts/RobotoMono-Italic-VariableFont_wght.ttf
          style: italic

<!-- END FILE: [v0.6.1] example/textf_flex/pubspec.yaml -->

<!-- BEGIN FILE: [v0.6.1] example/textf_flex/analysis_options.yaml -->
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

analyzer:
linter:
  rules:
    require_trailing_commas: true
    prefer_relative_imports: true
formatter:
  page_width: 120

<!-- END FILE: [v0.6.1] example/textf_flex/analysis_options.yaml -->

<!-- BEGIN FILE: [v0.6.1] example/textf_flex/lib/home_screen.dart -->
import 'package:flex_color_scheme/flex_color_scheme.dart';
import 'package:flutter/material.dart';
import 'package:textf/textf.dart'; // Import your textf package

class HomeScreen extends StatelessWidget {
  final FlexScheme selectedScheme;
  final ThemeMode themeMode;
  final ValueChanged<FlexScheme?> onSchemeChanged;
  final VoidCallback onThemeModeChanged;

  const HomeScreen({
    super.key,
    required this.selectedScheme,
    required this.themeMode,
    required this.onSchemeChanged,
    required this.onThemeModeChanged,
  });

  // --- Helper Methods ---

  // Helper to build the example cards
  Widget _buildExampleCard({
    required BuildContext context,
    required String title,
    Widget? description,
    String? code,
    Widget? cardContent,
    Widget? textf,
  }) {
    final theme = Theme.of(context);
    Widget displayContent;
    if (cardContent != null) {
      displayContent = cardContent;
    } else if (textf != null) {
      displayContent = DefaultTextStyle.merge(
        style: theme.textTheme.bodyMedium ?? const TextStyle(),
        child: textf,
      );
    } else {
      displayContent = const Text('No content provided.');
    }

    return Card(
      margin: const EdgeInsets.only(bottom: 16.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(title, style: theme.textTheme.titleLarge),
            const SizedBox(height: 8.0),
            if (description != null) ...[
              description,
              const SizedBox(height: 8.0),
            ],
            if (code != null)
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  // Use theme color for code background
                  color: theme.colorScheme.surfaceContainer,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: TextfOptions(
                  italicStyle: TextStyle(
                    fontFamily: 'RobotoMono',
                    color: theme.colorScheme.onPrimary,
                    backgroundColor: theme.colorScheme.primary.withValues(alpha: 0.5),
                  ),
                  child: Textf(
                    "`$code`",
                  ),
                ),
              ),
            const SizedBox(height: 16.0),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12.0),
              decoration: BoxDecoration(
                color: theme.colorScheme.surfaceContainerLowest,
                borderRadius: BorderRadius.circular(8.0),
              ),
              child: displayContent,
            ),
          ],
        ),
      ),
    );
  }

  // Helper function to capitalize the first letter of a string
  String _capitalize(String text) {
    if (text.isEmpty) return text;
    return '${text[0].toUpperCase()}${text.substring(1)}';
  }

  String _formatSchemeName(FlexScheme scheme) {
    final rawName = scheme.name;

    // Handle specific cases first
    if (rawName == 'blackWhite') return 'Black white';

    // Handle M3 suffix
    if (rawName.endsWith('M3')) {
      // Get the part before M3, replace underscores, capitalize first letter
      final prefix = rawName.substring(0, rawName.length - 2);
      final spacedPrefix = prefix.replaceAll('_', ' ');
      return '${_capitalize(spacedPrefix)} M3';
    } else {
      // General case: replace underscores, capitalize first letter
      final spacedName = rawName.replaceAll('_', ' ');
      return _capitalize(spacedName);
    }
  }
  // --- End Helper Methods ---

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Determine the icon and tooltip for the ThemeMode toggle button
    final IconData modeIcon;
    final String modeTooltip;
    switch (themeMode) {
      case ThemeMode.light:
        modeIcon = Icons.dark_mode_outlined;
        modeTooltip = 'Switch to Dark Mode';
        break;
      case ThemeMode.dark:
        modeIcon = Icons.light_mode_outlined;
        modeTooltip = 'Switch to System Mode';
        break;
      case ThemeMode.system:
        modeIcon = Icons.brightness_auto_outlined;
        modeTooltip = 'Switch to Light Mode';
        break;
    }

    final colorScheme = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(
        title: TextfOptions(
          boldStyle: TextStyle(
            color: colorScheme.primary,
            fontWeight: FontWeight.bold,
          ),
          italicStyle: TextStyle(
            color: colorScheme.onSurface,
            fontWeight: FontWeight.bold,
          ),
          child: Textf(
            '_Textf_ with FlexColorScheme **${_formatSchemeName(selectedScheme)}**',
          ),
        ),
        actions: [
          IconButton(
            icon: Icon(modeIcon),
            tooltip: modeTooltip,
            onPressed: onThemeModeChanged,
          ),
          const SizedBox(width: 8),
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: DropdownButton<FlexScheme>(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              value: selectedScheme,
              underline: const SizedBox.shrink(),
              style: theme.appBarTheme.titleTextStyle ?? theme.textTheme.titleMedium,
              iconEnabledColor: theme.appBarTheme.iconTheme?.color,
              items: FlexScheme.values
                  .map(
                    (scheme) => DropdownMenuItem<FlexScheme>(
                      value: scheme,
                      child: Text(
                        _formatSchemeName(scheme),
                        style: theme.textTheme.bodyMedium,
                      ),
                    ),
                  )
                  .toList(),
              onChanged: onSchemeChanged,
            ),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 16.0),
        children: [
          // --- Example Cards ---
          _buildExampleCard(
            context: context,
            title: 'Basic Formatting',
            description: Textf(
              '**No boilerplate. No TextSpan pain. Just** `Textf`.\n'
              'Easily apply bold, italic, strikethrough, and inline code styles using a clean, Markdown-like syntax.',
            ),
            code: 'Textf(\'This is \\*\\*bold**, \\*italic*, \\~~strikethrough~~, \\`inline code\\`\')',
            textf: Textf('This is **bold**, *italic*, ~~strikethrough~~, `inline code`'),
          ),
          _buildExampleCard(
            context: context,
            title: 'Links',
            description: Textf(
              '**Themed links out of the box.**\n'
              'Textf automatically styles links to match your app‚Äôs theme ‚Äî no extra setup needed.',
            ),
            code: "Textf(\n"
                "  'Visit the \\[Flutter Website](https://flutter.dev) '\n"
                "  'or \\[DartPad](https://dartpad.dev)',\n"
                ")",
            textf: Textf(
              'Visit the [Flutter Website](https://flutter.dev) '
              'or [DartPad](https://dartpad.dev)',
            ),
          ),
          _buildExampleCard(
            context: context,
            title: 'Override Link Style',
            description: Textf(
              '**Customize everything.**\n'
              'Freely override link styles, hover effects, and tap behavior using `TextfOptions`.',
            ),
            code: "TextfOptions(\n"
                "  _urlStyle_: TextStyle(\n"
                "    _color: colorScheme.secondary_,\n"
                "    fontWeight: FontWeight.bold,\n"
                "  ),\n"
                "  _urlHoverStyle_: TextStyle(\n"
                "    _decoration: TextDecoration.underline_,\n"
                "    decorationColor: colorScheme.secondary,\n"
                "  ),\n"
                "  child: _Textf_(\n"
                "    'This [link looks different]'\n"
                "    '(https://docs.flexcolorscheme.com/).',\n"
                "  ),\n"
                ")",
            textf: TextfOptions(
              urlStyle: TextStyle(
                color: colorScheme.secondary,
                fontWeight: FontWeight.bold,
              ),
              urlHoverStyle: TextStyle(
                decoration: TextDecoration.underline,
                decorationColor: colorScheme.secondary,
              ),
              child: Textf(
                'This [link looks different]'
                '(https://docs.flexcolorscheme.com/).',
              ),
            ),
          ),
        ],
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_flex/lib/home_screen.dart -->

<!-- BEGIN FILE: [v0.6.1] example/textf_flex/lib/main.dart -->
import 'package:flex_color_scheme/flex_color_scheme.dart';
import 'package:flutter/material.dart';

import 'home_screen.dart';

void main() {
  runApp(const FlexTextfExampleApp());
}

class FlexTextfExampleApp extends StatefulWidget {
  const FlexTextfExampleApp({super.key});

  @override
  State<FlexTextfExampleApp> createState() => _FlexTextfExampleAppState();
}

class _FlexTextfExampleAppState extends State<FlexTextfExampleApp> {
  // State for the selected FlexScheme and ThemeMode
  FlexScheme _selectedScheme = FlexScheme.material;
  ThemeMode _themeMode = ThemeMode.light;

  // Callback to change the selected theme scheme
  void _handleSchemeChange(FlexScheme? scheme) {
    if (scheme != null) {
      setState(() {
        _selectedScheme = scheme;
      });
    }
  }

  // Callback to toggle the ThemeMode (Light/Dark/System)
  void _handleThemeModeChange() {
    setState(() {
      switch (_themeMode) {
        case ThemeMode.light:
          _themeMode = ThemeMode.dark;
          break;
        case ThemeMode.dark:
          _themeMode = ThemeMode.system;
          break;
        case ThemeMode.system:
          _themeMode = ThemeMode.light;
          break;
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    // Use Material 3
    const bool useMaterial3 = true;

    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Textf + FlexColorScheme',
      theme: FlexThemeData.light(
        scheme: _selectedScheme,
        surfaceMode: FlexSurfaceMode.levelSurfacesLowScaffold,
        blendLevel: 20,
        subThemesData: const FlexSubThemesData(),
        visualDensity: FlexColorScheme.comfortablePlatformDensity,
        useMaterial3: useMaterial3,
        swapLegacyOnMaterial3: useMaterial3,
      ),
      darkTheme: FlexThemeData.dark(
        scheme: _selectedScheme,
        surfaceMode: FlexSurfaceMode.levelSurfacesLowScaffold,
        blendLevel: 20,
        subThemesData: const FlexSubThemesData(),
        visualDensity: FlexColorScheme.comfortablePlatformDensity,
        useMaterial3: useMaterial3,
        swapLegacyOnMaterial3: useMaterial3,
      ),
      themeMode: _themeMode,
      home: HomeScreen(
        selectedScheme: _selectedScheme,
        themeMode: _themeMode,
        onSchemeChanged: _handleSchemeChange,
        onThemeModeChanged: _handleThemeModeChange,
      ),
    );
  }
}

<!-- END FILE: [v0.6.1] example/textf_flex/lib/main.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/parser_link_test.dart -->
// ignore_for_file: avoid-late-keyword, no-magic-number

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/core/default_styles.dart';
import 'package:textf/src/parsing/textf_parser.dart';
import 'package:textf/src/widgets/internal/hoverable_link_span.dart';
import 'package:textf/src/widgets/textf_options.dart';

import '../widgets/pump_textf_widget.dart';

void main() {
  group('Link Parsing Tests', () {
    late TextfParser parser;
    late BuildContext mockContext;

    setUp(() {
      parser = TextfParser();
      // We'll set mockContext in the test widget
    });

    // Helper to create a test BuildContext
    Widget buildTestWidget(
      WidgetTester tester,
      Widget Function(BuildContext) builder,
    ) {
      return MaterialApp(
        home: Builder(
          builder: (context) {
            mockContext = context;
            return builder(context);
          },
        ),
      );
    }

    group('Basic Link Parsing', () {
      testWidgets('simple link without formatting', (tester) async {
        late BuildContext mockContext; // Capture context
        final lightTheme = ThemeData.light(); // Use a specific theme

        // Setup context with the light theme
        await tester.pumpWidget(
          MaterialApp(
            theme: lightTheme,
            home: Builder(
              builder: (context) {
                mockContext = context;
                return Container();
              },
            ),
          ),
        );
        const baseStyle = TextStyle();
        final parser = TextfParser();

        // Parse
        final spans = parser.parse(
          'Visit [Flutter website](https://flutter.dev)',
          mockContext,
          baseStyle,
        );

        // Verify overall structure (remains the same)
        expect(spans.length, 2);
        expect(spans.first, isA<TextSpan>());
        expect((spans.first as TextSpan).text, 'Visit ');
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;
        // --- Verify properties on the HoverableLinkSpan ---
        expect(hoverableWidget.url, 'https://flutter.dev');
        expect(hoverableWidget.rawDisplayText, 'Flutter website', reason: 'Raw display text should be stored');

        // For simple text without internal formatting, initialPlainText should be set,
        // and initialChildrenSpans should be empty.
        expect(hoverableWidget.initialPlainText, 'Flutter website');
        expect(hoverableWidget.initialChildrenSpans, isEmpty);

        // --- Verify the style passed to HoverableLinkSpan ---
        // The 'normalStyle' should now reflect the theme's primary color.
        // Calculate expected style by merging base with theme default link style
        final expectedNormalStyle = baseStyle.merge(
          TextStyle(
            color: lightTheme.colorScheme.primary, // Expect theme primary color
            decoration: TextDecoration.underline,
            decorationColor: lightTheme.colorScheme.primary,
          ),
        );

        expect(
          hoverableWidget.normalStyle.color,
          // Expect theme primary color instead of old hardcoded blue
          lightTheme.colorScheme.primary,
          reason: 'Normal style color should match theme primary color', // Updated reason
        );
        expect(
          hoverableWidget.normalStyle.decoration,
          TextDecoration.underline, // Default decoration still expected
          reason: 'Normal style decoration should be underline',
        );
        expect(
          hoverableWidget.normalStyle.decorationColor,
          // Expect theme primary color for decoration
          lightTheme.colorScheme.primary,
          reason: 'Normal style decoration color should match theme primary color', // Updated reason
        );

        // Hover style check (assuming default hover = normal style when no options)
        final expectedHoverStyle = expectedNormalStyle; // In theme fallback, hover == normal
        expect(
          hoverableWidget.hoverStyle.color,
          expectedHoverStyle.color,
          reason: 'Hover style color should match normal theme style',
        );
        expect(
          hoverableWidget.hoverStyle.decorationColor,
          expectedHoverStyle.decorationColor,
          reason: 'Hover style decoration color should match normal theme style',
        );

        // --- Verify other interaction properties (optional but good) ---
        expect(hoverableWidget.mouseCursor, DefaultStyles.urlMouseCursor);
        // Check recognizer existence if tap callback is expected (add TextfOptions for that)
        // expect(hoverableWidget.tapRecognizer, isNotNull);
      });

      testWidgets('link with URL normalization', (tester) async {
        // Setup context
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();

        // Parse
        final spans = parser.parse(
          'Visit [Google](google.com)', // Input text with non-normalized URL
          mockContext,
          baseStyle,
        );

        // Verify overall structure
        expect(spans.length, 2, reason: "Should have 2 spans: 'Visit ' and the link");
        expect(spans.first, isA<TextSpan>());
        expect((spans.first as TextSpan).text, 'Visit ');

        // --- Verify the WidgetSpan for the link ---
        expect(spans[1], isA<WidgetSpan>(), reason: 'Link span should be a WidgetSpan');
        final widgetSpan = spans[1] as WidgetSpan;

        // --- Verify the child widget inside the WidgetSpan ---
        expect(widgetSpan.child, isA<HoverableLinkSpan>(), reason: 'WidgetSpan should contain HoverableLinkSpan');
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // --- Check URL normalization on the HoverableLinkSpan ---
        // This is the core assertion for this test case.
        expect(hoverableWidget.url, 'http://google.com', reason: 'URL should be normalized with http:// prefix');

        // --- Also check other properties (optional but good practice) ---
        expect(hoverableWidget.rawDisplayText, 'Google'); // The original text between []
        expect(hoverableWidget.initialPlainText, 'Google'); // The plain text content (no internal format)
        expect(hoverableWidget.initialChildrenSpans, isEmpty); // No nested formatting
      });

      testWidgets('multiple links in text', (tester) async {
        // Setup context
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();

        // Parse
        final spans = parser.parse(
          'Visit [Flutter](https://flutter.dev) or [Dart](https://dart.dev)',
          mockContext,
          baseStyle,
        );

        // Expect 4 spans: "Visit ", first link (WidgetSpan), " or ", second link (WidgetSpan)
        expect(spans.length, 4, reason: 'Should have 4 spans total');

        // --- Check text spans  ---
        expect(spans.first, isA<TextSpan>());
        expect((spans.first as TextSpan).text, 'Visit ');
        expect(spans[2], isA<TextSpan>());
        expect((spans[2] as TextSpan).text, ' or ');

        // --- Check first link span (spans[1]) ---
        expect(spans[1], isA<WidgetSpan>(), reason: 'First link should be a WidgetSpan');
        final widgetSpan1 = spans[1] as WidgetSpan;
        expect(widgetSpan1.child, isA<HoverableLinkSpan>(), reason: 'WidgetSpan 1 should contain HoverableLinkSpan');
        final hoverableWidget1 = widgetSpan1.child as HoverableLinkSpan;

        // Verify properties of the first HoverableLinkSpan
        expect(hoverableWidget1.url, 'https://flutter.dev');
        expect(hoverableWidget1.rawDisplayText, 'Flutter');
        expect(hoverableWidget1.initialPlainText, 'Flutter'); // Since no internal formatting
        expect(hoverableWidget1.initialChildrenSpans, isEmpty);

        // --- Check second link span (spans[3]) ---
        expect(spans[3], isA<WidgetSpan>(), reason: 'Second link should be a WidgetSpan');
        final widgetSpan2 = spans[3] as WidgetSpan;
        expect(widgetSpan2.child, isA<HoverableLinkSpan>(), reason: 'WidgetSpan 2 should contain HoverableLinkSpan');
        final hoverableWidget2 = widgetSpan2.child as HoverableLinkSpan;

        // Verify properties of the second HoverableLinkSpan
        expect(hoverableWidget2.url, 'https://dart.dev');
        expect(hoverableWidget2.rawDisplayText, 'Dart');
        expect(hoverableWidget2.initialPlainText, 'Dart'); // Since no internal formatting
        expect(hoverableWidget2.initialChildrenSpans, isEmpty);
      });
    });

    group('Formatted Link Text', () {
      testWidgets('bold text in link', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [**Bold Link**](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans.first, isA<TextSpan>()); // "Visit "
        expect(spans[1], isA<WidgetSpan>()); // Link WidgetSpan
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '**Bold Link**');
        expect(hoverableWidget.initialPlainText, isNull, reason: 'Should have children spans, not plain text');
        expect(hoverableWidget.initialChildrenSpans, isNotEmpty);
        expect(hoverableWidget.initialChildrenSpans.length, 1, reason: 'Link text itself has one formatted part');

        // --- Verify the *inner* span's style ---
        final innerSpan = hoverableWidget.initialChildrenSpans.first;
        expect(innerSpan, isA<TextSpan>());
        final innerTextSpan = innerSpan as TextSpan;

        // Check formatting applied *within* the link text
        expect(innerTextSpan.text, 'Bold Link');
        expect(innerTextSpan.style?.fontWeight, FontWeight.bold, reason: 'Inner span should be bold');

        // Check that the inner span *also* inherits the link's base style
        // (which comes from hoverableWidget.normalStyle)
        expect(
          innerTextSpan.style?.color,
          hoverableWidget.normalStyle.color,
          reason: 'Inner span should inherit link color',
        );
        expect(
          innerTextSpan.style?.decoration,
          hoverableWidget.normalStyle.decoration,
          reason: 'Inner span should inherit link decoration',
        );
      });

      testWidgets('italic text in link', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [*Italic Link*](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '*Italic Link*');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 1);

        // Verify the inner span's style
        final innerSpan = hoverableWidget.initialChildrenSpans.first as TextSpan;
        expect(innerSpan.text, 'Italic Link');
        expect(innerSpan.style?.fontStyle, FontStyle.italic, reason: 'Inner span should be italic');

        // Verify inheritance of base link style
        expect(innerSpan.style?.color, hoverableWidget.normalStyle.color);
        expect(innerSpan.style?.decoration, hoverableWidget.normalStyle.decoration);
      });

      testWidgets('strikethrough text in link', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [~~Strikethrough Link~~](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '~~Strikethrough Link~~');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 1);

        // Verify the inner span's style
        final innerSpan = hoverableWidget.initialChildrenSpans.first as TextSpan;
        expect(innerSpan.text, 'Strikethrough Link');
        expect(
          innerSpan.style?.decoration,
          TextDecoration.combine([TextDecoration.underline, TextDecoration.lineThrough]),
          reason: "Inner span should combine link's underline with strikethrough",
        ); // Check decoration color is inherited from base link style's color
        expect(innerSpan.style?.decorationColor, hoverableWidget.normalStyle.color);

        // Verify inheritance of base link style color
        expect(innerSpan.style?.color, hoverableWidget.normalStyle.color);
      });

      testWidgets('code text in link', (tester) async {
        late BuildContext mockContext;
        final lightTheme = ThemeData.light();

        // Setup context
        await tester.pumpWidget(
          MaterialApp(
            theme: lightTheme,
            home: Builder(
              builder: (context) {
                mockContext = context;
                return Container();
              },
            ),
          ),
        );
        const baseStyle = TextStyle();
        final parser = TextfParser();
        const text = 'Visit [`Code Link`](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '`Code Link`');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 1);

        // Verify the inner span's style
        final innerSpan = hoverableWidget.initialChildrenSpans.first as TextSpan;

        // Calculate expected code style merged with the *link's normal style*
        // The link's normal style gets the theme primary color.
        final linkNormalStyle = baseStyle.merge(TextStyle(color: lightTheme.colorScheme.primary));
        final expectedInnerCodeStyle = linkNormalStyle.copyWith(
          // Apply code style onto link style
          fontFamily: 'monospace',
          fontFamilyFallback: ['RobotoMono', 'Menlo', 'Courier New'],
          // Expect theme background color
          backgroundColor: lightTheme.colorScheme.surfaceContainer,
          // Code text color should come from theme, overriding link color
          color: lightTheme.colorScheme.onSurfaceVariant,
          letterSpacing: 0,
        );

        expect(innerSpan.text, 'Code Link');
        expect(
          innerSpan.style?.fontFamily,
          expectedInnerCodeStyle.fontFamily,
          reason: 'Inner span should have monospace font',
        );
        expect(
          innerSpan.style?.backgroundColor,
          // Expect theme surfaceContainer color
          lightTheme.colorScheme.surfaceContainer,
          reason: 'Inner span should have theme code background',
        );
        expect(
          innerSpan.style?.color,
          // Expect theme code text color
          lightTheme.colorScheme.onSurfaceVariant,
          reason: 'Inner span should have theme code text color',
        );
      });
    });

    group('Mixed Formatting in Link Text', () {
      testWidgets('multiple formatting styles in link', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [**Bold** and *italic* text](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '**Bold** and *italic* text');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(
          hoverableWidget.initialChildrenSpans.length,
          4,
          reason: "Expected 4 inner spans: bold, ' and ', italic, ' text'",
        );

        // --- Verify the *inner* spans ---
        final innerSpans = hoverableWidget.initialChildrenSpans;

        // Child 0: Bold
        final boldSpan = innerSpans.first as TextSpan;
        expect(boldSpan.text, 'Bold');
        expect(boldSpan.style?.fontWeight, FontWeight.bold);
        expect(boldSpan.style?.color, hoverableWidget.normalStyle.color); // Inherited link color

        // Child 1: Plain
        final plainSpan1 = innerSpans[1] as TextSpan;
        expect(plainSpan1.text, ' and ');
        expect(plainSpan1.style?.fontWeight, isNot(FontWeight.bold)); // Not bold
        expect(plainSpan1.style?.fontStyle, isNot(FontStyle.italic)); // Not italic
        expect(plainSpan1.style?.color, hoverableWidget.normalStyle.color); // Inherited link color

        // Child 2: Italic
        final italicSpan = innerSpans[2] as TextSpan;
        expect(italicSpan.text, 'italic');
        expect(italicSpan.style?.fontStyle, FontStyle.italic);
        expect(italicSpan.style?.color, hoverableWidget.normalStyle.color); // Inherited link color

        // Child 3: Plain
        final plainSpan2 = innerSpans[3] as TextSpan;
        expect(plainSpan2.text, ' text');
        expect(plainSpan2.style?.fontWeight, isNot(FontWeight.bold));
        expect(plainSpan2.style?.fontStyle, isNot(FontStyle.italic));
        expect(plainSpan2.style?.color, hoverableWidget.normalStyle.color); // Inherited link color
      });

      testWidgets('nested formatting in link text', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [**Bold _and italic_**](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '**Bold _and italic_**');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 2, reason: "Expected 2 inner spans: 'Bold ', 'and italic'");

        // --- Verify the *inner* spans ---
        final innerSpans = hoverableWidget.initialChildrenSpans;

        // Child 0: Bold only
        final boldSpan = innerSpans.first as TextSpan;
        expect(boldSpan.text, 'Bold ');
        expect(boldSpan.style?.fontWeight, FontWeight.bold);
        expect(boldSpan.style?.fontStyle, isNot(FontStyle.italic)); // Not italic
        expect(boldSpan.style?.color, hoverableWidget.normalStyle.color); // Inherited link color

        // Child 1: Bold and Italic
        final boldItalicSpan = innerSpans[1] as TextSpan;
        expect(boldItalicSpan.text, 'and italic');
        expect(boldItalicSpan.style?.fontWeight, FontWeight.bold); // Bold
        expect(boldItalicSpan.style?.fontStyle, FontStyle.italic); // Italic
        expect(boldItalicSpan.style?.color, hoverableWidget.normalStyle.color); // Inherited link color
      });
    });

    group('Style Inheritance', () {
      testWidgets('link style is properly applied to formatted text from TextfOptions', (tester) async {
        // Define styles and options
        const baseStyle = TextStyle(fontSize: 16, color: Colors.black);
        const optionsUrlStyle = TextStyle(color: Colors.red, fontSize: 18, decoration: TextDecoration.none);
        const optionsBoldStyle =
            TextStyle(fontWeight: FontWeight.w900, decoration: TextDecoration.underline); // Add another prop to bold

        // Setup widget tree with TextfOptions
        late BuildContext testContext;
        await tester.pumpWidget(
          MaterialApp(
            home: Builder(
              builder: (context) {
                // Provide base style via DefaultTextStyle for context resolution
                return DefaultTextStyle(
                  style: baseStyle,
                  child: TextfOptions(
                    urlStyle: optionsUrlStyle,
                    boldStyle: optionsBoldStyle,
                    child: Builder(
                      builder: (innerContext) {
                        testContext = innerContext; // Capture context with options
                        return Container();
                      },
                    ),
                  ),
                );
              },
            ),
          ),
        );

        // Parse using the captured context
        final spans = parser.parse(
          'Visit [**Bold Link**](https://example.com)',
          testContext,
          baseStyle, // Pass base style explicitly to parser
        );

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify the style passed *to* HoverableLinkSpan (should reflect options)
        // Expected normal style = baseStyle merged with optionsUrlStyle
        expect(
          hoverableWidget.normalStyle.color,
          optionsUrlStyle.color,
          reason: 'Normal link style should have options color',
        );
        expect(
          hoverableWidget.normalStyle.fontSize,
          optionsUrlStyle.fontSize,
          reason: 'Normal link style should have options font size',
        );
        expect(
          hoverableWidget.normalStyle.decoration,
          optionsUrlStyle.decoration,
          reason: 'Normal link style should have options decoration',
        );

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.rawDisplayText, '**Bold Link**');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 1);

        // Verify the *inner* span's style (should inherit final link style + have its own format)
        final innerSpan = hoverableWidget.initialChildrenSpans.first as TextSpan;
        expect(innerSpan.text, 'Bold Link');

        // Check inheritance of the final normal link style
        expect(innerSpan.style?.color, optionsUrlStyle.color); // Inherited from link
        expect(innerSpan.style?.fontSize, optionsUrlStyle.fontSize); // Inherited from link

        // Check applied bold style (from TextfOptions, overriding default bold)
        expect(innerSpan.style?.fontWeight, optionsBoldStyle.fontWeight); // From options bold
        expect(
          innerSpan.style?.decoration,
          optionsBoldStyle.decoration,
        ); // From options bold (overrides link's decoration:none)
      });

      testWidgets('base style is properly inherited by links and nested formats', (tester) async {
        late BuildContext mockContext;
        final lightTheme = ThemeData.light();

        // Setup context
        await tester.pumpWidget(
          MaterialApp(
            theme: lightTheme,
            home: Builder(
              builder: (context) {
                mockContext = context;
                return Container();
              },
            ),
          ),
        );
        const baseStyle = TextStyle(
          // Base style is purple
          fontFamily: 'Roboto',
          fontSize: 20,
          height: 1.5,
          color: Colors.purple,
        );
        final parser = TextfParser();

        // Parse with the specific base style
        final spans = parser.parse(
          'Visit [**Bold Link**](https://example.com)',
          mockContext,
          baseStyle,
        );

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify the normal style passed to HoverableLinkSpan (Base + Theme Link)
        expect(hoverableWidget.normalStyle.fontFamily, baseStyle.fontFamily);
        expect(hoverableWidget.normalStyle.fontSize, baseStyle.fontSize);
        expect(hoverableWidget.normalStyle.height, baseStyle.height);
        expect(
          hoverableWidget.normalStyle.color,
          // Expect theme primary color, overriding base purple
          lightTheme.colorScheme.primary,
          reason: 'Theme link color should override base color',
        );
        expect(hoverableWidget.normalStyle.decoration, TextDecoration.underline);

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.rawDisplayText, '**Bold Link**');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 1);
        final innerSpan = hoverableWidget.initialChildrenSpans.first as TextSpan;
        expect(innerSpan.text, 'Bold Link');

        // Check inheritance of final link style properties
        expect(innerSpan.style?.fontFamily, baseStyle.fontFamily);
        expect(innerSpan.style?.fontSize, baseStyle.fontSize);
        expect(innerSpan.style?.height, baseStyle.height);
        expect(
          innerSpan.style?.color,
          // Expect theme primary color
          lightTheme.colorScheme.primary,
          reason: 'Inner span should inherit theme link color',
        );
        expect(innerSpan.style?.decoration, TextDecoration.underline);

        // Check bold formatting was applied
        expect(innerSpan.style?.fontWeight, FontWeight.bold);
      });
    });

    group('Edge Cases', () {
      testWidgets('escaped formatting characters in link text', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = r'Visit [This is \*not formatted\*](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, r'This is \*not formatted\*');

        // Escaped characters should result in plain text treatment
        expect(
          hoverableWidget.initialPlainText,
          'This is *not formatted*',
          reason: 'Escaped text should be in initialPlainText',
        );
        expect(hoverableWidget.initialChildrenSpans, isEmpty, reason: 'Should have no children spans for escaped text');
      });

      testWidgets('Unicode characters in link text', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [**‰Ω†Â•Ω‰∏ñÁïå**](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '**‰Ω†Â•Ω‰∏ñÁïå**');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 1);

        // Verify inner span
        final innerSpan = hoverableWidget.initialChildrenSpans.first as TextSpan;
        expect(innerSpan.text, '‰Ω†Â•Ω‰∏ñÁïå');
        expect(innerSpan.style?.fontWeight, FontWeight.bold);
        expect(innerSpan.style?.color, hoverableWidget.normalStyle.color); // Inherited link color
      });

      testWidgets('empty link text', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties for empty text
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, ''); // Empty raw text
        expect(hoverableWidget.initialPlainText, ''); // Empty plain text
        expect(hoverableWidget.initialChildrenSpans, isEmpty); // No children
      });

      testWidgets('very long link text with formatting', (tester) async {
        // Added 'with formatting'
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        final longText = 'A' * 1000;
        final text = 'Visit [**$longText**](https://example.com)'; // Make it bold

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '**$longText**');
        expect(hoverableWidget.initialPlainText, isNull); // Has children spans
        expect(hoverableWidget.initialChildrenSpans.length, 1);

        // Verify inner span
        final innerSpan = hoverableWidget.initialChildrenSpans.first as TextSpan;
        expect(innerSpan.text, longText); // Contains the long text
        expect(innerSpan.text?.length, 1000);
        expect(innerSpan.style?.fontWeight, FontWeight.bold); // Is bold
        expect(innerSpan.style?.color, hoverableWidget.normalStyle.color); // Inherits link color
      });
    });

    group('Complex Scenarios', () {
      testWidgets('multiple links with different formatting', (tester) async {
        // Setup
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle();
        const text = 'Visit [**Bold**](https://bold.com) or [*Italic*](https://italic.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 4, reason: 'Should have 4 spans total');
        expect(spans.first, isA<TextSpan>(), reason: 'First span is plain text');
        expect(spans[2], isA<TextSpan>(), reason: 'Third span is plain text');

        // --- Verify First Link (Bold) ---
        expect(spans[1], isA<WidgetSpan>(), reason: 'Span at index 1 should be a WidgetSpan for the bold link');
        final widgetSpan1 = spans[1] as WidgetSpan;
        expect(widgetSpan1.child, isA<HoverableLinkSpan>(), reason: 'WidgetSpan 1 should contain a HoverableLinkSpan');
        final hoverableWidget1 = widgetSpan1.child as HoverableLinkSpan;

        // Verify properties of the first HoverableLinkSpan
        expect(hoverableWidget1.url, 'https://bold.com');
        expect(hoverableWidget1.rawDisplayText, '**Bold**');
        expect(
          hoverableWidget1.initialPlainText,
          isNull,
          reason: 'Link text has internal formatting, so plain text should be null',
        );
        // Debug output showed length is 1
        expect(
          hoverableWidget1.initialChildrenSpans.length,
          1,
          reason: "Inner parse returns one direct TextSpan for '**Bold**'",
        );

        // --- ADJUSTMENT: Access the *direct* inner span ---
        // Since children is null, the first element IS the actual formatted span
        final innerSpan1 = hoverableWidget1.initialChildrenSpans.first;
        expect(innerSpan1, isA<TextSpan>(), reason: 'The single child span should be a TextSpan');
        // --- END ADJUSTMENT ---

        // Check style of the actual inner span
        expect((innerSpan1 as TextSpan).text, 'Bold');
        expect(innerSpan1.style?.fontWeight, FontWeight.bold, reason: 'Inner span should be bold');
        expect(
          innerSpan1.style?.color,
          hoverableWidget1.normalStyle.color,
          reason: "Inner span should inherit the link's normal text color",
        );
        // Verify it does NOT have children itself
        expect(innerSpan1.children, isNull, reason: "Directly returned span shouldn't have nested children here");

        // --- Verify Second Link (Italic) ---
        expect(spans[3], isA<WidgetSpan>(), reason: 'Span at index 3 should be a WidgetSpan for the italic link');
        final widgetSpan2 = spans[3] as WidgetSpan;
        expect(widgetSpan2.child, isA<HoverableLinkSpan>(), reason: 'WidgetSpan 2 should contain a HoverableLinkSpan');
        final hoverableWidget2 = widgetSpan2.child as HoverableLinkSpan;

        // Verify properties of the second HoverableLinkSpan
        expect(hoverableWidget2.url, 'https://italic.com');
        expect(hoverableWidget2.rawDisplayText, '*Italic*');
        expect(hoverableWidget2.initialPlainText, isNull);
        // Debug output showed length is 1
        expect(
          hoverableWidget2.initialChildrenSpans.length,
          1,
          reason: "Inner parse returns one direct TextSpan for '*Italic*'",
        );

        // --- ADJUSTMENT: Access the *direct* inner span ---
        final innerSpan2 = hoverableWidget2.initialChildrenSpans.first;
        expect(innerSpan2, isA<TextSpan>(), reason: 'The single child span should be a TextSpan');
        // --- END ADJUSTMENT ---

        // Check style of the actual inner span
        expect((innerSpan2 as TextSpan).text, 'Italic');
        expect(innerSpan2.style?.fontStyle, FontStyle.italic, reason: 'Inner span should be italic');
        expect(
          innerSpan2.style?.color,
          hoverableWidget2.normalStyle.color,
          reason: "Inner span should inherit the link's normal text color",
        );
        // Verify it does NOT have children itself
        expect(innerSpan2.children, isNull, reason: "Directly returned span shouldn't have nested children here");
      });

      testWidgets('links within formatted text', (tester) async {
        late BuildContext mockContext;
        final lightTheme = ThemeData.light();

        // Setup context
        await tester.pumpWidget(
          MaterialApp(
            theme: lightTheme,
            home: Builder(
              builder: (context) {
                mockContext = context;
                return Container();
              },
            ),
          ),
        );
        const baseStyle = TextStyle(color: Colors.black); // Base style is black
        final parser = TextfParser();
        const text = '**Bold text with [a link](https://example.com) inside**';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 3);

        // Verify Bold Start
        expect(spans.first, isA<TextSpan>(), reason: 'First span should be bold text');
        final boldStartSpan = spans.first as TextSpan;
        expect(boldStartSpan.text, 'Bold text with ');
        expect(boldStartSpan.style?.fontWeight, FontWeight.bold);
        expect(boldStartSpan.style?.color, baseStyle.color, reason: 'Should inherit base color');

        // Verify Link Span
        expect(spans[1], isA<WidgetSpan>(), reason: 'Second span should be the link WidgetSpan');
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, 'a link');
        // Check plain text handling because inner link text has no formatting
        expect(hoverableWidget.initialPlainText, 'a link', reason: 'Link text is plain, should be in initialPlainText');
        expect(hoverableWidget.initialChildrenSpans, isEmpty, reason: 'Plain link text should have no children spans');

        expect(
          hoverableWidget.normalStyle.fontWeight,
          FontWeight.bold, // Inherited bold from surroundings
          reason: "Link's normal style should inherit surrounding bold",
        );
        expect(
          hoverableWidget.normalStyle.color,
          // Expect theme primary color, overriding base/bold color
          lightTheme.colorScheme.primary,
          reason: "Link's normal style should have theme link color (over base/bold color)",
        );
        expect(
          hoverableWidget.normalStyle.decoration,
          TextDecoration.underline, // Default decoration
          reason: "Link's normal style should have default link decoration",
        );
      });

      testWidgets('link text with mixed and nested formatting', (tester) async {
        late BuildContext mockContext;
        final lightTheme = ThemeData.light();

        // Setup context
        await tester.pumpWidget(
          MaterialApp(
            theme: lightTheme,
            home: Builder(
              builder: (context) {
                mockContext = context;
                return Container();
              },
            ),
          ),
        );
        const baseStyle = TextStyle();
        final parser = TextfParser();
        const text = 'Visit [**Bold** *Italic* ~~Strike~~ `Code` **_Both_**](https://example.com)';

        // Parse
        final spans = parser.parse(text, mockContext, baseStyle);

        // Verify structure
        expect(spans.length, 2);
        expect(spans[1], isA<WidgetSpan>());
        final widgetSpan = spans[1] as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());
        final hoverableWidget = widgetSpan.child as HoverableLinkSpan;

        // Verify HoverableLinkSpan properties
        expect(hoverableWidget.url, 'https://example.com');
        expect(hoverableWidget.rawDisplayText, '**Bold** *Italic* ~~Strike~~ `Code` **_Both_**');
        expect(hoverableWidget.initialPlainText, isNull);
        expect(hoverableWidget.initialChildrenSpans.length, 9);
        final innerSpans = hoverableWidget.initialChildrenSpans;

        // --- Verify *inner* spans ---
        final linkNormalColor = lightTheme.colorScheme.primary; // Use theme color
        expect(innerSpans.first, isA<TextSpan>());
        expect((innerSpans.first as TextSpan).text, 'Bold');
        expect((innerSpans.first as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((innerSpans.first as TextSpan).style?.color, linkNormalColor);

        expect(innerSpans[1], isA<TextSpan>());
        expect((innerSpans[1] as TextSpan).text, ' '); // Space

        expect(innerSpans[2], isA<TextSpan>());
        expect((innerSpans[2] as TextSpan).text, 'Italic');
        expect((innerSpans[2] as TextSpan).style?.fontStyle, FontStyle.italic);
        expect((innerSpans[2] as TextSpan).style?.color, linkNormalColor);

        expect(innerSpans[3], isA<TextSpan>());
        expect((innerSpans[3] as TextSpan).text, ' '); // Space

        expect(innerSpans[4], isA<TextSpan>());
        expect((innerSpans[4] as TextSpan).text, 'Strike');
        expect(
          (innerSpans[4] as TextSpan).style?.decoration,
          TextDecoration.combine([TextDecoration.underline, TextDecoration.lineThrough]),
        );
        expect((innerSpans[4] as TextSpan).style?.color, linkNormalColor);

        expect(innerSpans[5], isA<TextSpan>());
        expect((innerSpans[5] as TextSpan).text, ' '); // Space

        // Check Code span (index 6)
        final codeSpan = innerSpans[6] as TextSpan;
        final linkNormalStyle = baseStyle.merge(TextStyle(color: linkNormalColor)); // Base style for code inside link
        final expectedInnerCodeStyle = linkNormalStyle.copyWith(
          // Apply code style onto link style
          fontFamily: 'monospace',
          fontFamilyFallback: ['RobotoMono', 'Menlo', 'Courier New'],
          backgroundColor: lightTheme.colorScheme.surfaceContainer, // Expect theme background
          color: lightTheme.colorScheme.onSurfaceVariant, // Expect theme text color
          letterSpacing: 0,
        );

        expect(codeSpan.text, 'Code');
        expect(codeSpan.style?.fontFamily, expectedInnerCodeStyle.fontFamily);
        expect(
          codeSpan.style?.backgroundColor,
          // Expect theme background color
          lightTheme.colorScheme.surfaceContainer,
          reason: 'Code segment inside link should use theme background',
        );
        expect(codeSpan.style?.color, expectedInnerCodeStyle.color);

        expect((innerSpans[8] as TextSpan).text, 'Both');
        expect((innerSpans[8] as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((innerSpans[8] as TextSpan).style?.fontStyle, FontStyle.italic);
        expect((innerSpans[8] as TextSpan).style?.color, linkNormalColor);
      });
    });

    group('Interaction Behavior', () {
      testWidgets('onUrlTap callback is triggered on tap', (tester) async {
        // --- Setup Callback Tracking ---
        bool tapCalled = false;
        String? tappedUrl;
        String? tappedText;
        const inputText = 'Visit [**Flutter**](https://flutter.dev)';
        const expectedUrl = 'https://flutter.dev';
        const expectedRawText = '**Flutter**'; // TextfOptions callback gets raw text

        // --- Pump Widget with TextfOptions ---
        await pumpTextfWidget(
          tester,
          data: inputText,
          textfOptions: TextfOptions(
            // Provide a dummy child for the constructor if needed, but it's replaced by Textf above
            child: const SizedBox.shrink(),
            onUrlTap: (url, displayText) {
              tapCalled = true;
              tappedUrl = url;
              tappedText = displayText;
            },
          ),
        );

        // --- Find the Interactive Widget ---
        // We need to find the HoverableLinkSpan widget rendered on screen.
        // Since there's only one link, finding by type should be sufficient.
        final linkFinder = find.byType(HoverableLinkSpan);
        expect(linkFinder, findsOneWidget, reason: 'Should find the HoverableLinkSpan widget');

        // --- Simulate Tap ---
        await tester.tap(linkFinder);
        // Allow callbacks to process
        await tester.pumpAndSettle();

        // --- Verify Callback Invocation and Parameters ---
        expect(tapCalled, isTrue, reason: 'onUrlTap callback should have been triggered');
        expect(tappedUrl, expectedUrl, reason: 'Callback should receive the correct URL');
        expect(tappedText, expectedRawText, reason: 'Callback should receive the raw display text');
      });

      testWidgets('onUrlHover callback is triggered on hover', (tester) async {
        // --- Setup Callback Tracking ---
        bool hoverCalled = false;
        bool isHover = false;
        String? hoveredUrl;
        String? hoveredText;
        const inputText = 'Visit [Flutter](https://flutter.dev)';
        const expectedUrl = 'https://flutter.dev';
        const expectedRawText = 'Flutter'; // TextfOptions callback gets raw text

        // --- Pump Widget with TextfOptions ---
        await pumpTextfWidget(
          tester,
          data: inputText,
          textfOptions: TextfOptions(
            child: const SizedBox.shrink(), // Dummy child
            onUrlHover: (url, displayText, {required bool isHovering}) {
              hoverCalled = true;
              hoveredUrl = url;
              hoveredText = displayText;
              isHover = isHovering;
            },
          ),
        );

        // --- Find the Interactive Widget ---
        final linkFinder = find.byType(HoverableLinkSpan);
        expect(linkFinder, findsOneWidget);

        // --- Simulate Hover Enter ---
        final gesture = await tester.createGesture(kind: PointerDeviceKind.mouse);
        await gesture.addPointer(); // Add a mouse pointer
        await gesture.moveTo(tester.getCenter(linkFinder)); // Move pointer over the link
        await tester.pump(); // Allow hover event processing

        // --- Verify Hover Enter Callback ---
        expect(hoverCalled, isTrue, reason: 'onUrlHover should be called on enter');
        expect(isHover, isTrue, reason: 'isHovering should be true on enter');
        expect(hoveredUrl, expectedUrl);
        expect(hoveredText, expectedRawText);

        // --- Simulate Hover Exit ---
        hoverCalled = false; // Reset flag for exit check
        await gesture.moveTo(Offset.zero); // Move pointer away from the link
        await tester.pump(); // Allow hover event processing

        // --- Verify Hover Exit Callback ---
        expect(hoverCalled, isTrue, reason: 'onUrlHover should be called again on exit');
        expect(isHover, isFalse, reason: 'isHovering should be false on exit');
        // URL and text should remain the same from the last call
        expect(hoveredUrl, expectedUrl);
        expect(hoveredText, expectedRawText);

        // Clean up the gesture
        await gesture.removePointer();
      });
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/parser_link_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/parser_test.dart -->
// ignore_for_file: cascade_invocations // cascade_invocations for readability and chaining methods., no-magic-number
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/parsing/textf_parser.dart';

void main() {
  group('TextfParser Tests', () {
    // ignore: avoid-late-keyword
    late TextfParser parser;
    // ignore: avoid-late-keyword
    late BuildContext mockContext;

    setUp(() {
      parser = TextfParser();
      // Use a real BuildContext in a widget test
    });

    // Helper to create a test BuildContext
    Widget buildTestWidget(
      WidgetTester tester,
      Widget Function(BuildContext) builder,
    ) {
      return MaterialApp(
        home: Builder(
          builder: (context) {
            mockContext = context;
            return builder(context);
          },
        ),
      );
    }

    group('Basic Parsing', () {
      testWidgets('empty text returns empty spans list', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('', mockContext, const TextStyle());
        expect(spans, isEmpty);
      });

      testWidgets('plain text returns single TextSpan', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('plain text', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect(spans.first, isA<TextSpan>());
        expect((spans.first as TextSpan).text, 'plain text');
      });

      testWidgets('text with no actual formatting is handled efficiently', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse(
          'text with * single asterisk',
          mockContext,
          const TextStyle(),
        );
        expect(spans.length, 1);
        expect((spans.first as TextSpan).text, 'text with * single asterisk');
      });
    });

    group('Style Application', () {
      testWidgets('bold text applies FontWeight.bold', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('**bold**', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect((spans.first as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans.first as TextSpan).text, 'bold');
      });

      testWidgets('italic text applies FontStyle.italic', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('*italic*', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect((spans.first as TextSpan).style?.fontStyle, FontStyle.italic);
        expect((spans.first as TextSpan).text, 'italic');
      });

      testWidgets('bold-italic text applies both styles', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('***bold-italic***', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect((spans.first as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans.first as TextSpan).style?.fontStyle, FontStyle.italic);
        expect((spans.first as TextSpan).text, 'bold-italic');
      });

      testWidgets('strikethrough text applies line-through decoration', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('~~strikethrough~~', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect(
          (spans.first as TextSpan).style?.decoration,
          TextDecoration.lineThrough,
        );
        expect((spans.first as TextSpan).text, 'strikethrough');
      });

      testWidgets('code text applies monospace and background', (tester) async {
        // ignore: avoid-late-keyword
        late BuildContext mockContext;
        final lightTheme = ThemeData.light();

        // Setup context
        await tester.pumpWidget(
          MaterialApp(
            theme: lightTheme,
            home: Builder(
              builder: (context) {
                mockContext = context;
                return Container();
              },
            ),
          ),
        );
        final parser = TextfParser();

        final spans = parser.parse('`code`', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect((spans.first as TextSpan).style?.fontFamily, 'monospace');
        expect(
          (spans.first as TextSpan).style?.backgroundColor,
          // Expect theme surfaceContainer instead of old hardcoded grey
          lightTheme.colorScheme.surfaceContainer,
          reason: 'Code background should come from theme',
        );
        expect((spans.first as TextSpan).text, 'code');
        expect(
          (spans.first as TextSpan).style?.color,
          // Expect theme text color for code
          lightTheme.colorScheme.onSurfaceVariant,
          reason: 'Code text color should come from theme',
        );
      });

      testWidgets('base style is preserved and extended', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const baseStyle = TextStyle(fontSize: 20, color: Colors.blue);
        final spans = parser.parse('**bold**', mockContext, baseStyle);
        expect((spans.first as TextSpan).style?.fontSize, 20);
        expect((spans.first as TextSpan).style?.color, Colors.blue);
        expect((spans.first as TextSpan).style?.fontWeight, FontWeight.bold);
      });

      testWidgets('understcore variants apply correct styles', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final boldSpans = parser.parse('__bold__', mockContext, const TextStyle());
        expect((boldSpans.first as TextSpan).style?.fontWeight, FontWeight.bold);

        final italicSpans = parser.parse('_italic_', mockContext, const TextStyle());
        expect((italicSpans.first as TextSpan).style?.fontStyle, FontStyle.italic);

        final boldItalicSpans = parser.parse('___both___', mockContext, const TextStyle());
        expect(
          (boldItalicSpans.first as TextSpan).style?.fontWeight,
          FontWeight.bold,
        );
        expect(
          (boldItalicSpans.first as TextSpan).style?.fontStyle,
          FontStyle.italic,
        );
      });
    });

    group('Nesting Tests', () {
      testWidgets('nested formatting with different markers works', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse(
          '**bold with _italic_ inside**',
          mockContext,
          const TextStyle(),
        );

        expect(spans.length, 3);
        expect((spans.first as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans.first as TextSpan).text, 'bold with ');

        expect((spans[1] as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans[1] as TextSpan).style?.fontStyle, FontStyle.italic);
        expect((spans[1] as TextSpan).text, 'italic');

        expect((spans[2] as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans[2] as TextSpan).text, ' inside');
      });

      testWidgets('nested formatting with same markers handles correctly', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse(
          '**bold with *italic* inside**',
          mockContext,
          const TextStyle(),
        );

        // The parser should handle this specific case gracefully
        // We verify it doesn't crash and produces reasonable output
        expect(spans.isNotEmpty, true);
      });

      testWidgets('exceeding maximum nesting depth treats as text', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        // 3 levels of nesting (exceeds default maxDepth of 2)
        final spans = parser.parse(
          '**bold _italic ~~strike~~ text_**',
          mockContext,
          const TextStyle(),
        );

        // Verify that the third level is not applied
        bool hasStrikethrough = false;
        for (final span in spans) {
          if (span is TextSpan && span.style?.decoration == TextDecoration.lineThrough) {
            hasStrikethrough = true;
            break;
          }
        }
        expect(hasStrikethrough, false);
      });

      testWidgets('different nesting combinations parse correctly', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));

        // Bold with code
        final boldWithCode = parser.parse(
          '**bold with `code`**',
          mockContext,
          const TextStyle(),
        );
        expect(boldWithCode.length, 2);
        expect((boldWithCode[1] as TextSpan).style?.fontFamily, 'monospace');

        // Italic with strike
        final italicWithStrike = parser.parse(
          '*italic with ~~strike~~*',
          mockContext,
          const TextStyle(),
        );
        expect(italicWithStrike.length, 2);
        expect(
          (italicWithStrike[1] as TextSpan).style?.decoration,
          TextDecoration.lineThrough,
        );
      });
    });

    group('Error Handling', () {
      testWidgets('unpaired opening marker treated as text', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('**bold', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect((spans.first as TextSpan).text, '**bold');
      });

      testWidgets('unpaired closing marker treated as text', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('bold**', mockContext, const TextStyle());
        expect(spans.length, 1);
        expect((spans.first as TextSpan).text, 'bold**');
      });

      testWidgets('improperly nested tags handled gracefully', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        // opening bold, opening italic, closing bold, closing italic
        final spans = parser.parse(
          '**bold *italic** text*',
          mockContext,
          const TextStyle(),
        );

        // The result should not crash and should make a reasonable attempt
        expect(spans.isNotEmpty, true);
      });

      testWidgets('overlapping tags handled correctly', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse(
          '**bold *both** italic*',
          mockContext,
          const TextStyle(),
        );

        // Should not crash and handle gracefully
        expect(spans.isNotEmpty, true);
      });
    });

    group('Cache Tests', () {
      testWidgets('different styles use different cache entries', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const text = 'Cache **test**';
        const style1 = TextStyle(fontSize: 16);
        const style2 = TextStyle(fontSize: 18);

        final firstParse = parser.parse(text, mockContext, style1);
        final secondParse = parser.parse(text, mockContext, style2);

        // Verify different instances returned
        expect(identical(firstParse, secondParse), false);
      });
    });

    group('Edge Cases', () {
      testWidgets('very long text parses correctly', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final longText = '${'A' * 1000}**bold**${'B' * 1000}';
        final spans = parser.parse(longText, mockContext, const TextStyle());
        expect(spans.length, 3);
        expect((spans.first as TextSpan).text?.length, 1000);
        expect((spans[1] as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans[2] as TextSpan).text?.length, 1000);
      });

      testWidgets('Unicode characters parse correctly', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse(
          '**‰Ω†Â•Ω‰∏ñÁïå** *ÏïàÎÖïÌïòÏÑ∏Ïöî* ~~–ü—Ä–∏–≤–µ—Ç~~',
          mockContext,
          const TextStyle(),
        );
        expect(spans.length, 5); // 3 formatted spans + 2 spaces
        expect((spans.first as TextSpan).text, '‰Ω†Â•Ω‰∏ñÁïå');
        expect((spans.first as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans[2] as TextSpan).text, 'ÏïàÎÖïÌïòÏÑ∏Ïöî');
        expect((spans[2] as TextSpan).style?.fontStyle, FontStyle.italic);
        expect((spans[4] as TextSpan).text, '–ü—Ä–∏–≤–µ—Ç');
        expect(
          (spans[4] as TextSpan).style?.decoration,
          TextDecoration.lineThrough,
        );
      });

      testWidgets('emoji characters parse correctly', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse('**üòÄ** *üåç* ~~üö´~~', mockContext, const TextStyle());
        expect(spans.length, 5); // 3 formatted spans + 2 spaces
        expect((spans.first as TextSpan).text, 'üòÄ');
        expect((spans.first as TextSpan).style?.fontWeight, FontWeight.bold);
      });

      testWidgets('escaped characters parse correctly', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse(
          r'This is \*not italic\*',
          mockContext,
          const TextStyle(),
        );
        expect(spans.length, 1);
        expect((spans.first as TextSpan).text, 'This is *not italic*');
      });
    });

    group('Mixed Formatting', () {
      testWidgets('mixed formatting applies correct styles', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        final spans = parser.parse(
          '**Bold** and *italic* and ~~strike~~ and `code`',
          mockContext,
          const TextStyle(),
        );

        expect(
          spans.length,
          7,
        ); // 4 formatted segments + 3 plain "and " segments

        // Verify styles
        expect((spans.first as TextSpan).style?.fontWeight, FontWeight.bold);
        expect((spans[2] as TextSpan).style?.fontStyle, FontStyle.italic);
        expect(
          (spans[4] as TextSpan).style?.decoration,
          TextDecoration.lineThrough,
        );
        expect((spans[6] as TextSpan).style?.fontFamily, 'monospace');
      });

      testWidgets('complex formatting combinations work', (tester) async {
        await tester.pumpWidget(buildTestWidget(tester, (context) => Container()));
        const complex = 'Normal **bold _italic bold_ back to bold** normal *italic* end';
        final spans = parser.parse(complex, mockContext, const TextStyle());

        // Manually verify a few key spans
        bool hasBoldItalic = false;
        bool hasRegularItalic = false;

        for (final span in spans) {
          if (span is TextSpan) {
            // Check for bold+italic
            if (span.style?.fontWeight == FontWeight.bold && span.style?.fontStyle == FontStyle.italic) {
              hasBoldItalic = true;
            }

            // Check for just italic (not bold)
            if (span.style?.fontStyle == FontStyle.italic && span.style?.fontWeight != FontWeight.bold) {
              hasRegularItalic = true;
            }
          }
        }

        expect(hasBoldItalic, true);
        expect(hasRegularItalic, true);
      });
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/parser_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/tokenizer_test.dart -->
// ignore_for_file: no-magic-number

import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/models/token_type.dart';
import 'package:textf/src/parsing/textf_tokenizer.dart';

void main() {
  group('Tokenizer Tests', () {
    // ignore: avoid-late-keyword
    late TextfTokenizer tokenizer;

    setUp(() {
      tokenizer = TextfTokenizer();
    });

    group('Basic Tokenization', () {
      test('Empty text returns empty list', () {
        final tokens = tokenizer.tokenize('');
        expect(tokens, isEmpty);
      });

      test('Plain text returns single text token', () {
        final tokens = tokenizer.tokenize('plain text');
        expect(tokens.length, 1);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value, 'plain text');
        expect(tokens.first.position, 0);
        expect(tokens.first.length, 10);
      });

      test('Whitespace-only text returns single text token', () {
        final tokens = tokenizer.tokenize('   \t\n');
        expect(tokens.length, 1);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value, '   \t\n');
      });
    });

    group('Bold Formatting', () {
      test('Bold text with asterisks', () {
        final tokens = tokenizer.tokenize('This is **bold** text');
        expect(tokens.length, 5);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value, 'This is ');
        expect(tokens[1].type, TokenType.boldMarker);
        expect(tokens[1].value, '**');
        expect(tokens[2].type, TokenType.text);
        expect(tokens[2].value, 'bold');
        expect(tokens[3].type, TokenType.boldMarker);
        expect(tokens[3].value, '**');
        expect(tokens[4].type, TokenType.text);
        expect(tokens[4].value, ' text');
      });

      test('Bold text with underscores', () {
        final tokens = tokenizer.tokenize('This is __bold__ text');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.boldMarker);
        expect(tokens[1].value, '__');
        expect(tokens[3].type, TokenType.boldMarker);
        expect(tokens[3].value, '__');
      });

      test('Bold marker at beginning of text', () {
        final tokens = tokenizer.tokenize('**Bold** at start');
        expect(tokens.length, 4);
        expect(tokens.first.type, TokenType.boldMarker);
        expect(tokens.first.value, '**');
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, 'Bold');
      });

      test('Bold marker at end of text', () {
        final tokens = tokenizer.tokenize('End with **bold**');
        expect(tokens.length, 4);
        expect(tokens[2].type, TokenType.text);
        expect(tokens[2].value, 'bold');
        expect(tokens[3].type, TokenType.boldMarker);
        expect(tokens[3].value, '**');
      });
    });

    group('Italic Formatting', () {
      test('Italic text with asterisks', () {
        final tokens = tokenizer.tokenize('This is *italic* text');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.italicMarker);
        expect(tokens[1].value, '*');
        expect(tokens[3].type, TokenType.italicMarker);
        expect(tokens[3].value, '*');
      });

      test('Italic text with underscores', () {
        final tokens = tokenizer.tokenize('This is _italic_ text');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.italicMarker);
        expect(tokens[1].value, '_');
        expect(tokens[3].type, TokenType.italicMarker);
        expect(tokens[3].value, '_');
      });

      test('Italic marker at beginning of text', () {
        final tokens = tokenizer.tokenize('*Italic* at start');
        expect(tokens.length, 4);
        expect(tokens.first.type, TokenType.italicMarker);
        expect(tokens.first.value, '*');
      });

      test('Italic marker at end of text', () {
        final tokens = tokenizer.tokenize('End with _italic_');
        expect(tokens.length, 4);
        expect(tokens[3].type, TokenType.italicMarker);
        expect(tokens[3].value, '_');
      });
    });

    group('Bold-Italic Formatting', () {
      test('Bold-italic text with asterisks', () {
        final tokens = tokenizer.tokenize('This is ***bold-italic*** text');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.boldItalicMarker);
        expect(tokens[1].value, '***');
        expect(tokens[3].type, TokenType.boldItalicMarker);
        expect(tokens[3].value, '***');
      });

      test('Bold-italic text with underscores', () {
        final tokens = tokenizer.tokenize('This is ___bold-italic___ text');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.boldItalicMarker);
        expect(tokens[1].value, '___');
        expect(tokens[3].type, TokenType.boldItalicMarker);
        expect(tokens[3].value, '___');
      });
    });

    group('Strikethrough Formatting', () {
      test('Strikethrough text', () {
        final tokens = tokenizer.tokenize('This is ~~strikethrough~~ text');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.strikeMarker);
        expect(tokens[1].value, '~~');
        expect(tokens[3].type, TokenType.strikeMarker);
        expect(tokens[3].value, '~~');
      });

      test('Single tilde is not recognized as strikethrough', () {
        final tokens = tokenizer.tokenize('This is ~not strikethrough~ text');
        expect(tokens.length, 1);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value, 'This is ~not strikethrough~ text');
      });
    });

    group('Code Formatting', () {
      test('Inline code', () {
        final tokens = tokenizer.tokenize('This is `code` text');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.codeMarker);
        expect(tokens[1].value, '`');
        expect(tokens[3].type, TokenType.codeMarker);
        expect(tokens[3].value, '`');
      });

      test('Code with internal backticks is correctly tokenized', () {
        final tokens = tokenizer.tokenize(r'This `code has \` character` inside');
        // The tokenizer just identifies the markers, it doesn't validate pairing
        expect(tokens.length, 7);
        expect(tokens[1].type, TokenType.codeMarker);
        expect(tokens[3].type, TokenType.text);
        expect(tokens[4].value, ' character');
        expect(tokens[5].type, TokenType.codeMarker);
      });
    });

    group('Escape Sequences', () {
      test('Escaped asterisk', () {
        final tokens = tokenizer.tokenize(r'This is \*not italic\*');
        expect(tokens.length, 4);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value, 'This is ');
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, '*');
        expect(tokens[2].type, TokenType.text);
        expect(tokens[2].value, 'not italic');
        expect(tokens[3].type, TokenType.text);
        expect(tokens[3].value, '*');
      });

      test('Escaped underscore', () {
        final tokens = tokenizer.tokenize(r'This is \_not italic\_');
        expect(tokens.length, 4);
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, '_');
        expect(tokens[3].type, TokenType.text);
        expect(tokens[3].value, '_');
      });

      test('Escaped tilde', () {
        final tokens = tokenizer.tokenize(r'This is \~not tilde\~');
        expect(tokens.length, 4);
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, '~');
        expect(tokens[3].type, TokenType.text);
        expect(tokens[3].value, '~');
      });

      test('Escaped backtick', () {
        final tokens = tokenizer.tokenize(r'This is \`not code\`');
        expect(tokens.length, 4);
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, '`');
        expect(tokens[3].type, TokenType.text);
        expect(tokens[3].value, '`');
      });

      test('Escaped backslash', () {
        final tokens = tokenizer.tokenize(r'This is \\backslash');
        expect(tokens.length, 3);
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, r'\');
      });

      test('Multiple escaped characters', () {
        final tokens = tokenizer.tokenize(r'This has \*\*\* many escapes');
        expect(tokens.length, 5);
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, '*');
        expect(tokens[2].type, TokenType.text);
        expect(tokens[2].value, '*');
        expect(tokens[3].type, TokenType.text);
        expect(tokens[3].value, '*');
      });

      test('Escape followed by non-special character is treated literally', () {
        final tokens = tokenizer.tokenize(r'This has \a normal character');
        expect(tokens.length, 1);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value, r'This has \a normal character');
      });

      test('Escape at end of string is preserved', () {
        final tokens = tokenizer.tokenize(r'Text ending with backslash \');
        expect(tokens.length, 1);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value, r'Text ending with backslash \');
      });
    });

    group('Nested Formatting Markers', () {
      test('Bold with nested italic using different marker types', () {
        final tokens = tokenizer.tokenize('**Bold with _nested italic_**');
        expect(tokens.length, 6);
        expect(tokens.first.type, TokenType.boldMarker);
        expect(tokens.first.value, '**');
        expect(tokens[1].type, TokenType.text);
        expect(tokens[1].value, 'Bold with ');
        expect(tokens[2].type, TokenType.italicMarker);
        expect(tokens[2].value, '_');
        expect(tokens[3].type, TokenType.text);
        expect(tokens[3].value, 'nested italic');
        expect(tokens[4].type, TokenType.italicMarker);
        expect(tokens[4].value, '_');
        expect(tokens[5].type, TokenType.boldMarker);
        expect(tokens[5].value, '**');
      });

      test('Bold with nested italic using same marker type (fails)', () {
        final tokens = tokenizer.tokenize('**Bold with *nested italic***');
        // Document the expected behavior for the non-working case
        expect(tokens.length, 5);
        // The tokenizer still identifies all markers, but the parser
        // will struggle with proper nesting when using same marker type
      });
    });

    group('Complex Scenarios', () {
      test('Multiple formats in one text', () {
        final tokens = tokenizer.tokenize('**Bold** and *italic* and `code` and ~~strike~~');
        expect(tokens.length, 15);

        // Check each formatting type appears
        final tokenTypes = tokens.map((t) => t.type).toList();
        expect(tokenTypes.contains(TokenType.boldMarker), true);
        expect(tokenTypes.contains(TokenType.italicMarker), true);
        expect(tokenTypes.contains(TokenType.codeMarker), true);
        expect(tokenTypes.contains(TokenType.strikeMarker), true);
      });

      test('Adjacent markers', () {
        final tokens = tokenizer.tokenize('**Bold**_Italic_');
        expect(tokens.length, 6);
        expect(tokens.first.type, TokenType.boldMarker);
        expect(tokens[2].type, TokenType.boldMarker);
        expect(tokens[3].type, TokenType.italicMarker);
        expect(tokens[5].type, TokenType.italicMarker);
      });

      test('Mixed markers with whitespace', () {
        final tokens = tokenizer.tokenize('** Bold** *Italic * ~~Strike ~~ `Code`');
        expect(tokens.length, 15);
      });

      test('Potential nested formatting (tokenizer handles without validation)', () {
        final tokens = tokenizer.tokenize('**Bold with _nested italic_**');
        expect(tokens.length, 6);
        expect(tokens.first.type, TokenType.boldMarker);
        expect(tokens[2].type, TokenType.italicMarker);
        expect(tokens[4].type, TokenType.italicMarker);
        expect(tokens[5].type, TokenType.boldMarker);
      });

      test('Unmatched opening markers', () {
        final tokens = tokenizer.tokenize('This **is unmatched');
        expect(tokens.length, 3);
        expect(tokens[1].type, TokenType.boldMarker);
        expect(tokens[1].value, '**');
      });

      test('Unmatched closing markers', () {
        final tokens = tokenizer.tokenize('This is unmatched**');
        expect(tokens.length, 2);
        expect(tokens[1].type, TokenType.boldMarker);
        expect(tokens[1].value, '**');
      });
    });

    group('Edge Cases', () {
      test('Unicode characters', () {
        final tokens = tokenizer.tokenize('Unicode: **‰Ω†Â•Ω** and *Ë°®ÊÉÖÁ¨¶Âè∑* ~~Âà†Èô§Á∫ø~~');
        expect(tokens.length, 12);
        expect(tokens[2].type, TokenType.text);
        expect(tokens[2].value, '‰Ω†Â•Ω');
      });

      test('Emoji', () {
        final tokens = tokenizer.tokenize('Emoji: **üòÄ** and *üåç* ~~üö´~~');
        expect(tokens.length, 12);
        expect(tokens[2].type, TokenType.text);
        expect(tokens[2].value, 'üòÄ');
      });

      test('Line breaks', () {
        final tokens = tokenizer.tokenize('Line\nbreak with **bold**\nformatting');
        expect(tokens.length, 5);
      });

      test('Tabs and special whitespace', () {
        final tokens = tokenizer.tokenize('Tab\t**bold**\tand space');
        expect(tokens.length, 5);
      });

      test('Single asterisk/underscore in text (not formatting)', () {
        final tokens = tokenizer.tokenize(
          'This * is not formatting and neither is this _ character',
        );
        expect(tokens.length, 5);
        expect(tokens.first.type, TokenType.text);
        expect(tokens[1].type, TokenType.italicMarker);
        expect(tokens[3].type, TokenType.italicMarker);
      });

      test('Very long input with no formatting', () {
        final longText = 'A' * 10000;
        final tokens = tokenizer.tokenize(longText);
        expect(tokens.length, 1);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value.length, 10000);
      });

      test('Very long input with formatting', () {
        final longPrefix = 'A' * 5000;
        final longSuffix = 'B' * 5000;
        final tokens = tokenizer.tokenize('$longPrefix**bold**$longSuffix');
        expect(tokens.length, 5);
        expect(tokens.first.type, TokenType.text);
        expect(tokens.first.value.length, 5000);
        expect(tokens[4].type, TokenType.text);
        expect(tokens[4].value.length, 5000);
      });
    });

    group('Performance Concerns', () {
      test('Many formatting markers', () {
        final manyMarkers = List.generate(100, (i) => '**bold$i**').join(' ');
        final tokens = tokenizer.tokenize(manyMarkers);
        expect(
          tokens.length,
          399,
        ); // 200 (100 pairs) of markers + 100 text segments + 99 spaces
      });

      test('Alternating character formatting', () {
        // This is a pathological case: b*o*l*d* (every character has a marker)
        final text = List.generate(100, (i) => '${String.fromCharCode(i + 97)}*').join();
        final tokens = tokenizer.tokenize(text);
        expect(tokens.length > 100, true);
      });
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/tokenizer_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/core/default_styles_test.dart -->
// ignore_for_file: no-magic-number

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/core/default_styles.dart';

void main() {
  group('DefaultStyles Tests', () {
    const baseStyle = TextStyle(fontSize: 16, color: Colors.blue, fontFamily: 'Roboto');

    group('boldStyle', () {
      test('applies bold font weight and preserves other properties', () {
        final newStyle = DefaultStyles.boldStyle(baseStyle);
        expect(newStyle.fontWeight, FontWeight.bold);
        expect(newStyle.fontSize, baseStyle.fontSize);
        expect(newStyle.color, baseStyle.color);
      });
    });

    group('italicStyle', () {
      test('applies italic font style and preserves other properties', () {
        final newStyle = DefaultStyles.italicStyle(baseStyle);
        expect(newStyle.fontStyle, FontStyle.italic);
        expect(newStyle.fontSize, baseStyle.fontSize);
        expect(newStyle.color, baseStyle.color);
      });
    });

    group('boldItalicStyle', () {
      test('applies both bold and italic and preserves other properties', () {
        final newStyle = DefaultStyles.boldItalicStyle(baseStyle);
        expect(newStyle.fontWeight, FontWeight.bold);
        expect(newStyle.fontStyle, FontStyle.italic);
        expect(newStyle.fontSize, baseStyle.fontSize);
        expect(newStyle.color, baseStyle.color);
      });
    });

    group('highlightStyle', () {
      test('applies highlight for a light theme color', () {
        const lightBaseStyle = TextStyle(color: Colors.black);
        final newStyle = DefaultStyles.highlightStyle(lightBaseStyle);
        expect(newStyle.backgroundColor, isNotNull);
        expect(newStyle.color, lightBaseStyle.color); // Should preserve text color
      });

      test('applies highlight for a dark theme color', () {
        const darkBaseStyle = TextStyle(color: Colors.white);
        final newStyle = DefaultStyles.highlightStyle(darkBaseStyle);
        expect(newStyle.backgroundColor, isNotNull);
        expect(newStyle.color, darkBaseStyle.color); // Should preserve text color
      });
    });

    group('strikethroughStyle', () {
      test('applies strikethrough to a style with no existing decoration', () {
        final newStyle = DefaultStyles.strikethroughStyle(baseStyle);
        expect(newStyle.decoration, TextDecoration.lineThrough);
        expect(newStyle.decorationThickness, DefaultStyles.defaultStrikethroughThickness);
      });

      test('combines strikethrough with an existing decoration', () {
        const styleWithUnderline = TextStyle(decoration: TextDecoration.underline);
        final newStyle = DefaultStyles.strikethroughStyle(styleWithUnderline);
        expect(
          newStyle.decoration,
          TextDecoration.combine([
            TextDecoration.underline,
            TextDecoration.lineThrough,
          ]),
        );
      });

      test('does not re-combine if strikethrough already exists', () {
        const styleWithStrikethrough = TextStyle(decoration: TextDecoration.lineThrough);
        final newStyle = DefaultStyles.strikethroughStyle(styleWithStrikethrough);
        expect(newStyle.decoration, TextDecoration.lineThrough);
      });

      test('uses decorationColor from baseStyle if available', () {
        const styleWithDecoColor = TextStyle(decorationColor: Colors.red);
        final newStyle = DefaultStyles.strikethroughStyle(styleWithDecoColor);
        expect(newStyle.decorationColor, Colors.red);
      });

      test('falls back to base color for decorationColor if decorationColor is null', () {
        const styleWithColor = TextStyle(color: Colors.green);
        final newStyle = DefaultStyles.strikethroughStyle(styleWithColor);
        expect(newStyle.decorationColor, Colors.green);
      });

      test('applies specified thickness', () {
        final newStyle = DefaultStyles.strikethroughStyle(baseStyle, thickness: 3);
        expect(newStyle.decorationThickness, 3.0);
      });
    });

    group('underlineStyle', () {
      test('applies underline to a style with no existing decoration', () {
        final newStyle = DefaultStyles.underlineStyle(baseStyle);
        expect(newStyle.decoration, TextDecoration.underline);
      });

      test('combines underline with an existing decoration', () {
        const styleWithStrikethrough = TextStyle(decoration: TextDecoration.lineThrough);
        final newStyle = DefaultStyles.underlineStyle(styleWithStrikethrough);
        expect(
          newStyle.decoration,
          TextDecoration.combine([
            TextDecoration.lineThrough,
            TextDecoration.underline,
          ]),
        );
      });

      test('does not re-combine if underline already exists', () {
        const styleWithUnderline = TextStyle(decoration: TextDecoration.underline);
        final newStyle = DefaultStyles.underlineStyle(styleWithUnderline);
        expect(newStyle.decoration, TextDecoration.underline);
      });

      test('uses decorationColor from baseStyle if available', () {
        const styleWithDecoColor = TextStyle(decorationColor: Colors.red);
        final newStyle = DefaultStyles.underlineStyle(styleWithDecoColor);
        expect(newStyle.decorationColor, Colors.red);
      });

      test('falls back to base color for decorationColor if decorationColor is null', () {
        const styleWithColor = TextStyle(color: Colors.green);
        final newStyle = DefaultStyles.underlineStyle(styleWithColor);
        expect(newStyle.decorationColor, Colors.green);
      });

      test('uses decorationThickness from baseStyle if available', () {
        const styleWithDecoThickness = TextStyle(decorationThickness: 2.5);
        final newStyle = DefaultStyles.underlineStyle(styleWithDecoThickness);
        expect(newStyle.decorationThickness, 2.5);
      });
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/core/default_styles_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/core/formatting_utils_test.dart -->
// ignore_for_file: cascade_invocations // cascade_invocations for readability and chaining methods.

import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/core/formatting_utils.dart';

void main() {
  group('FormattingUtils Tests', () {
    group('hasFormatting', () {
      // Test cases for characters that should return true.
      final Map<String, String> positiveCases = {
        'asterisk': 'an *italic* example',
        'underscore': 'an _italic_ example',
        'tilde': 'a ~~strike~~ example',
        'backtick': 'some `code` example',
        'equals': 'a ==highlight== example',
        'plus': 'an ++underline++ example',
        'escape': r'an \escaped char',
        'open bracket': 'a [link] example',
        'close bracket': 'a [link] example',
        'open paren': 'a link (url)',
        'close paren': 'a link (url)',
      };

      positiveCases.forEach((description, text) {
        test('should return true for strings containing: $description', () {
          expect(FormattingUtils.hasFormatting(text), isTrue);
        });
      });

      test('should return false for strings without any formatting characters', () {
        const plainText = 'This is just a regular sentence.';
        expect(FormattingUtils.hasFormatting(plainText), isFalse);
      });

      test('should return false for an empty string', () {
        const emptyText = '';
        expect(FormattingUtils.hasFormatting(emptyText), isFalse);
      });
    });

    group('hasFormattingMarkers', () {
      // Test cases for characters that should return true.
      final Map<String, String> positiveCases = {
        'asterisk': 'an *italic* example',
        'underscore': 'an _italic_ example',
        'tilde': 'a ~~strike~~ example',
        'backtick': 'some `code` example',
        'equals': 'a ==highlight== example',
        'plus': 'an ++underline++ example',
        'escape': r'an \escaped char',
      };

      positiveCases.forEach((description, text) {
        test('should return true for strings containing styling marker: $description', () {
          expect(FormattingUtils.hasFormattingMarkers(text), isTrue);
        });
      });

      test('should return false for strings with only link syntax characters', () {
        const linkSyntaxOnly = 'This is text with [brackets] and (parens)';
        expect(
          FormattingUtils.hasFormattingMarkers(linkSyntaxOnly),
          isFalse,
          reason: 'Brackets and parentheses are not considered styling markers.',
        );
      });

      test('should return false for strings without any styling markers', () {
        const plainText = 'This is just a regular sentence.';
        expect(FormattingUtils.hasFormattingMarkers(plainText), isFalse);
      });

      test('should return false for an empty string', () {
        const emptyText = '';
        expect(FormattingUtils.hasFormattingMarkers(emptyText), isFalse);
      });
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/core/formatting_utils_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/models/parser_state_test.dart -->
// ignore_for_file: cascade_invocations // cascade_invocations for readability and chaining methods.
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/models/format_stack_entry.dart';
import 'package:textf/src/models/parser_state.dart';
import 'package:textf/src/models/token_type.dart';
import 'package:textf/src/styling/textf_style_resolver.dart';

// ---- Mock class for TextfStyleResolver ----
// This class simulates the behavior of the real resolver, allowing us to
// test ParserState in isolation. We can tell it which TextStyle to return
// for a given TokenType.
// ignore: prefer-match-file-name
class _MockTextfStyleResolver implements TextfStyleResolver {
  _MockTextfStyleResolver(this.context);
  // Ignore the unused 'context' field, as it's not needed for the mock.
  // ignore: unused_field
  @override
  final BuildContext context;

  final Map<TokenType, TextStyle> _styleMap = {};

  // A method to configure the mock for a specific test.
  void whenResolveStyle(TokenType type, TextStyle styleToReturn) {
    _styleMap[type] = styleToReturn;
  }

  @override
  TextStyle resolveStyle(TokenType type, TextStyle baseStyle) {
    final style = _styleMap[type];
    if (style != null) {
      // Simulate the real resolver's behavior: the option style is
      // merged onto the base style.
      return baseStyle.merge(style);
    }
    // If no style is configured, just return the base style.
    return baseStyle;
  }

  // The remaining methods are not needed for this test and can be
  // implemented with an exception to ensure they are not accidentally called.
  @override
  TextStyle resolveLinkStyle(TextStyle baseStyle) => throw UnimplementedError();
  @override
  TextStyle resolveLinkHoverStyle(TextStyle baseStyle) => throw UnimplementedError();
  @override
  MouseCursor resolveLinkMouseCursor() => throw UnimplementedError();
  @override
  void Function(String url, String displayText)? resolveOnUrlTap() => throw UnimplementedError();
  @override
  void Function(String url, String displayText, {required bool isHovering})? resolveOnUrlHover() =>
      throw UnimplementedError();
}

void main() {
  const baseStyle = TextStyle(fontSize: 16, color: Colors.black);

  // Helper function to set up a valid BuildContext and mock resolver for each test.
  // It takes the `tester` from `testWidgets` to ensure it runs in a valid environment.
  Future<(BuildContext, _MockTextfStyleResolver)> setupTest(WidgetTester tester) async {
    // ignore: avoid-late-keyword
    late BuildContext mockContext;
    await tester.pumpWidget(
      MaterialApp(
        home: Builder(
          builder: (context) {
            mockContext = context;
            return const SizedBox.shrink();
          },
        ),
      ),
    );
    final mockResolver = _MockTextfStyleResolver(mockContext);
    return (mockContext, mockResolver);
  }

  group('ParserState Tests', () {
    testWidgets('flushText does nothing when textBuffer is empty', (tester) async {
      // ARRANGE
      final (mockContext, mockResolver) = await setupTest(tester);
      final state = ParserState(
        tokens: [],
        baseStyle: baseStyle,
        matchingPairs: {},
        styleResolver: mockResolver,
      );

      // ACT
      state.flushText(mockContext);

      // ASSERT
      expect(state.spans, isEmpty, reason: 'Spans list should remain empty');
      expect(state.textBuffer, isEmpty, reason: 'Text buffer should still be empty');
    });

    testWidgets('flushText creates a simple TextSpan with baseStyle when formatStack is empty', (tester) async {
      // ARRANGE
      final (mockContext, mockResolver) = await setupTest(tester);
      final state = ParserState(
        tokens: [],
        baseStyle: baseStyle,
        matchingPairs: {},
        styleResolver: mockResolver,
      );
      state.textBuffer = 'Plain text';

      // ACT
      state.flushText(mockContext);

      // ASSERT
      expect(state.spans, hasLength(1), reason: 'One span should be created');
      final span = state.spans.first as TextSpan;
      expect(span.text, 'Plain text');
      expect(span.style, baseStyle, reason: 'The style should be the baseStyle');
      expect(state.textBuffer, isEmpty, reason: 'Text buffer should be cleared after flushing');
    });

    testWidgets('flushText applies a single style from the formatStack', (tester) async {
      // ARRANGE
      final (mockContext, mockResolver) = await setupTest(tester);

      // Configure the mock to return a bold style for boldMarker.
      const boldStyle = TextStyle(fontWeight: FontWeight.bold);
      mockResolver.whenResolveStyle(TokenType.boldMarker, boldStyle);

      final state = ParserState(
        tokens: [],
        baseStyle: baseStyle,
        matchingPairs: {},
        styleResolver: mockResolver,
      );
      state.textBuffer = 'Bold text';
      state.formatStack.add(
        const FormatStackEntry(index: 0, matchingIndex: 1, type: TokenType.boldMarker),
      );

      // ACT
      state.flushText(mockContext);

      // ASSERT
      expect(state.spans, hasLength(1));
      final span = state.spans.first as TextSpan;
      expect(span.text, 'Bold text');
      // The style should have the base properties plus the merged properties.
      expect(span.style?.fontWeight, FontWeight.bold);
      expect(span.style?.fontSize, baseStyle.fontSize, reason: 'Font size from base style should be preserved');
      expect(span.style?.color, baseStyle.color, reason: 'Color from base style should be preserved');
      expect(state.textBuffer, isEmpty);
    });

    testWidgets('flushText correctly applies multiple nested styles from the formatStack', (tester) async {
      // ARRANGE
      final (mockContext, mockResolver) = await setupTest(tester);
      const boldStyle = TextStyle(fontWeight: FontWeight.bold);
      const italicStyle = TextStyle(fontStyle: FontStyle.italic, color: Colors.red); // Overrides color
      mockResolver.whenResolveStyle(TokenType.boldMarker, boldStyle);
      mockResolver.whenResolveStyle(TokenType.italicMarker, italicStyle);

      final state = ParserState(
        tokens: [],
        baseStyle: baseStyle, // Black text
        matchingPairs: {},
        styleResolver: mockResolver,
      );
      state.textBuffer = 'Nested style';
      // Simulate a nested state: **_Text_**
      state.formatStack.add(
        const FormatStackEntry(index: 0, matchingIndex: 3, type: TokenType.boldMarker),
      );
      state.formatStack.add(
        const FormatStackEntry(index: 1, matchingIndex: 2, type: TokenType.italicMarker),
      );

      // ACT
      state.flushText(mockContext);

      // ASSERT
      expect(state.spans, hasLength(1));
      final span = state.spans.first as TextSpan;
      expect(span.text, 'Nested style');

      // Check if all styles were applied correctly.
      // The order of application in `flushText` is important.
      expect(span.style?.fontWeight, FontWeight.bold, reason: 'Bold style should be applied');
      expect(span.style?.fontStyle, FontStyle.italic, reason: 'Italic style should be applied');
      expect(span.style?.color, Colors.red, reason: 'Italic style color should override base and bold color');
      expect(span.style?.fontSize, baseStyle.fontSize, reason: 'Font size should be inherited from base');
      expect(state.textBuffer, isEmpty);
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/models/parser_state_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/styling/style_resolver_test.dart -->
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/core/default_styles.dart';
import 'package:textf/src/models/token_type.dart';
import 'package:textf/src/styling/textf_style_resolver.dart';
import 'package:textf/src/widgets/textf_options.dart';

void main() {
  // Ensure Flutter bindings are initialized for ThemeData access.
  setUpAll(TestWidgetsFlutterBinding.ensureInitialized);

  group('TextfStyleResolver Tests', () {
    // A base style to be used in tests.
    const TextStyle baseStyle = TextStyle(
      fontSize: 16,
      color: Colors.black,
      fontFamily: 'Roboto',
      decoration: TextDecoration.none, // Explicitly none for easier testing
    );

    // A common light theme for consistent testing of theme-based defaults.
    final ThemeData lightTheme = ThemeData.light();

    // Helper to build a widget tree with a Builder to capture context.
    // Optionally wraps the Builder with TextfOptions.
    Future<BuildContext> pumpWithContext(
      WidgetTester tester, {
      TextfOptions? options,
      TextfOptions? parentOptions,
    }) async {
      // ignore: avoid-late-keyword
      late BuildContext capturedContext;
      Widget child = Builder(
        builder: (context) {
          capturedContext = context;
          return const SizedBox.shrink();
        },
      );

      // Apply inner options first if they exist
      if (options != null) {
        child = TextfOptions(
          key: options.key,
          boldStyle: options.boldStyle,
          italicStyle: options.italicStyle,
          boldItalicStyle: options.boldItalicStyle,
          strikethroughStyle: options.strikethroughStyle,
          strikethroughThickness: options.strikethroughThickness,
          codeStyle: options.codeStyle,
          underlineStyle: options.underlineStyle,
          highlightStyle: options.highlightStyle,
          urlStyle: options.urlStyle,
          urlHoverStyle: options.urlHoverStyle,
          urlMouseCursor: options.urlMouseCursor,
          onUrlTap: options.onUrlTap,
          onUrlHover: options.onUrlHover,
          child: child,
        );
      }

      // Then wrap with parent options if they exist
      if (parentOptions != null) {
        child = TextfOptions(
          key: parentOptions.key,
          boldStyle: parentOptions.boldStyle,
          italicStyle: parentOptions.italicStyle,
          boldItalicStyle: parentOptions.boldItalicStyle,
          strikethroughStyle: parentOptions.strikethroughStyle,
          strikethroughThickness: parentOptions.strikethroughThickness,
          codeStyle: parentOptions.codeStyle,
          underlineStyle: parentOptions.underlineStyle,
          highlightStyle: parentOptions.highlightStyle,
          urlStyle: parentOptions.urlStyle,
          urlHoverStyle: parentOptions.urlHoverStyle,
          urlMouseCursor: parentOptions.urlMouseCursor,
          onUrlTap: parentOptions.onUrlTap,
          onUrlHover: parentOptions.onUrlHover,
          child: child,
        );
      }

      await tester.pumpWidget(
        MaterialApp(
          theme: lightTheme, // Use the consistent lightTheme
          home: child,
        ),
      );
      return capturedContext;
    }

    group('No TextfOptions (Fallback to Defaults)', () {
      // ignore: avoid-late-keyword
      late BuildContext testContext;
      // ignore: avoid-late-keyword
      late TextfStyleResolver resolver;

      // setUp needs to be called within testWidgets or use a helper that takes tester
      // For simplicity, we'll get context and resolver inside each testWidgets.

      testWidgets('Initializes correctly and resolver can be created', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        expect(resolver, isNotNull);
      });

      testWidgets('resolveStyle for boldMarker uses DefaultStyles.boldStyle', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveStyle(TokenType.boldMarker, baseStyle);
        expect(resolved.fontWeight, FontWeight.bold);
        expect(resolved.fontSize, baseStyle.fontSize);
        expect(resolved.color, baseStyle.color);
      });

      testWidgets('resolveStyle for italicMarker uses DefaultStyles.italicStyle', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveStyle(TokenType.italicMarker, baseStyle);
        expect(resolved.fontStyle, FontStyle.italic);
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveStyle for boldItalicMarker uses DefaultStyles.boldItalicStyle', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveStyle(TokenType.boldItalicMarker, baseStyle);
        expect(resolved.fontWeight, FontWeight.bold);
        expect(resolved.fontStyle, FontStyle.italic);
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveStyle for strikeMarker uses DefaultStyles.strikethroughStyle with default thickness',
          (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveStyle(TokenType.strikeMarker, baseStyle);
        expect(resolved.decoration, TextDecoration.lineThrough);
        expect(resolved.decorationThickness, DefaultStyles.defaultStrikethroughThickness);
        expect(resolved.decorationColor, baseStyle.color); // Inherits base color for decoration
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveStyle for codeMarker uses theme-based default', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveStyle(TokenType.codeMarker, baseStyle);
        expect(resolved.fontFamily, 'monospace');
        expect(resolved.fontFamilyFallback, DefaultStyles.defaultCodeFontFamilyFallback);
        expect(resolved.backgroundColor, lightTheme.colorScheme.surfaceContainer);
        expect(resolved.color, lightTheme.colorScheme.onSurfaceVariant); // Theme color for text
        expect(resolved.fontSize, baseStyle.fontSize); // Base font size
      });

      testWidgets('resolveStyle for underlineMarker uses DefaultStyles.underlineStyle', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveStyle(TokenType.underlineMarker, baseStyle);
        expect(resolved.decoration, TextDecoration.underline);
        expect(resolved.decorationColor, baseStyle.color);
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveStyle for highlightMarker uses theme-based default', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveStyle(TokenType.highlightMarker, baseStyle);
        expect(resolved.backgroundColor, isNotNull);
        expect(resolved.backgroundColor, isNot(baseStyle.backgroundColor));
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveLinkStyle uses theme-based default', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolved = resolver.resolveLinkStyle(baseStyle);
        expect(resolved.color, lightTheme.colorScheme.primary);
        expect(resolved.decoration, TextDecoration.underline);
        expect(resolved.decorationColor, lightTheme.colorScheme.primary);
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveLinkHoverStyle defaults to normal link style', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        final resolvedNormal = resolver.resolveLinkStyle(baseStyle);
        final resolvedHover = resolver.resolveLinkHoverStyle(baseStyle);
        expect(resolvedHover, resolvedNormal);
      });

      testWidgets('resolveLinkMouseCursor uses DefaultStyles.urlMouseCursor', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        expect(resolver.resolveLinkMouseCursor(), DefaultStyles.urlMouseCursor);
      });

      testWidgets('resolveOnUrlTap returns null', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        expect(resolver.resolveOnUrlTap(), isNull);
      });

      testWidgets('resolveOnUrlHover returns null', (tester) async {
        testContext = await pumpWithContext(tester);
        resolver = TextfStyleResolver(testContext);
        expect(resolver.resolveOnUrlHover(), isNull);
      });
    });

    group('With TextfOptions (Single Level)', () {
      const optionBoldStyle = TextStyle(fontWeight: FontWeight.w900, color: Colors.red);
      const optionItalicStyle = TextStyle(fontStyle: FontStyle.normal, color: Colors.green);
      // CORRECTED: optionStrikeStyle now includes the decoration itself
      const optionStrikeStyle = TextStyle(
        decoration: TextDecoration.lineThrough, // Added this
        decorationColor: Colors.purple,
        decorationThickness: 3,
      );
      const optionStrikeThickness = 2.5;
      const optionCodeStyle = TextStyle(backgroundColor: Colors.grey, fontFamily: 'Courier');
      const optionUrlStyle = TextStyle(color: Colors.orange, decoration: TextDecoration.overline);
      const optionUrlHoverStyle = TextStyle(color: Colors.pink, letterSpacing: 2);
      const optionCursor = SystemMouseCursors.help;

      void testOnTap(String u, String d) {
        debugPrint('Tapped URL: $u with display text: $d');
      }

      void testOnHover(String u, String d, {required bool isHovering}) {
        debugPrint('Hovered URL: $u with display text: $d, isHovering: $isHovering');
      }

      final options = TextfOptions(
        boldStyle: optionBoldStyle,
        italicStyle: optionItalicStyle,
        strikethroughStyle: optionStrikeStyle,
        codeStyle: optionCodeStyle,
        urlStyle: optionUrlStyle,
        urlHoverStyle: optionUrlHoverStyle,
        urlMouseCursor: optionCursor,
        onUrlTap: testOnTap,
        onUrlHover: testOnHover,
        child: const SizedBox.shrink(),
      );

      testWidgets('resolveStyle for boldMarker uses TextfOptions', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        final resolved = resolverWithOptions.resolveStyle(TokenType.boldMarker, baseStyle);
        expect(resolved.fontWeight, optionBoldStyle.fontWeight);
        expect(resolved.color, optionBoldStyle.color);
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveStyle for italicMarker uses TextfOptions', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        final resolved = resolverWithOptions.resolveStyle(TokenType.italicMarker, baseStyle);
        expect(resolved.fontStyle, optionItalicStyle.fontStyle);
        expect(resolved.color, optionItalicStyle.color);
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveStyle for strikeMarker uses TextfOptions.strikethroughStyle', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        final resolved = resolverWithOptions.resolveStyle(TokenType.strikeMarker, baseStyle);
        // Now it should have the decoration from optionStrikeStyle
        expect(resolved.decoration, optionStrikeStyle.decoration); // CORRECTED EXPECTATION
        expect(resolved.decorationColor, optionStrikeStyle.decorationColor);
        expect(resolved.decorationThickness, optionStrikeStyle.decorationThickness);
      });

      testWidgets('resolveStyle for strikeMarker uses TextfOptions.strikethroughThickness if style is null',
          (tester) async {
        const optionsWithThickness = TextfOptions(
          strikethroughThickness: optionStrikeThickness,
          child: SizedBox.shrink(),
        );
        final context = await pumpWithContext(tester, options: optionsWithThickness);
        final resolver = TextfStyleResolver(context);

        final resolved = resolver.resolveStyle(TokenType.strikeMarker, baseStyle);
        expect(resolved.decoration, TextDecoration.lineThrough);
        expect(resolved.decorationThickness, optionStrikeThickness);
        expect(resolved.decorationColor, baseStyle.color);
      });

      testWidgets('resolveStyle for codeMarker uses TextfOptions', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        final resolved = resolverWithOptions.resolveStyle(TokenType.codeMarker, baseStyle);
        expect(resolved.backgroundColor, optionCodeStyle.backgroundColor);
        expect(resolved.fontFamily, optionCodeStyle.fontFamily);
        expect(resolved.color, baseStyle.color);
      });

      testWidgets('resolveLinkStyle uses TextfOptions', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        final resolved = resolverWithOptions.resolveLinkStyle(baseStyle);
        expect(resolved.color, optionUrlStyle.color);
        expect(resolved.decoration, optionUrlStyle.decoration);
        expect(resolved.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveLinkHoverStyle uses TextfOptions and merges onto normal style', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        final normalLinkStyleWithOptions = baseStyle.merge(optionUrlStyle);
        final resolvedHover = resolverWithOptions.resolveLinkHoverStyle(baseStyle);

        expect(resolvedHover.color, optionUrlHoverStyle.color);
        expect(resolvedHover.letterSpacing, optionUrlHoverStyle.letterSpacing);
        expect(resolvedHover.decoration, normalLinkStyleWithOptions.decoration);
        expect(resolvedHover.fontSize, baseStyle.fontSize);
      });

      testWidgets('resolveLinkMouseCursor uses TextfOptions', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        expect(resolverWithOptions.resolveLinkMouseCursor(), optionCursor);
      });

      testWidgets('resolveOnUrlTap uses TextfOptions', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        expect(resolverWithOptions.resolveOnUrlTap(), testOnTap);
      });

      testWidgets('resolveOnUrlHover uses TextfOptions', (tester) async {
        final testContextWithOptions = await pumpWithContext(tester, options: options);
        final resolverWithOptions = TextfStyleResolver(testContextWithOptions);
        expect(resolverWithOptions.resolveOnUrlHover(), testOnHover);
      });
    });

    group('With Nested TextfOptions', () {
      const parentBoldStyle = TextStyle(color: Colors.amber);
      // CORRECTED: parentUrlStyle now defines no color, so baseStyle or theme should provide it
      const parentUrlStyle = TextStyle(decoration: TextDecoration.none /* no color here */);
      void parentTap(String u, String d) {
        debugPrint('Parent tapped URL: $u with display text: $d');
      }

      const childBoldStyle = TextStyle(fontWeight: FontWeight.w300);
      const childItalicStyle = TextStyle(fontStyle: FontStyle.normal, color: Colors.teal);
      void childTap(String u, String d) {
        debugPrint('Child tapped URL: $u with display text: $d');
      }

      final parentOpts = TextfOptions(
        boldStyle: parentBoldStyle,
        urlStyle: parentUrlStyle,
        onUrlTap: parentTap,
        italicStyle: const TextStyle(color: Colors.cyan),
        child: const SizedBox.shrink(),
      );

      final childOptsWithOverride = TextfOptions(
        boldStyle: childBoldStyle,
        italicStyle: childItalicStyle,
        onUrlTap: childTap,
        child: const SizedBox.shrink(),
      );

      testWidgets('Nested options correctly merge with and override ancestor values', (tester) async {
        // SETUP:
        // parentOpts provides a red color for bold text.
        // childOptsWithOverride provides a light font weight for bold text.
        // The expected result is a MERGE of both.

        const parentBoldStyle = TextStyle(fontWeight: FontWeight.w900, color: Colors.red);
        const parentItalicStyle = TextStyle(fontStyle: FontStyle.italic, color: Colors.purple);
        void parentTap(String u, String d) {}

        const childBoldStyle = TextStyle(fontWeight: FontWeight.w300); // No color specified.
        const childItalicStyle = TextStyle(fontStyle: FontStyle.normal, backgroundColor: Colors.yellow);
        void childTap(String u, String d) {}

        final parentOpts = TextfOptions(
          boldStyle: parentBoldStyle,
          italicStyle: parentItalicStyle,
          onUrlTap: parentTap,
          child: const SizedBox.shrink(),
        );

        final childOptsWithOverride = TextfOptions(
          boldStyle: childBoldStyle,
          italicStyle: childItalicStyle,
          onUrlTap: childTap,
          child: const SizedBox.shrink(),
        );

        // ARRANGE: Pump the widget tree.
        final context = await pumpWithContext(
          tester,
          parentOptions: parentOpts,
          options: childOptsWithOverride,
        );
        final resolver = TextfStyleResolver(context);

        // --- ASSERT BOLD STYLE (MERGED) ---
        final resolvedBold = resolver.resolveStyle(TokenType.boldMarker, baseStyle);
        // The fontWeight should come from the child (it overrides the parent).
        expect(resolvedBold.fontWeight, childBoldStyle.fontWeight);
        // The color should be inherited from the parent (since the child didn't specify one).
        expect(
          resolvedBold.color,
          parentBoldStyle.color, // This is the key change in the test's expectation.
          reason: 'Color should be inherited from the parent TextfOptions.',
        );
        expect(resolvedBold.fontSize, baseStyle.fontSize); // Inherited from baseStyle.

        // --- ASSERT ITALIC STYLE (MERGED) ---
        final resolvedItalic = resolver.resolveStyle(TokenType.italicMarker, baseStyle);
        // It should have properties from both parent and child.
        expect(
          resolvedItalic.color,
          parentItalicStyle.color, // From parent.
          reason: 'Italic color should be inherited from parent.',
        );
        expect(
          resolvedItalic.backgroundColor,
          childItalicStyle.backgroundColor, // From child.
          reason: 'Italic background color should come from child.',
        );
        expect(
          resolvedItalic.fontStyle,
          childItalicStyle.fontStyle, // From child (overriding parent).
          reason: 'Italic fontStyle should be overridden by child.',
        );

        // --- ASSERT CALLBACK (NEAREST WINS) ---
        // Callbacks do not merge, so "nearest wins" logic is still correct here.
        expect(
          resolver.resolveOnUrlTap(),
          childTap,
          reason: 'Callback should be taken from the nearest (child) TextfOptions.',
        );
      });

      testWidgets('Falls back to ancestor if nearest option is null for a property', (tester) async {
        final context = await pumpWithContext(
          tester,
          parentOptions: parentOpts, // Outer (provides urlStyle, italicStyle from parentOpts)
          options: const TextfOptions(child: SizedBox.shrink()), // Inner (urlStyle is implicitly null)
        );
        final resolver = TextfStyleResolver(context);

        final resolvedUrl = resolver.resolveLinkStyle(baseStyle);
        expect(resolvedUrl.decoration, parentUrlStyle.decoration); // From parent
        // CORRECTED EXPECTATION: parentUrlStyle has no color, so it should be baseStyle.color
        // *IF* the theme fallback didn't kick in.
        // However, if an option for urlStyle exists (even without color), the theme fallback for color is NOT used.
        // The color comes from merging baseStyle with the optionStyle.
        expect(
          resolvedUrl.color,
          baseStyle.color,
          reason: "Color should be from baseStyle as parentUrlStyle didn't set it.",
        );

        final resolvedItalic = resolver.resolveStyle(TokenType.italicMarker, baseStyle);
        expect(resolvedItalic.color, Colors.cyan);
      });

      testWidgets('Falls back to theme/DefaultStyles if all ancestors have null', (tester) async {
        const specificOptionItalicStyle = TextStyle(fontStyle: FontStyle.italic, color: Colors.blueGrey);
        const parent = TextfOptions(boldStyle: parentBoldStyle, child: SizedBox.shrink());
        const child = TextfOptions(italicStyle: specificOptionItalicStyle, child: SizedBox.shrink());

        final context = await pumpWithContext(tester, parentOptions: parent, options: child);
        final resolver = TextfStyleResolver(context);

        final resolvedCode = resolver.resolveStyle(TokenType.codeMarker, baseStyle);
        expect(resolvedCode.fontFamily, 'monospace');
        expect(resolvedCode.backgroundColor, lightTheme.colorScheme.surfaceContainer);
        expect(resolvedCode.color, lightTheme.colorScheme.onSurfaceVariant);

        final resolvedHighlight = resolver.resolveStyle(TokenType.highlightMarker, baseStyle);
        expect(resolvedHighlight.backgroundColor, isNotNull);
      });
    });

    group('Style Merging Details', () {
      testWidgets('baseStyle properties are preserved if not overridden', (tester) async {
        const specificBaseStyle = TextStyle(
          fontSize: 20,
          fontFamily: 'Arial',
          letterSpacing: 1.5,
          color: Colors.deepPurple,
        );
        const options = TextfOptions(
          boldStyle: TextStyle(fontWeight: FontWeight.w900),
          child: SizedBox.shrink(),
        );
        final context = await pumpWithContext(tester, options: options);
        final resolver = TextfStyleResolver(context);

        final resolvedBold = resolver.resolveStyle(TokenType.boldMarker, specificBaseStyle);
        expect(resolvedBold.fontWeight, FontWeight.w900);
        expect(resolvedBold.fontSize, specificBaseStyle.fontSize);
        expect(resolvedBold.fontFamily, specificBaseStyle.fontFamily);
        expect(resolvedBold.letterSpacing, specificBaseStyle.letterSpacing);
        expect(resolvedBold.color, specificBaseStyle.color);
      });

      testWidgets('Option properties override baseStyle properties', (tester) async {
        const options = TextfOptions(
          boldStyle: TextStyle(fontWeight: FontWeight.w900, color: Colors.green),
          child: SizedBox.shrink(),
        );
        final context = await pumpWithContext(tester, options: options);
        final resolver = TextfStyleResolver(context);

        final resolvedBold = resolver.resolveStyle(TokenType.boldMarker, baseStyle);
        expect(resolvedBold.fontWeight, FontWeight.w900);
        expect(resolvedBold.color, Colors.green);
        expect(resolvedBold.fontSize, baseStyle.fontSize);
      });

      testWidgets('Theme-default properties override baseStyle properties for links and code', (tester) async {
        // No options, so link style and code style come from theme
        final context = await pumpWithContext(tester);
        final resolver = TextfStyleResolver(context);

        // Link
        final resolvedLink = resolver.resolveLinkStyle(baseStyle); // baseStyle is black
        expect(resolvedLink.color, lightTheme.colorScheme.primary, reason: 'Link color should be theme primary');
        expect(resolvedLink.decoration, TextDecoration.underline);
        expect(resolvedLink.fontSize, baseStyle.fontSize);

        // Code
        final resolvedCode = resolver.resolveStyle(TokenType.codeMarker, baseStyle); // baseStyle is black
        expect(
          resolvedCode.color,
          lightTheme.colorScheme.onSurfaceVariant,
          reason: 'Code color should be theme onSurfaceVariant',
        );
        expect(resolvedCode.backgroundColor, lightTheme.colorScheme.surfaceContainer);
        expect(resolvedCode.fontFamily, 'monospace');
        expect(resolvedCode.fontSize, baseStyle.fontSize);
      });

      testWidgets('Theme-default properties DO NOT override baseStyle for bold/italic if no option', (tester) async {
        // No options, so bold/italic come from DefaultStyles applied to baseStyle
        final context = await pumpWithContext(tester);
        final resolver = TextfStyleResolver(context);

        // Bold
        final resolvedBold = resolver.resolveStyle(TokenType.boldMarker, baseStyle); // baseStyle is black
        expect(resolvedBold.color, baseStyle.color, reason: 'Bold color should be from baseStyle'); // Not from theme
        expect(resolvedBold.fontWeight, FontWeight.bold);
        expect(resolvedBold.fontSize, baseStyle.fontSize);

        // Italic
        final resolvedItalic = resolver.resolveStyle(TokenType.italicMarker, baseStyle);
        expect(
          resolvedItalic.color,
          baseStyle.color,
          reason: 'Italic color should be from baseStyle',
        ); // Not from theme
        expect(resolvedItalic.fontStyle, FontStyle.italic);
        expect(resolvedItalic.fontSize, baseStyle.fontSize);
      });
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/styling/style_resolver_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/parsing/components/link_handler_test.dart -->
// test/unit/parsing/components/link_handler_test.dart

// ignore_for_file: no-magic-number

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/models/parser_state.dart';
import 'package:textf/src/parsing/components/link_handler.dart';
import 'package:textf/src/parsing/textf_tokenizer.dart';
import 'package:textf/src/styling/textf_style_resolver.dart';
import 'package:textf/src/widgets/internal/hoverable_link_span.dart';

// By using `extends`, we inherit the concrete implementation of TextfStyleResolver
// and only need to override the methods relevant to this test. This is the correct
// way to mock a concrete class.
// ignore: prefer-match-file-name
class _MockLinkStyleResolver extends TextfStyleResolver {
  // We must call the super constructor.
  _MockLinkStyleResolver(super.context);

  // Override only the methods needed to test the LinkHandler.
  // We want to control the output for link-related styles.
  @override
  TextStyle resolveLinkStyle(TextStyle baseStyle) {
    // Return a predictable, simple style for testing.
    return baseStyle.copyWith(
      color: Colors.blue,
      decoration: TextDecoration.underline,
    );
  }

  @override
  TextStyle resolveLinkHoverStyle(TextStyle baseStyle) {
    // Return a predictable hover style.
    return baseStyle.copyWith(
      color: Colors.red,
      decoration: TextDecoration.underline,
    );
  }

  @override
  MouseCursor resolveLinkMouseCursor() {
    // Return a predictable cursor.
    return SystemMouseCursors.click;
  }

  // For this test, tap and hover callbacks are not needed.
  @override
  void Function(String url, String displayText)? resolveOnUrlTap() => null;

  @override
  void Function(String url, String displayText, {required bool isHovering})? resolveOnUrlHover() => null;

  // We don't need to override `resolveStyle` because the LinkHandler
  // uses its own internal parser for nested content, but we could if needed.
}

void main() {
  group('LinkHandler Tests', () {
    // ignore: avoid-late-keyword
    late TextfTokenizer tokenizer;

    setUp(() {
      tokenizer = TextfTokenizer();
    });

    // Helper to create a valid test environment with context and a parser state.
    Future<ParserState> createParserState(
      WidgetTester tester,
      String text,
    ) async {
      // ignore: avoid-late-keyword
      late BuildContext buildContext;
      await tester.pumpWidget(
        MaterialApp(
          home: Builder(
            builder: (context) {
              buildContext = context;
              return const SizedBox();
            },
          ),
        ),
      );

      return ParserState(
        tokens: tokenizer.tokenize(text),
        baseStyle: const TextStyle(),
        matchingPairs: {},
        // Use our new mock that `extends` TextfStyleResolver.
        styleResolver: _MockLinkStyleResolver(buildContext),
      );
    }

    group('processLink: Valid Links', () {
      testWidgets('correctly processes a simple link', (tester) async {
        // ARRANGE
        const text = '[link text](http://example.com)';
        final state = await createParserState(tester, text);

        // ACT
        final nextIndex = LinkHandler.processLink(state.styleResolver.context, state, 0);

        // ASSERT
        expect(nextIndex, 5, reason: 'Should consume 5 tokens: [, text, ](, url, )');
        expect(state.spans.length, 1, reason: 'A WidgetSpan for the link should be created');
        expect(state.spans.first, isA<WidgetSpan>());

        final widgetSpan = state.spans.first as WidgetSpan;
        expect(widgetSpan.child, isA<HoverableLinkSpan>());

        final hoverableSpan = widgetSpan.child as HoverableLinkSpan;
        expect(hoverableSpan.url, 'http://example.com');
        expect(hoverableSpan.rawDisplayText, 'link text');
        expect(hoverableSpan.normalStyle.color, Colors.blue, reason: 'Normal style should come from mock resolver');

        expect(state.processedIndices, {0, 1, 2, 3, 4}, reason: 'All link tokens should be marked as processed');
      });
    });

    group('processLink: Invalid Links', () {
      testWidgets('handles text that looks like a link but is not', (tester) async {
        // ARRANGE
        const text = '[unclosed bracket';
        final state = await createParserState(tester, text);

        // ACT
        final nextIndex = LinkHandler.processLink(state.styleResolver.context, state, 0);

        // ASSERT
        expect(nextIndex, isNull, reason: 'Should not process an incomplete link');
        expect(state.spans, isEmpty, reason: 'No span should be created');
        expect(state.textBuffer, '[', reason: 'The opening bracket should be treated as plain text');
        expect(state.processedIndices, {0}, reason: 'Only the opening bracket token should be marked as processed');
      });

      testWidgets('handles link text followed by non-link characters', (tester) async {
        // ARRANGE
        const text = '[link text] but not a url';
        final state = await createParserState(tester, text);

        // ACT
        final nextIndex = LinkHandler.processLink(state.styleResolver.context, state, 0);

        // ASSERT
        expect(nextIndex, isNull);
        expect(state.spans, isEmpty);
        expect(state.textBuffer, '[');
        expect(state.processedIndices, {0});
      });
    });

    group('_normalizeUrl', () {
      test('adds http:// to URLs without a scheme', () {
        expect(LinkHandler.normalizeUrl('example.com'), 'http://example.com');
      });

      test('does not modify URLs that already have a scheme', () {
        expect(LinkHandler.normalizeUrl('https://example.com'), 'https://example.com');
        expect(LinkHandler.normalizeUrl('ftp://example.com'), 'ftp://example.com');
        expect(LinkHandler.normalizeUrl('mailto:test@example.com'), 'mailto:test@example.com');
      });

      test('does not modify relative paths', () {
        expect(LinkHandler.normalizeUrl('/path/to/page'), '/path/to/page');
      });

      test('does not modify anchor links', () {
        expect(LinkHandler.normalizeUrl('#section1'), '#section1');
      });

      test('trims whitespace from URLs', () {
        expect(LinkHandler.normalizeUrl('  example.com  '), 'http://example.com');
      });
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/parsing/components/link_handler_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/unit/parsing/components/nesting_validator_test.dart -->
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/models/token_type.dart';
import 'package:textf/src/parsing/components/nesting_validator.dart';
import 'package:textf/src/parsing/textf_tokenizer.dart';

void main() {
  group('NestingValidator Tests', () {
    // ignore: avoid-late-keyword
    late TextfTokenizer tokenizer;

    setUp(() {
      tokenizer = TextfTokenizer();
    });

    // Helper function to run a validation test.
    // It tokenizes text, finds initial pairs, validates them, and checks the result.
    void testValidation(
      String description,
      String text,
      List<String> expectedValidPairs,
    ) {
      test(description, () {
        // ARRANGE: Tokenize and find all potential pairs (before validation).
        final tokens = tokenizer.tokenize(text);
        final candidatePairs = <int, int>{};
        // This is a simplified version of PairingResolver._identifySimplePairs
        // to get the initial candidates for validation.
        final stacks = <TokenType, List<int>>{};
        for (int i = 0; i < tokens.length; i++) {
          final token = tokens[i];
          if (!token.type.isFormattingMarker) continue;
          final stack = stacks.putIfAbsent(token.type, () => []);
          if (stack.isEmpty) {
            stack.add(i);
          } else {
            final openIndex = stack.removeLast();
            candidatePairs[openIndex] = i;
            candidatePairs[i] = openIndex;
          }
        }

        // ACT: Validate the pairs using the NestingValidator.
        final validatedPairs = NestingValidator.validatePairs(tokens, candidatePairs);

        // ASSERT: Format the result for easy comparison.
        final actualValidPairs = <String>{};
        validatedPairs.forEach((key, value) {
          // Add each pair only once to the set for comparison (from opener to closer).
          if (key < value) {
            actualValidPairs.add('${tokens[key].value} -> ${tokens[value].value}');
          }
        });

        expect(actualValidPairs, unorderedEquals(expectedValidPairs), reason: description);
      });
    }

    group('Valid Nesting Scenarios', () {
      testValidation(
        'should validate correctly nested different markers',
        '**bold with _italic_**',
        ['** -> **', '_ -> _'],
      );

      testValidation(
        'should validate adjacent markers',
        '**bold**_italic_`code`',
        ['** -> **', '_ -> _', '` -> `'],
      );

      testValidation(
        'should validate correctly nested same markers (using different chars)',
        '__bold with _italic_ __',
        ['__ -> __', '_ -> _'],
      );
    });

    group('Invalid Nesting Scenarios', () {
      testValidation(
        'should invalidate overlapping markers',
        // Here, bold opens, then italic opens. But bold closes before italic.
        // This is invalid nesting, so both pairs should be discarded.
        '**bold *and italic** is wrong*',
        [], // Expect no valid pairs.
      );

      testValidation(
        'should invalidate overlapping markers of different types',
        '~~strike with **bold~~ inner**',
        [], // Expect no valid pairs.
      );
    });

    group('Nesting Depth Limit', () {
      // NestingValidator.maxDepth is 2. This test uses 3 levels.
      testValidation(
        'should invalidate pairs exceeding the maximum nesting depth',
        // Level 1: **
        // Level 2: _
        // Level 3: ~~ (This should be invalidated)
        '**level1 _level2 ~~level3~~_**',
        // The outer two pairs are valid and should be kept.
        ['** -> **', '_ -> _'],
      );

      testValidation(
        'should handle multiple pairs at the same depth correctly',
        '**bold _italic_ and `code`**',
        // Italic and code are both at depth 2, which is valid.
        ['** -> **', '_ -> _', '` -> `'],
      );

      testValidation(
        'should invalidate only the deepest pair in a multi-level violation',
        // Level 1: **
        // Level 2: _
        // Level 3: ~~
        // Level 4: `` (Invalid)
        '**_~~`code`~~_**',
        // Only the code pair ` -> ` should be invalidated.
        ['** -> **', '_ -> _'],
      );
    });
  });
}

<!-- END FILE: [v0.6.1] test/unit/parsing/components/nesting_validator_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/widgets/pump_textf_widget.dart -->
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/textf.dart';

// ignore: avoid-top-level-members-in-tests
Future<void> pumpTextfWidget(
  WidgetTester tester, {
  required String data,
  TextStyle? style,
  TextAlign? textAlign,
  int? maxLines,
  TextOverflow? overflow,
  bool? softWrap,
  TextScaler? textScaler,
  TextDirection? textDirection,
  DefaultTextStyle? defaultTextStyle,
  SelectionRegistrar? selectionRegistrar,
  bool wrapInSelectionArea = false,
  Color? selectionColor,
  TextfOptions? textfOptions,
}) async {
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: Builder(
          builder: (context) {
            // Start with the core Textf widget
            Widget finalWidget = Textf(
              data,
              style: style,
              textAlign: textAlign,
              maxLines: maxLines,
              overflow: overflow,
              softWrap: softWrap,
              textScaler: textScaler,
              textDirection: textDirection,
              selectionColor: selectionColor,
            );

            // Wrap with TextfOptions *if provided*
            if (textfOptions != null) {
              finalWidget = TextfOptions(
                key: textfOptions.key, // Pass key if needed

                // Use properties from the passed instance
                onUrlTap: textfOptions.onUrlTap,
                onUrlHover: textfOptions.onUrlHover,
                urlStyle: textfOptions.urlStyle,
                urlHoverStyle: textfOptions.urlHoverStyle,
                urlMouseCursor: textfOptions.urlMouseCursor,
                boldStyle: textfOptions.boldStyle,
                italicStyle: textfOptions.italicStyle,
                boldItalicStyle: textfOptions.boldItalicStyle,
                strikethroughStyle: textfOptions.strikethroughStyle,
                codeStyle: textfOptions.codeStyle,
                child: finalWidget,
              );
            }

            // Wrap with DefaultTextStyle if provided
            if (defaultTextStyle != null) {
              finalWidget = DefaultTextStyle.merge(
                style: defaultTextStyle.style,
                child: finalWidget,
              );
            }

            // Wrap with SelectionArea if requested
            if (wrapInSelectionArea) {
              finalWidget = SelectionArea(
                child: finalWidget,
              );
            }

            // Center the final result
            return Center(child: finalWidget);
          },
        ),
      ),
    ),
  );
}

<!-- END FILE: [v0.6.1] test/widgets/pump_textf_widget.dart -->

<!-- BEGIN FILE: [v0.6.1] test/widgets/textf_options_decoration_test.dart -->
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/textf.dart';

// Helper to find the RichText widget rendered by Textf.
Finder _findRichText() => find.byType(RichText);

// Helper to find a specific TextSpan within the RichText widget by its text content.
// This is crucial for asserting styles on specific parts of the formatted string.
TextSpan _findSpanByText(WidgetTester tester, String text) {
  final richText = tester.widget<RichText>(_findRichText());
  final rootSpan = richText.text as TextSpan;

  TextSpan? foundSpan;
  rootSpan.visitChildren((span) {
    if (span is TextSpan && span.text == text) {
      foundSpan = span;
      return false; // Stop visiting
    }
    return true; // Continue visiting
  });

  if (foundSpan == null) {
    throw StateError('TextSpan with text "$text" not found in the widget tree.');
  }
  return foundSpan!;
}

void main() {
  group('TextfOptions Decoration Combining Tests', () {
    testWidgets(
      'Test Case 1: Nested decorations are correctly combined',
      (tester) async {
        // ARRANGE: Set up a parent with underline and a child with strikethrough.
        await tester.pumpWidget(
          const MaterialApp(
            home: Scaffold(
              body: TextfOptions(
                boldStyle: TextStyle(decoration: TextDecoration.underline),
                child: TextfOptions(
                  boldStyle: TextStyle(
                    decoration: TextDecoration.lineThrough,
                  ),
                  child: Textf(
                    'Some **bold** text.',
                    style: TextStyle(color: Colors.black),
                  ),
                ),
              ),
            ),
          ),
        );

        // ACT: Find the styled span.
        final boldSpan = _findSpanByText(tester, 'bold');

        // ASSERT: Verify that both decorations have been combined.
        expect(
          boldSpan.style?.decoration,
          TextDecoration.combine([
            TextDecoration.underline,
            TextDecoration.lineThrough,
          ]),
          reason: 'Decorations from parent and child options should be combined.',
        );
      },
    );

    testWidgets(
      'Test Case 2: A child option with TextDecoration.none removes parent decoration',
      (tester) async {
        // ARRANGE: Set up a parent with underline and a child that removes it.
        await tester.pumpWidget(
          const MaterialApp(
            home: Scaffold(
              body: TextfOptions(
                boldStyle: TextStyle(
                  decoration: TextDecoration.underline,
                  decorationColor: Colors.blue,
                ),
                child: TextfOptions(
                  boldStyle: TextStyle(decoration: TextDecoration.none),
                  child: Textf(
                    'Some **bold** text.',
                    style: TextStyle(color: Colors.black),
                  ),
                ),
              ),
            ),
          ),
        );

        // ACT: Find the styled span.
        final boldSpan = _findSpanByText(tester, 'bold');

        // ASSERT: Verify that the decoration has been removed.
        expect(
          boldSpan.style?.decoration,
          TextDecoration.none,
          reason: 'Child with TextDecoration.none should remove parent decoration.',
        );
      },
    );

    testWidgets(
      'Test Case 3: Child decoration properties take precedence when combining',
      (tester) async {
        // ARRANGE: Parent and child both define decorations and their properties.
        await tester.pumpWidget(
          const MaterialApp(
            home: Scaffold(
              body: TextfOptions(
                boldStyle: TextStyle(
                  decoration: TextDecoration.underline,
                  decorationColor: Colors.blue,
                  decorationThickness: 2,
                  decorationStyle: TextDecorationStyle.solid,
                ),
                child: TextfOptions(
                  boldStyle: TextStyle(
                    decoration: TextDecoration.lineThrough,
                    decorationColor: Colors.red,
                    decorationThickness: 4,
                    decorationStyle: TextDecorationStyle.wavy,
                  ),
                  child: Textf('Some **bold** text.'),
                ),
              ),
            ),
          ),
        );

        // ACT: Find the styled span.
        final boldSpan = _findSpanByText(tester, 'bold');

        // ASSERT: Verify the final properties are from the child option.
        expect(
          boldSpan.style?.decoration,
          TextDecoration.combine([
            TextDecoration.underline,
            TextDecoration.lineThrough,
          ]),
        );
        expect(
          boldSpan.style?.decorationColor,
          Colors.red,
          reason: 'Child decorationColor should take precedence.',
        );
        expect(
          boldSpan.style?.decorationThickness,
          4.0,
          reason: 'Child decorationThickness should take precedence.',
        );
        expect(
          boldSpan.style?.decorationStyle,
          TextDecorationStyle.wavy,
          reason: 'Child decorationStyle should take precedence.',
        );
      },
    );

    testWidgets(
      'Test Case 4: No-op test (unrelated options do not interfere)',
      (tester) async {
        // ARRANGE: Parent defines a bold style with decoration.
        // Child defines an unrelated italic style.
        await tester.pumpWidget(
          const MaterialApp(
            home: Scaffold(
              body: TextfOptions(
                boldStyle: TextStyle(
                  decoration: TextDecoration.underline,
                  decorationColor: Colors.green,
                ),
                child: TextfOptions(
                  italicStyle: TextStyle(fontStyle: FontStyle.italic),
                  child: Textf('Some **bold** and *italic* text.'),
                ),
              ),
            ),
          ),
        );

        // ACT & ASSERT for bold text.
        final boldSpan = _findSpanByText(tester, 'bold');
        expect(
          boldSpan.style?.decoration,
          TextDecoration.underline,
          reason: 'Bold text should still have its underline from the parent.',
        );
        expect(
          boldSpan.style?.decorationColor,
          Colors.green,
          reason: 'Bold text should have its decoration color from the parent.',
        );

        // ACT & ASSERT for italic text.
        final italicSpan = _findSpanByText(tester, 'italic');
        expect(
          italicSpan.style?.fontStyle,
          FontStyle.italic,
          reason: 'Italic text should have its style from the child option.',
        );
        expect(
          italicSpan.style?.decoration,
          anyOf(isNull, TextDecoration.none),
          reason: 'Italic text should not have any decoration.',
        );
      },
    );
  });
}

<!-- END FILE: [v0.6.1] test/widgets/textf_options_decoration_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/widgets/textf_options_test.dart -->
// ignore_for_file: avoid-non-null-assertion

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:textf/src/core/default_styles.dart';
import 'package:textf/src/models/token_type.dart';
import 'package:textf/src/styling/textf_style_resolver.dart';
import 'package:textf/src/widgets/textf_options.dart';

// ----- Helper Class and Callbacks -----
// ignore: prefer-match-file-name
class _ResolvedOptions {
  _ResolvedOptions({
    this.urlStyle,
    this.urlHoverStyle,
    this.urlMouseCursor,
    this.boldStyle,
    this.italicStyle,
    this.boldItalicStyle,
    this.strikethroughStyle,
    this.codeStyle,
    this.onUrlTap,
    this.onUrlHover,
  });

  // Factory to create from context
  factory _ResolvedOptions.fromContext(BuildContext context, TextStyle baseStyle) {
    final TextfOptions? nearestOptions = TextfOptions.maybeOf(context);
    final ThemeData theme = Theme.of(context); // Get theme for fallbacks

    // Helper to get theme-based link style merged with base
    TextStyle getThemeLinkStyle(TextStyle currentBase) {
      final Color themeLinkColor = theme.colorScheme.primary;
      // Default link style merged onto the current base
      return currentBase.merge(
        TextStyle(
          color: themeLinkColor,
          decoration: TextDecoration.underline,
          decorationColor: themeLinkColor,
        ),
      );
    }

    // Helper to get theme-based code style merged with base
    TextStyle getThemeCodeStyle(TextStyle currentBase) {
      final Color codeBackgroundColor = theme.colorScheme.surfaceContainer;
      final Color codeForegroundColor = theme.colorScheme.onSurfaceVariant;
      const String codeFontFamily = 'monospace';
      // FIX: Use the constant directly from DefaultStyles
      const List<String> codeFontFamilyFallback = DefaultStyles.defaultCodeFontFamilyFallback;

      return currentBase.copyWith(
        fontFamily: codeFontFamily,
        fontFamilyFallback: codeFontFamilyFallback, // Use the constant list
        backgroundColor: codeBackgroundColor,
        color: codeForegroundColor, // Theme color overrides base color
        letterSpacing: currentBase.letterSpacing ?? 0,
        // Other properties like fontSize, height are inherited from currentBase
      );
    }

    // Resolve each property individually, applying fallbacks if options are null
    final resolvedBold = nearestOptions?.getEffectiveBoldStyle(context, baseStyle) ??
        DefaultStyles.boldStyle(baseStyle); // Default fallback

    final resolvedItalic = nearestOptions?.getEffectiveItalicStyle(context, baseStyle) ??
        DefaultStyles.italicStyle(baseStyle); // Default fallback

    final resolvedBoldItalic = nearestOptions?.getEffectiveBoldItalicStyle(context, baseStyle) ??
        DefaultStyles.boldItalicStyle(baseStyle); // Default fallback

    final resolvedStrike = nearestOptions?.getEffectiveStrikethroughStyle(context, baseStyle) ??
        DefaultStyles.strikethroughStyle(baseStyle); // Default fallback

    final resolvedCode = nearestOptions?.getEffectiveCodeStyle(context, baseStyle) ??
        getThemeCodeStyle(baseStyle); // Theme fallback for code

    final resolvedUrl = nearestOptions?.getEffectiveUrlStyle(context, baseStyle) ??
        getThemeLinkStyle(baseStyle); // Theme fallback for links

    // Hover style depends on the resolved *normal* style
    final resolvedUrlHover = nearestOptions?.getEffectiveUrlHoverStyle(context, baseStyle) ??
        resolvedUrl; // Default hover is same as normal if no option

    final resolvedCursor =
        nearestOptions?.getEffectiveUrlMouseCursor(context) ?? DefaultStyles.urlMouseCursor; // Default fallback

    final resolvedTap = nearestOptions?.getEffectiveOnUrlTap(context); // Null if not found
    final resolvedHoverCb = nearestOptions?.getEffectiveOnUrlHover(context); // Null if not found

    return _ResolvedOptions(
      urlStyle: resolvedUrl,
      urlHoverStyle: resolvedUrlHover,
      urlMouseCursor: resolvedCursor,
      boldStyle: resolvedBold,
      italicStyle: resolvedItalic,
      boldItalicStyle: resolvedBoldItalic,
      strikethroughStyle: resolvedStrike,
      codeStyle: resolvedCode,
      onUrlTap: resolvedTap,
      onUrlHover: resolvedHoverCb,
    );
  }
  final TextStyle? urlStyle;
  final TextStyle? urlHoverStyle;
  final MouseCursor? urlMouseCursor;
  final TextStyle? boldStyle;
  final TextStyle? italicStyle;
  final TextStyle? boldItalicStyle;
  final TextStyle? strikethroughStyle;
  final TextStyle? codeStyle;
  final Function? onUrlTap;
  final Function? onUrlHover;
}

// Dummy callbacks
void _dummyTap1(String u, String d) {
  debugPrint('Dummy tap 1: $u, $d');
}

void _dummyHover2(String u, String d, {required bool isHovering}) {
  debugPrint('Dummy hover 2: $u, $d, hovering: $isHovering');
}
// ----------------------------------------------------------

void main() {
  // --- Test Styles & Callbacks (Keep as before) ---
  // Note: baseStyle here is only used when *no* DefaultTextStyle is in context,
  // which isn't the case in these tests due to MaterialApp.
  const baseStyle = TextStyle(fontSize: 16, color: Colors.black);
  const rootBoldStyle = TextStyle(fontWeight: FontWeight.w900, color: Colors.red);
  const rootUrlStyle = TextStyle(color: Colors.blue, decoration: TextDecoration.none);
  const rootCursor = SystemMouseCursors.text;
  const rootOnTap = _dummyTap1;

  const childUrlStyle = TextStyle(color: Colors.green, fontSize: 18);
  const childItalicStyle = TextStyle(fontStyle: FontStyle.normal, backgroundColor: Colors.yellow);

  // ----------------------------------------------------

  group('TextfOptions Inheritance Tests', () {
    testWidgets('Falls back to defaults when no TextfOptions is present', (tester) async {
      _ResolvedOptions? resolved;
      final theme = ThemeData.light(); // Use a specific theme
      TextStyle? capturedDefaultStyle; // To capture the style from context

      await tester.pumpWidget(
        MaterialApp(
          theme: theme, // Provide theme
          home: Builder(
            builder: (context) {
              // Capture the actual DefaultTextStyle from the context where resolved is calculated
              capturedDefaultStyle = DefaultTextStyle.of(context).style;
              // Ensure we captured something sensible before proceeding
              expect(capturedDefaultStyle, isNotNull, reason: 'Failed to capture DefaultTextStyle');
              expect(
                capturedDefaultStyle!.fontSize,
                isNotNull,
                reason: 'Captured DefaultTextStyle must have a fontSize',
              );
              // Pass the captured style explicitly as the base style
              resolved = _ResolvedOptions.fromContext(context, capturedDefaultStyle!);
              return const SizedBox();
            },
          ),
        ),
      );

      // Ensure resolution happened
      expect(resolved, isNotNull, reason: 'ResolvedOptions should not be null after pump');

      // Ensure the captured style is still valid before using it in expectations
      expect(capturedDefaultStyle, isNotNull, reason: 'DefaultTextStyle should be available after pump');
      expect(capturedDefaultStyle!.fontSize, isNotNull, reason: 'DefaultTextStyle must have a fontSize after pump');

      // Verify resolved options match defaults merged with the capturedDefaultStyle

      // --- Check URL Style ---
      // Check inherited properties first
      expect(
        resolved!.urlStyle?.fontSize,
        capturedDefaultStyle!.fontSize, // Compare against the captured default size
        reason: 'URL style font size should match the DefaultTextStyle font size',
      );
      expect(
        resolved!.urlStyle?.fontFamily,
        capturedDefaultStyle!.fontFamily,
        reason: 'URL style font family should match the DefaultTextStyle font family',
      );
      // Check properties overridden by theme link style
      expect(
        resolved!.urlStyle?.color,
        theme.colorScheme.primary,
        reason: 'URL style color should be theme primary color',
      );
      expect(
        resolved!.urlStyle?.decoration,
        TextDecoration.underline,
        reason: 'URL style decoration should be underline',
      );
      expect(
        resolved!.urlStyle?.decorationColor,
        theme.colorScheme.primary,
        reason: 'URL style decoration color should be theme primary color',
      );

      // --- Check other styles (ensure they also use the correct base) ---
      expect(
        resolved!.boldStyle?.fontSize,
        capturedDefaultStyle!.fontSize,
        reason: 'Bold style font size should match default',
      );
      expect(resolved!.boldStyle?.fontWeight, DefaultStyles.boldStyle(capturedDefaultStyle!).fontWeight);

      expect(
        resolved!.italicStyle?.fontSize,
        capturedDefaultStyle!.fontSize,
        reason: 'Italic style font size should match default',
      );
      expect(resolved!.italicStyle?.fontStyle, DefaultStyles.italicStyle(capturedDefaultStyle!).fontStyle);

      // Code Style: Check against theme defaults merged with base
      expect(
        resolved!.codeStyle?.fontSize,
        capturedDefaultStyle!.fontSize,
        reason: 'Code style font size should match default',
      );
      expect(resolved!.codeStyle?.fontFamily, 'monospace');
      expect(resolved!.codeStyle?.color, theme.colorScheme.onSurfaceVariant);
      expect(resolved!.codeStyle?.backgroundColor, theme.colorScheme.surfaceContainer);

      // --- Check non-style properties ---
      expect(resolved!.urlMouseCursor, DefaultStyles.urlMouseCursor);
      expect(resolved!.onUrlTap, isNull);
      expect(resolved!.onUrlHover, isNull);
    });

    testWidgets('Uses values from single ancestor', (tester) async {
      _ResolvedOptions? resolved;
      final theme = ThemeData.light();

      await tester.pumpWidget(
        MaterialApp(
          theme: theme,
          home: TextfOptions(
            boldStyle: rootBoldStyle,
            urlStyle: rootUrlStyle, // blue, no decoration
            urlMouseCursor: rootCursor,
            onUrlTap: rootOnTap,
            // italicStyle left null
            child: Builder(
              builder: (context) {
                resolved = _ResolvedOptions.fromContext(context, baseStyle);
                return const SizedBox();
              },
            ),
          ),
        ),
      );

      expect(resolved, isNotNull);
      // Check specified values (merged with base)
      expect(resolved!.boldStyle?.fontWeight, rootBoldStyle.fontWeight);
      expect(resolved!.boldStyle?.color, rootBoldStyle.color);
      expect(resolved!.boldStyle?.fontSize, baseStyle.fontSize); // Merged from base
      expect(resolved!.urlStyle?.color, rootUrlStyle.color); // Should be root blue
      expect(resolved!.urlStyle?.decoration, rootUrlStyle.decoration); // none from root
      expect(resolved!.urlStyle?.fontSize, baseStyle.fontSize); // Merged from base
      expect(resolved!.urlMouseCursor, rootCursor);
      expect(resolved!.onUrlTap, same(rootOnTap));
      // Check unspecified (falls back to default effect on base)
      expect(resolved!.italicStyle?.fontStyle, DefaultStyles.italicStyle(baseStyle).fontStyle); // Default italic
      expect(resolved!.italicStyle?.color, baseStyle.color); // Base color
      // Check unspecified callback
      expect(resolved!.onUrlHover, isNull);
    });

    testWidgets('Child properties correctly merge with and override parent properties', (tester) async {
      // SETUP
      const baseStyle = TextStyle(fontSize: 16, color: Colors.black);
      const rootUrlStyle = TextStyle(color: Colors.blue, decoration: TextDecoration.none);
      // ignore: no-empty-block
      void rootOnTap(String u, String d) {}
      const rootItalicStyle = TextStyle(fontStyle: FontStyle.italic, color: Colors.purple);

      const childUrlStyle = TextStyle(color: Colors.green, fontSize: 18); // No decoration specified
      // ignore: no-empty-block
      void childOnTap(String u, String d) {}

      await tester.pumpWidget(
        MaterialApp(
          home: TextfOptions(
            // Root
            urlStyle: rootUrlStyle,
            onUrlTap: rootOnTap,
            italicStyle: rootItalicStyle,
            child: TextfOptions(
              // Child override
              urlStyle: childUrlStyle,
              onUrlTap: childOnTap,
              // Italic style NOT specified here, so it should be inherited.
              child: const SizedBox(), // Dummy child for context
            ),
          ),
        ),
      );

      // ARRANGE: Get context and create the resolver
      final BuildContext context = tester.element(find.byType(SizedBox));
      final resolver = TextfStyleResolver(context);

      // --- ASSERT MERGED URL STYLE ---
      final resolvedUrlStyle = resolver.resolveLinkStyle(baseStyle);

      // Properties from child should win
      expect(
        resolvedUrlStyle.color,
        childUrlStyle.color,
        reason: 'Child color (green) should override parent color (blue).',
      );
      expect(
        resolvedUrlStyle.fontSize,
        childUrlStyle.fontSize,
        reason: 'Child font size (18) should override base style size (16).',
      );
      // Property from parent should be inherited
      expect(
        resolvedUrlStyle.decoration,
        rootUrlStyle.decoration, // TextDecoration.none
        reason: 'Parent decoration should be inherited as child did not specify one.',
      );

      // --- ASSERT INHERITED ITALIC STYLE ---
      final resolvedItalicStyle = resolver.resolveStyle(TokenType.italicMarker, baseStyle);
      expect(
        resolvedItalicStyle.color,
        rootItalicStyle.color,
        reason: 'Italic color should be inherited from parent.',
      );
      expect(
        resolvedItalicStyle.fontStyle,
        rootItalicStyle.fontStyle,
        reason: 'Italic style should be inherited from parent.',
      );

      // --- ASSERT CALLBACK (NEAREST WINS) ---
      expect(
        resolver.resolveOnUrlTap(),
        childOnTap,
        reason: 'Callback should come from the nearest (child) ancestor.',
      );
    });

    testWidgets('Unspecified child properties are correctly inherited from parent', (tester) async {
      // SETUP
      const baseStyle = TextStyle(fontSize: 16, color: Colors.black);
      const rootBoldStyle = TextStyle(fontWeight: FontWeight.w900, color: Colors.red);
      // ignore: no-empty-block
      void rootOnTap(String u, String d) {}
      const rootUrlStyle = TextStyle(color: Colors.blue, decoration: TextDecoration.none);

      const childUrlStyle = TextStyle(color: Colors.green, fontSize: 18);
      const childItalicStyle = TextStyle(fontStyle: FontStyle.normal, backgroundColor: Colors.yellow);
      // ignore: no-empty-block
      void childOnHover(String u, String d, {required bool isHovering}) {}

      await tester.pumpWidget(
        MaterialApp(
          home: TextfOptions(
            // Root (provides bold, tap, rootUrl)
            boldStyle: rootBoldStyle,
            onUrlTap: rootOnTap,
            urlStyle: rootUrlStyle,
            child: TextfOptions(
              // Child (provides childUrl, italic, hover, but NOT bold or tap)
              urlStyle: childUrlStyle,
              italicStyle: childItalicStyle,
              onUrlHover: childOnHover,
              child: const SizedBox(),
            ),
          ),
        ),
      );

      // ARRANGE
      final BuildContext context = tester.element(find.byType(SizedBox));
      final resolver = TextfStyleResolver(context);

      // --- 1. Assert properties specified ONLY in Child ---
      final resolvedItalic = resolver.resolveStyle(TokenType.italicMarker, baseStyle);
      expect(resolvedItalic.fontStyle, childItalicStyle.fontStyle);
      expect(resolvedItalic.backgroundColor, childItalicStyle.backgroundColor);
      expect(resolver.resolveOnUrlHover(), childOnHover);

      // --- 2. Assert properties MERGED between Parent and Child ---
      final resolvedUrl = resolver.resolveLinkStyle(baseStyle);
      expect(
        resolvedUrl.color,
        childUrlStyle.color, // Green from Child wins
        reason: 'Child URL color should override Parent.',
      );
      expect(
        resolvedUrl.decoration,
        rootUrlStyle.decoration, // Decoration from Parent is inherited
        reason: "Child did not specify a decoration, so Parent's should be used.",
      );

      // --- 3. Assert properties inherited from Parent because Child did not specify them ---
      final resolvedBold = resolver.resolveStyle(TokenType.boldMarker, baseStyle);
      expect(resolvedBold.fontWeight, rootBoldStyle.fontWeight);
      expect(resolvedBold.color, rootBoldStyle.color);
      expect(resolver.resolveOnUrlTap(), rootOnTap);
    });

    testWidgets('Inheritance works across multiple levels', (tester) async {
      _ResolvedOptions? resolved;
      final theme = ThemeData.light();

      await tester.pumpWidget(
        MaterialApp(
          theme: theme,
          home: TextfOptions(
            // Level 1 (Root: bold, tap)
            boldStyle: rootBoldStyle, // w900, red
            onUrlTap: rootOnTap,
            child: TextfOptions(
              // Level 2 (Mid: italic)
              italicStyle: childItalicStyle, // normal, yellow bg
              child: TextfOptions(
                // Level 3 (Leaf: url, hover)
                urlStyle: childUrlStyle, // green, 18
                onUrlHover: _dummyHover2,
                // codeStyle not specified anywhere
                child: Builder(
                  builder: (context) {
                    resolved = _ResolvedOptions.fromContext(context, baseStyle); // black, 16
                    return const SizedBox();
                  },
                ),
              ),
            ),
          ),
        ),
      );

      expect(resolved, isNotNull);
      // Comes from Leaf (Level 3)
      expect(resolved!.urlStyle?.color, childUrlStyle.color); // green
      expect(resolved!.urlStyle?.fontSize, childUrlStyle.fontSize); // 18
      expect(resolved!.onUrlHover, same(_dummyHover2));
      // Comes from Mid (Level 2)
      expect(resolved!.italicStyle?.backgroundColor, childItalicStyle.backgroundColor); // yellow bg
      expect(resolved!.italicStyle?.fontStyle, childItalicStyle.fontStyle); // normal
      // Comes from Root (Level 1)
      expect(resolved!.boldStyle?.fontWeight, rootBoldStyle.fontWeight); // w900
      expect(resolved!.boldStyle?.color, rootBoldStyle.color); // red
      expect(resolved!.onUrlTap, same(rootOnTap));
      // Comes from Default (Not specified anywhere) - Check Code style default
      expect(
        resolved!.codeStyle?.fontFamily,
        'monospace', // Expect default monospace
        reason: 'Code style fallback should use monospace font',
      );
      expect(resolved!.codeStyle?.color, theme.colorScheme.onSurfaceVariant); // Theme color
      expect(resolved!.urlMouseCursor, DefaultStyles.urlMouseCursor); // Default cursor
    });

    testWidgets('Correctly merges styles with baseStyle', (tester) async {
      _ResolvedOptions? resolved;
      final theme = ThemeData.light();
      // Use a distinct base style
      const specificBaseStyle = TextStyle(fontSize: 10, fontFamily: 'Arial', color: Colors.grey);

      await tester.pumpWidget(
        MaterialApp(
          theme: theme,
          home: TextfOptions(
            boldStyle: const TextStyle(fontWeight: FontWeight.bold, color: Colors.red), // Override weight and color
            italicStyle: const TextStyle(fontStyle: FontStyle.italic), // Only specify italic effect
            urlStyle: const TextStyle(
              // Specify only decoration properties
              decoration: TextDecoration.lineThrough,
              decorationColor: Colors.orange,
            ),
            child: Builder(
              builder: (context) {
                resolved = _ResolvedOptions.fromContext(context, specificBaseStyle); // grey, 10, Arial
                return const SizedBox();
              },
            ),
          ),
        ),
      );
      expect(resolved, isNotNull);

      // Bold: Should have specific base props + override props
      expect(resolved!.boldStyle?.fontWeight, FontWeight.bold); // from override
      expect(resolved!.boldStyle?.color, Colors.red); // from override
      expect(resolved!.boldStyle?.fontSize, specificBaseStyle.fontSize); // from base
      expect(resolved!.boldStyle?.fontFamily, specificBaseStyle.fontFamily); // from base

      // Italic: Should have specific base props + default italic effect
      expect(resolved!.italicStyle?.fontStyle, FontStyle.italic); // from override
      expect(resolved!.italicStyle?.color, specificBaseStyle.color); // from base
      expect(resolved!.italicStyle?.fontSize, specificBaseStyle.fontSize); // from base

      // URL: Should have base props + override props. Color comes from base as option didn't specify it.
      expect(resolved!.urlStyle?.decoration, TextDecoration.lineThrough); // from override
      expect(resolved!.urlStyle?.decorationColor, Colors.orange); // from override
      expect(
        resolved!.urlStyle?.color,
        specificBaseStyle.color, // Should be grey from base
        reason: "URL color should be from baseStyle as option didn't specify it",
      );
      expect(resolved!.urlStyle?.fontSize, specificBaseStyle.fontSize); // from base
      expect(resolved!.urlStyle?.fontFamily, specificBaseStyle.fontFamily); // from base
    });
  });
}

<!-- END FILE: [v0.6.1] test/widgets/textf_options_test.dart -->

<!-- BEGIN FILE: [v0.6.1] test/widgets/textf_widget_test.dart -->
// ignore_for_file: cascade_invocations // cascade_invocations for readability and chaining methods., avoid-non-null-assertion, no-magic-number
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'pump_textf_widget.dart';

// Helper to find the RichText widget rendered by Textf
Finder _findRichText() => find.byType(RichText);

// Helper to get the root TextSpan from the found RichText
TextSpan _getRootTextSpan(WidgetTester tester) {
  final richText = tester.widget<RichText>(_findRichText());
  expect(richText.text, isA<TextSpan>());
  return richText.text as TextSpan;
}

void main() {
  group('Textf Widget Tests', () {
    testWidgets('Renders plain text correctly', (tester) async {
      const text = 'This is plain text.';
      await pumpTextfWidget(tester, data: text);

      // --- Basic Checks ---
      expect(find.text(text), findsOneWidget); // Verify the text exists visually
      expect(_findRichText(), findsOneWidget); // Verify RichText is used

      // --- Inspecting the Span Tree ---
      final rootSpan = _getRootTextSpan(tester); // This is the span passed to Text.rich

      // Expectation 1: The root span itself usually has no direct text
      expect(rootSpan.text, isNull, reason: 'Root span from Text.rich usually has null text');

      // Expectation 2: The root span's children list contains the spans from the parser
      expect(rootSpan.children, isNotNull, reason: 'Root span should have children from parser');
      expect(rootSpan.children!.length, 1, reason: 'Parser fast-path should return one primary span');

      // Get the first span returned by the parser
      final parserSpan = rootSpan.children!.first;
      expect(parserSpan, isA<TextSpan>(), reason: 'Parser result should be a TextSpan');

      // --- Accommodation for the observed deeper nesting ---
      // Based on your feedback, we check if this parserSpan *also* nests the text
      final actualTextSpan = parserSpan as TextSpan;

      expect(actualTextSpan.children!.length, 1, reason: 'Nested structure should contain one text span');
      final innermostSpan = actualTextSpan.children!.first;
      expect(innermostSpan, isA<TextSpan>(), reason: 'Innermost element should be a TextSpan');
      expect((innermostSpan as TextSpan).text, text, reason: 'Innermost span should contain the text');
      expect(innermostSpan.children, isNull, reason: 'Innermost span should not have further children');
    });

    testWidgets('Renders basic bold formatting', (tester) async {
      const text = 'Some **bold** text';
      await pumpTextfWidget(tester, data: text);

      expect(find.textContaining('Some bold text'), findsOneWidget);
      final rootSpan = _getRootTextSpan(tester);
      // Root span should have no text itself, but children
      expect(rootSpan.text, isNull);
      expect(rootSpan.children, isNotNull);

      expect(rootSpan.children!.length, 1, reason: 'Test failure indicates only one direct child');
      final containerSpan = rootSpan.children!.first as TextSpan;
      expect(containerSpan.children, isNotNull, reason: 'The container span should hold the actual segments');
      final actualSpans = containerSpan.children!;

      // Now assert the length and content of the *actual* spans
      expect(actualSpans.length, 3, reason: "Expected 3 segments: 'Some ', bold, ' text'");

      expect((actualSpans.first as TextSpan).text, 'Some ');
      expect((actualSpans[1] as TextSpan).text, 'bold');
      expect((actualSpans[1] as TextSpan).style?.fontWeight, FontWeight.bold);
      expect((actualSpans[2] as TextSpan).text, ' text');
    });

    testWidgets('Renders basic italic formatting', (tester) async {
      const text = 'Some *italic* text';
      await pumpTextfWidget(tester, data: text);

      final rootSpan = _getRootTextSpan(tester);
      expect(rootSpan.children, isNotNull);

      expect(rootSpan.children!.length, 1, reason: 'Test failure indicates only one direct child');
      final containerSpan = rootSpan.children!.first as TextSpan;
      expect(containerSpan.children, isNotNull);
      final actualSpans = containerSpan.children!;
      expect(actualSpans.length, 3, reason: "Expected 3 segments: 'Some ', italic, ' text'");

      expect((actualSpans.first as TextSpan).text, 'Some ');
      expect((actualSpans[1] as TextSpan).text, 'italic');
      expect((actualSpans[1] as TextSpan).style?.fontStyle, FontStyle.italic);
      expect((actualSpans[2] as TextSpan).text, ' text');
    });

    testWidgets('Renders mixed formatting', (tester) async {
      const text = '**Bold** and *italic*.';
      await pumpTextfWidget(tester, data: text);

      expect(find.textContaining('Bold and italic.'), findsOneWidget);
      final rootSpan = _getRootTextSpan(tester);
      expect(rootSpan.children, isNotNull);

      expect(rootSpan.children!.length, 1, reason: 'Test failure indicates only one direct child');
      final containerSpan = rootSpan.children!.first as TextSpan;
      expect(containerSpan.children, isNotNull);
      final actualSpans = containerSpan.children!;
      expect(actualSpans.length, 4, reason: "Expected 4 segments: bold, ' and ', italic, '.'");

      final boldSpan = actualSpans.first as TextSpan;
      expect(boldSpan.style?.fontWeight, FontWeight.bold);
      expect(boldSpan.text, 'Bold');

      final italicSpan = actualSpans[2] as TextSpan;
      expect(italicSpan.style?.fontStyle, FontStyle.italic);
      expect(italicSpan.text, 'italic');

      expect((actualSpans[1] as TextSpan).text, ' and ');
      expect((actualSpans[3] as TextSpan).text, '.');
    });

    testWidgets('Applies textAlign correctly', (tester) async {
      const text = 'Some **centered** text';
      await pumpTextfWidget(tester, data: text, textAlign: TextAlign.center);

      final richText = tester.widget<RichText>(_findRichText());
      expect(richText.textAlign, TextAlign.center);
    });

    testWidgets('Applies maxLines and overflow correctly', (tester) async {
      const text = 'This is **very long text** that will definitely overflow '
          'when maxLines is set to one.';
      await pumpTextfWidget(
        tester,
        data: text,
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      );

      final richText = tester.widget<RichText>(_findRichText());
      expect(richText.maxLines, 1);
      expect(richText.overflow, TextOverflow.ellipsis);
      // NOTE: Verifying the actual visual ellipsis is hard in widget tests.
      // Checking the properties is usually sufficient. Golden tests are better for visuals.
    });

    testWidgets('Applies softWrap correctly', (tester) async {
      const text = 'Some **text** to wrap or not wrap.';
      await pumpTextfWidget(tester, data: text, softWrap: false);

      final richText = tester.widget<RichText>(_findRichText());
      expect(richText.softWrap, false);

      await pumpTextfWidget(tester, data: text, softWrap: true);
      final richTextWrapped = tester.widget<RichText>(_findRichText());
      expect(richTextWrapped.softWrap, true);
    });

    testWidgets('Applies textScaler correctly', (tester) async {
      const text = 'Some **scalable** text';
      const scaler = TextScaler.linear(1.5);
      await pumpTextfWidget(tester, data: text, textScaler: scaler);

      final richText = tester.widget<RichText>(_findRichText());
      expect(richText.textScaler, scaler);
    });

    testWidgets('Applies textDirection correctly', (tester) async {
      const text = '**RTL** text example';
      await pumpTextfWidget(tester, data: text, textDirection: TextDirection.rtl);

      final richText = tester.widget<RichText>(_findRichText());
      expect(richText.textDirection, TextDirection.rtl);
    });

    testWidgets('Inherits style from DefaultTextStyle', (tester) async {
      const text = 'Inherited **style**';
      const defaultStyle = TextStyle(color: Colors.red, fontSize: 20);

      await pumpTextfWidget(
        tester,
        data: text,
        defaultTextStyle: const DefaultTextStyle(style: defaultStyle, child: SizedBox()),
      );

      final rootSpan = _getRootTextSpan(tester);

      // --- Check Root Span Style ---
      // The root span itself should have the default style merged by Text.rich
      expect(rootSpan.style?.color, defaultStyle.color);
      expect(rootSpan.style?.fontSize, defaultStyle.fontSize);
      expect(rootSpan.children, isNotNull);

      // --- Apply Nesting ---
      expect(rootSpan.children!.length, 1, reason: 'Structure has container span');
      final containerSpan = rootSpan.children!.first as TextSpan;
      expect(containerSpan.children, isNotNull);
      final actualSpans = containerSpan.children!;
      expect(actualSpans.length, 2, reason: "Expected 2 segments: 'Inherited ', style");

      // --- Check Inherited Span ---
      final plainSpan = actualSpans.first as TextSpan;
      // This plain span *should* also inherit the default style
      expect(plainSpan.style?.color, defaultStyle.color);
      expect(plainSpan.style?.fontSize, defaultStyle.fontSize);
      expect(plainSpan.text, 'Inherited ');

      // --- Check Bold Span ---
      // Find the bold span within the *actual* segments
      final boldSpan = actualSpans[1] as TextSpan; // We know it's the second one
      expect(boldSpan.text, 'style');
      // Verify it inherited default style properties
      expect(boldSpan.style?.color, defaultStyle.color);
      expect(boldSpan.style?.fontSize, defaultStyle.fontSize);
      // Verify bold was applied on top
      expect(boldSpan.style?.fontWeight, FontWeight.bold);
    });

    testWidgets('Explicit style overrides DefaultTextStyle', (tester) async {
      const text = 'Explicit **style** wins'; // Input has 3 parts
      const defaultStyle = TextStyle(color: Colors.red, fontSize: 20);
      const explicitStyle = TextStyle(color: Colors.blue, fontSize: 16);

      await pumpTextfWidget(
        tester,
        data: text,
        style: explicitStyle, // Explicit style provided to Textf
        defaultTextStyle: const DefaultTextStyle(style: defaultStyle, child: SizedBox()),
      );

      final rootSpan = _getRootTextSpan(tester);

      // Root span reflects ambient DefaultTextStyle
      expect(rootSpan.style?.color, defaultStyle.color);
      expect(rootSpan.style?.fontSize, defaultStyle.fontSize);
      expect(rootSpan.children, isNotNull);

      // Apply Nesting
      expect(rootSpan.children!.length, 1);
      final containerSpan = rootSpan.children!.first as TextSpan;
      expect(containerSpan.children, isNotNull);
      final actualSpans = containerSpan.children!;

      expect(actualSpans.length, 3, reason: "Expected 3 segments: 'Explicit ', style (bold), ' wins'");

      // --- Check Inner Spans ---
      final plainSpan1 = actualSpans.first as TextSpan;
      final boldSpan = actualSpans[1] as TextSpan;
      final plainSpan2 = actualSpans[2] as TextSpan;

      // Check Segment 1: "Explicit "
      expect(plainSpan1.text, 'Explicit ');
      expect(plainSpan1.style?.color, explicitStyle.color); // Parsed with explicitStyle
      expect(plainSpan1.style?.fontSize, explicitStyle.fontSize); // Parsed with explicitStyle

      // Check Segment 2: "style" (bold)
      expect(boldSpan.text, 'style');
      expect(boldSpan.style?.color, explicitStyle.color); // Inherited from explicitStyle base
      expect(boldSpan.style?.fontSize, explicitStyle.fontSize); // Inherited from explicitStyle base
      expect(boldSpan.style?.fontWeight, FontWeight.bold); // Added by formatting

      // Check Segment 3: " wins"
      expect(plainSpan2.text, ' wins');
      expect(plainSpan2.style?.color, explicitStyle.color); // Parsed with explicitStyle
      expect(plainSpan2.style?.fontSize, explicitStyle.fontSize); // Parsed with explicitStyle
    });

    testWidgets('Integrates with SelectionArea', (tester) async {
      const text = 'Select **this** text';

      await pumpTextfWidget(
        tester,
        data: text,
        wrapInSelectionArea: true, // <<< TELL THE HELPER TO WRAP
      );

      // Verify the core widgets are present
      expect(find.byType(SelectionArea), findsOneWidget); // <<< THIS SHOULD PASS NOW
      expect(_findRichText(), findsOneWidget);

      // Verify the text content is rendered somewhere within the RichText
      expect(find.textContaining('Select this text', findRichText: true), findsOneWidget);

      // Check if RichText got a selection color from the SelectionArea context
      final richText = tester.widget<RichText>(_findRichText());
      expect(richText.selectionColor, isNotNull);
    });
  });
}

<!-- END FILE: [v0.6.1] test/widgets/textf_widget_test.dart -->

---
Generated with llmifier v0.2.2
Created by Software Engineering Philipp Gerber
Repository: https://github.com/PhilippHGerber/llmifier
Package: https://pub.dev/packages/llmifier
